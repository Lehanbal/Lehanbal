<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/pace-js@1.2.4/themes/yellow/pace-theme-bounce.css">
  <script src="https://unpkg.com/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"lehanbal.top","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.12.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="ArrayDeque是Deque接口的一个实现，使用了可变数组，所以没有容量上的限制。同时，ArrayDeque是线程不安全的，在没有外部同步的情况下，不能再多线程环境下使用。ArrayDeque是Deque的实现类，可以作为栈来使用，效率高于Stack；也可以作为队列来使用，效率高于LinkedList。需要注意的是，ArrayDeque不支持null值。 说人话，就是一个比Stack栈效率高，">
<meta property="og:type" content="article">
<meta property="og:title" content="谈谈Deque">
<meta property="og:url" content="https://lehanbal.top/2020/10/29/%E8%B0%88%E8%B0%88Deque/index.html">
<meta property="og:site_name" content="Take it ez">
<meta property="og:description" content="ArrayDeque是Deque接口的一个实现，使用了可变数组，所以没有容量上的限制。同时，ArrayDeque是线程不安全的，在没有外部同步的情况下，不能再多线程环境下使用。ArrayDeque是Deque的实现类，可以作为栈来使用，效率高于Stack；也可以作为队列来使用，效率高于LinkedList。需要注意的是，ArrayDeque不支持null值。 说人话，就是一个比Stack栈效率高，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://cdn.lehanbal.top/%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png">
<meta property="og:image" content="http://cdn.lehanbal.top/%E7%BA%BF%E6%80%A7%E6%95%B0%E7%BB%84%E4%B8%8E%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84.png">
<meta property="og:image" content="http://cdn.lehanbal.top/LinkedList%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E5%9B%BE.png">
<meta property="og:image" content="http://cdn.lehanbal.top/LinkedList.png">
<meta property="og:image" content="http://cdn.lehanbal.top/LinkedList%E5%8A%A0%E5%85%A5%E6%96%B0%E5%85%83%E7%B4%A0%E7%9A%84%E6%AD%A5%E9%AA%A4.png">
<meta property="og:image" content="http://cdn.lehanbal.top/LinkedList%E6%96%AD%E5%BC%80%E8%BF%87%E7%A8%8B.png">
<meta property="article:published_time" content="2020-10-29T07:09:21.000Z">
<meta property="article:modified_time" content="2022-07-28T05:08:41.923Z">
<meta property="article:author" content="Lehanbal">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="JAVA">
<meta property="article:tag" content="Deque">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://cdn.lehanbal.top/%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png">


<link rel="canonical" href="https://lehanbal.top/2020/10/29/%E8%B0%88%E8%B0%88Deque/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://lehanbal.top/2020/10/29/%E8%B0%88%E8%B0%88Deque/","path":"2020/10/29/谈谈Deque/","title":"谈谈Deque"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>谈谈Deque | Take it ez</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Take it ez</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">lehanbal's blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Deque%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.</span> <span class="nav-text">Deque接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayDeque"><span class="nav-number">2.</span> <span class="nav-text">ArrayDeque</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81"><span class="nav-number">2.1.</span> <span class="nav-text">源码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A2%9E"><span class="nav-number">2.1.1.</span> <span class="nav-text">增</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0"><span class="nav-number">2.1.2.</span> <span class="nav-text">删</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5"><span class="nav-number">2.1.3.</span> <span class="nav-text">查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%A2%9E%E5%87%BD%E6%95%B0"><span class="nav-number">2.1.4.</span> <span class="nav-text">扩增函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedList"><span class="nav-number">3.</span> <span class="nav-text">LinkedList</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-1"><span class="nav-number">3.1.</span> <span class="nav-text">源码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A2%9E-1"><span class="nav-number">3.1.1.</span> <span class="nav-text">增</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0-1"><span class="nav-number">3.1.2.</span> <span class="nav-text">删</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5-1"><span class="nav-number">3.1.3.</span> <span class="nav-text">查</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayDeque%E4%B8%8ELinkedList"><span class="nav-number">4.</span> <span class="nav-text">ArrayDeque与LinkedList</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lehanbal"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Lehanbal</p>
  <div class="site-description" itemprop="description">Just do it!</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/lehanbal" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lehanbal" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:huai1230@qq.com" title="E-Mail → mailto:huai1230@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/lehanbal" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lehanbal.top/2020/10/29/%E8%B0%88%E8%B0%88Deque/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Lehanbal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Take it ez">
      <meta itemprop="description" content="Just do it!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="谈谈Deque | Take it ez">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          谈谈Deque
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-29 15:09:21" itemprop="dateCreated datePublished" datetime="2020-10-29T15:09:21+08:00">2020-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-28 13:08:41" itemprop="dateModified" datetime="2022-07-28T13:08:41+08:00">2022-07-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><code>ArrayDeque</code>是<code>Deque</code>接口的一个实现，使用了可变数组，所以没有容量上的限制。同时，<code>ArrayDeque</code>是线程不安全的，在没有外部同步的情况下，不能再多线程环境下使用。<code>ArrayDeque</code>是<code>Deque</code>的实现类，可以作为栈来使用，效率高于<code>Stack</code>；也可以作为队列来使用，效率高于<code>LinkedList</code>。需要注意的是，<code>ArrayDeque</code>不支持<code>null</code>值。</p>
<p>说人话，就是一个比Stack栈效率高，比LinkedList队列效率高的又能当栈又能当队列用的万金油集合，但是不支持多线程，我们来详细看看这到底是个啥，为什么说他性能比Stack和LinkedList要高。</p>
<h2 id="Deque接口"><a href="#Deque接口" class="headerlink" title="Deque接口"></a>Deque接口</h2><p>继承关系如下图：</p>
<p><img src="http://cdn.lehanbal.top/%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="继承关系"></p>
<p>学习一个类，就从它的父类进行学习，所以我们从它的继承关系来看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDeque</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p>继承了Deque接口，Deque这个接口啊，提供了插入，移除和检查元素的方法。deque是“双端队列”的缩写，也就是说，只要是集成了Deque这个接口，都能够实现双端操作。</p>
<p>与List不同，这个接口不支持索引访问元素。</p>
<p>Queue、Stack以及Deque各个接口的方法对比</p>
<table>
<thead>
<tr>
<th align="center">Queue Method</th>
<th align="center">Stack Method</th>
<th align="center">Deque Method</th>
<th align="center"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">add(e)</td>
<td align="center">push(e)</td>
<td align="center">addLast(e)</td>
<td align="center">向队尾\栈顶插入元素，失败则抛出异常</td>
</tr>
<tr>
<td align="center">offer(e)</td>
<td align="center">无</td>
<td align="center">offerLast(e)</td>
<td align="center">向队尾\栈顶插入元素，失败则返回false</td>
</tr>
<tr>
<td align="center">remove()</td>
<td align="center">pop()</td>
<td align="center">removeFirst()</td>
<td align="center">获取并删除队首\栈顶元素，失败则抛出异常</td>
</tr>
<tr>
<td align="center">poll()</td>
<td align="center">无</td>
<td align="center">pollFirst()</td>
<td align="center">获取并删除队首\栈顶元素，失败则返回null</td>
</tr>
<tr>
<td align="center">element()</td>
<td align="center">peek()</td>
<td align="center">getFirst()</td>
<td align="center">获取但不删除队首\栈顶元素，失败则抛出异常</td>
</tr>
<tr>
<td align="center">peek()</td>
<td align="center">无</td>
<td align="center">peekFirst()</td>
<td align="center">获取但不删除队\栈顶首元素，失败则返回null</td>
</tr>
</tbody></table>
<p>这个类给我们分别定义了两套获取元素和插入元素的方法，一套会抛出异常，而另一套只会返回对应的状态值。</p>
<p><strong>Stack不被支持继续使用，它继承自Vector类，Vector因为性能问题已经忌用，所以它的子类也会有类似的问题</strong></p>
<h2 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h2><p><em>ArrayDeque</em>是Deque的一个实现类，底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即<strong>循环数组（circular array）</strong>，也就是说数组的任何一点都可能被看作起点或者终点。</p>
<p><em>ArrayDeque</em>是非线程安全的（not thread-safe），当多个线程同时使用的时候，需要程序员手动同步；另外，<strong>该容器不允许放入null元素</strong>，<strong>该容器不允许放入null元素</strong>，<strong>该容器不允许放入null元素</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存储元素的数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elements;</span><br><span class="line">   <span class="comment">//头部元素索引</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> head;</span><br><span class="line">   <span class="comment">//尾部要加入元素的索引</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> tail;</span><br></pre></td></tr></table></figure>

<p>数组遇到插入元素是一件很苦恼的事情，巧妙地利用循环数组可以直接将元素向头部之前添加元素，并不需要大面积地移动数据。</p>
<p>线性数组与循环数组插入元素地区别图：<strong>（注意头指针和尾指针的位置！头指针指向的是第一个元素，尾指针则是指向最后一个元素的后一位）</strong></p>
<p><img src="http://cdn.lehanbal.top/%E7%BA%BF%E6%80%A7%E6%95%B0%E7%BB%84%E4%B8%8E%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84.png" alt="线性数组与循环数组"></p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>我们从增删查入手，以此把每个要点的老大看了，就能彻底弄懂的源码。</p>
<h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><p>offer、add、push都是根据插入的位置的不同来分别调用addFirst或者addLast。它俩的源码如下：</p>
<p>addFirst：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)<span class="comment">//前面说过ArrayDeque不能存储空元素，这里源码再一次证明。</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elements;</span><br><span class="line">    es[head = dec(head, es.length)] = e;<span class="comment">//当前头指针指向的是第一个元素，头部指针向前减一位，由于是循环队列，所以会在dec()里面判断并且循环。</span></span><br><span class="line">    <span class="keyword">if</span> (head == tail)<span class="comment">//如果头指针指到尾指针了，就进行扩容，注意是先插入，后扩容，所以插入元素的时候并不需要考虑是否能插入，此时头指针永远都是指向空的位置。</span></span><br><span class="line">        grow(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addFirst所依赖的dec：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> modulus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (--i &lt; <span class="number">0</span>) i = modulus - <span class="number">1</span>;<span class="comment">//如果头指针向前移动了一位就导致数组下标越界了，那么就让这个头指针指向改数组的最后一个位置。</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addLast：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elements;</span><br><span class="line">    es[tail] = e;<span class="comment">//因为是尾指针，尾指针指向的地方为空元素，所以直接将元素插入即可，移动尾指针的步骤在inc里面执行。</span></span><br><span class="line">    <span class="keyword">if</span> (head == (tail = inc(tail, es.length)))<span class="comment">//判断是否需要扩容（顺便移动了尾指针）</span></span><br><span class="line">        grow(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addLast所依赖的inc：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> modulus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (++i &gt;= modulus) i = <span class="number">0</span>;<span class="comment">//尾指针移动之后如果超出了该数组的最大长度，那就让尾指针指向数组的第一个位置。</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><p>与增一致，remove、poll、pop都是调用pollFirst或者pollLast方法，源码如下：</p>
<p>pollFirst：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] es;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> h;</span><br><span class="line">    E e = elementAt(es = elements, h = head);<span class="comment">//获取头元素</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        es[h] = <span class="keyword">null</span>;<span class="comment">//将当前头元素的内容设为null</span></span><br><span class="line">        head = inc(h, es.length);<span class="comment">//调用inc函数让头指针先后移动以为，继续指向当前队列中的第一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pollLast：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] es;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> t;</span><br><span class="line">    E e = elementAt(es = elements, t = dec(tail, es.length));<span class="comment">//因为尾指针指向的位置是空元素，所以需要先进行dec操作将尾指针进行前移，才能获取到队列中的最后一个元素。</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">        es[tail = t] = <span class="keyword">null</span>;<span class="comment">//将当前尾指针指向的内容设值为null</span></span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>一样一样一样，都一样，get、peek、element都是调用的elementAt方法。</p>
<p>elementAt：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;E&gt; <span class="function">E <span class="title">elementAt</span><span class="params">(Object[] es, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) es[i];<span class="comment">//就这么简单,根据下标查询数组内容，所以会在数组下标的参数传递上做功夫。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> elementAt(elements, head);<span class="comment">//直接将头指针的位置传递即可</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] es;</span><br><span class="line">    <span class="keyword">return</span> elementAt(es = elements, dec(tail, es.length));<span class="comment">//尾指针先调用dec向前移动一位才能访问到数组元素，然后根据下标查询数据即可。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增删查就这么搞定了。</p>
<h4 id="扩增函数"><a href="#扩增函数" class="headerlink" title="扩增函数"></a>扩增函数</h4><p>grow函数（看个乐呵）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> needed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldCapacity = elements.length;<span class="comment">//记录下原来数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity;<span class="comment">//声明用于表示新数组长度的变量</span></span><br><span class="line">    <span class="comment">// Double capacity if small; else grow by 50%</span></span><br><span class="line">    <span class="keyword">int</span> jump = (oldCapacity &lt; <span class="number">64</span>) ? (oldCapacity + <span class="number">2</span>) : (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//当原数组的空间小于64的时候，每次就翻倍增则（这里的jump是扩容的量，后面还需要在原数组长度的基础上再加上jump），不然的后就按原数组长度的50%增长（&gt;&gt;1相当于*0.5）</span></span><br><span class="line">    <span class="keyword">if</span> (jump &lt; needed</span><br><span class="line">        || (newCapacity = (oldCapacity + jump)) - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)<span class="comment">//当我们扩容的长度比我们所需要的长度要小的时候，或者是我们扩容的长度已经比我们所设定的最大数组长度还要大的时候，我们会调用newCapacity方法（下一个代码详解）</span></span><br><span class="line">        newCapacity = newCapacity(needed, jump);</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elements = Arrays.copyOf(elements, newCapacity);<span class="comment">//我们把当前的数组用新空间拷贝一份</span></span><br><span class="line">    <span class="keyword">if</span> (tail &lt; head || (tail == head &amp;&amp; es[head] != <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="comment">//tail &lt; head 当头指针在尾指针后面的时候</span></span><br><span class="line">        <span class="comment">//tail == head &amp;&amp; es[head] != null 当头指针等于尾指针且它们指向的内容不为空</span></span><br><span class="line">        <span class="comment">//数组满了的情况就是头指到尾了，所以需要扩容</span></span><br><span class="line">        <span class="keyword">int</span> newSpace = newCapacity - oldCapacity;<span class="comment">//新空间的大小，等价于jump</span></span><br><span class="line">        System.arraycopy(es, head,</span><br><span class="line">                         es, head + newSpace,</span><br><span class="line">                         oldCapacity - head);<span class="comment">//调用系统复制数组，将原数组的元素移动到加了新空间的位置上，同时移动了头指针的位置，与尾指针分开</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head, to = (head += newSpace); i &lt; to; i++)</span><br><span class="line">            es[i] = <span class="keyword">null</span>;<span class="comment">//将新空间中的元素设置为null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>newCapacity：（这个函数是用来判断边界条件以及溢出处理的）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> needed, <span class="keyword">int</span> jump)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldCapacity = elements.length, minCapacity;</span><br><span class="line">    <span class="keyword">if</span> ((minCapacity = oldCapacity + needed) - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//minCapacity是所需要的最小扩容空间，当最小的扩容空间比我们给定的最大数组方法还要大的时候</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>)<span class="comment">//这里是溢出了，直接抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Sorry, deque too big&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;<span class="comment">//不然的话直接返回int的最大值</span></span><br><span class="line">        <span class="comment">//  private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class="line">        <span class="comment">//原先设定的最大数组长度比int的最大值小8，所以还能有剩余空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (needed &gt; jump)<span class="comment">//当我们所需的空间比自动扩容要大，则返回我们能够完成的最小空间</span></span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    <span class="keyword">return</span> (oldCapacity + jump - MAX_ARRAY_SIZE &lt; <span class="number">0</span>)</span><br><span class="line">        ? oldCapacity + jump</span><br><span class="line">        : MAX_ARRAY_SIZE;<span class="comment">//自动扩容的空间如果不比最大数组长度大则返回自动扩容的容量，否则返回指定的最大数组长度。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p><em>LinkedList</em>也是Deque的一个实现类，底层是一个双向链表实现的，记录着前驱和后继两个结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to first node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to last node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该集合的元素存储结构也可以形象的表示为以下图：</p>
<p><img src="http://cdn.lehanbal.top/LinkedList%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E5%9B%BE.png" alt="LinkedList逻辑存储图"></p>
<p>它的继承关系如下图：</p>
<p><img src="http://cdn.lehanbal.top/LinkedList.png" alt="LinkedList"></p>
<p>我们能看到<em>LinkedList</em>实现了Deque和List接口，那么<em>LinkedList</em>就具备了list和deque两个接口的属性，list能够通过下标进行索引访问，deque在前面也介绍了，能够实现双向队列（同样能够当作栈或者队列来使用）。</p>
<p>除此之外，<em>LinkedList</em>能够存储null元素。</p>
<p>那么我们来看看源码。</p>
<h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><h4 id="增-1"><a href="#增-1" class="headerlink" title="增"></a>增</h4><p>与队列和栈的增加元素方法相关的操作都与linkFirst函数和linkLast函数相关，根据插入元素的位置的不同会调用相关操作。</p>
<p>linkFirst：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;<span class="comment">//保存当前first结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);<span class="comment">//声明一个新的结点来作为当前的头节点</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)<span class="comment">//如果之前是空链表，那么就让头和尾指针指向同一个元素，因为当前元素是该链表中唯一的元素</span></span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;<span class="comment">//如果之前不是空链表，那么就让之前的头节点的前驱结点指向当前的头节点</span></span><br><span class="line">    size++;<span class="comment">//链表元素+1</span></span><br><span class="line">    modCount++;<span class="comment">//修改次数+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>linkLast：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;<span class="comment">//保存当前的last结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);<span class="comment">//声明一个新的结点来作为当前的尾结点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)<span class="comment">//如果之前是空链表，那么就让头和尾指针指向同一个元素，因为当前元素是该链表中唯一的元素</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;<span class="comment">//如果之前不是空链表，那么就让之前的尾结点的后继结点指向新的尾结点</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然继承了list接口，就有够通过下标进行元素操作的方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);<span class="comment">//检测index是否合理，必须是链表长度内才行，不然就抛出越界异常</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)<span class="comment">//如果要插入的元素是链表的末尾，那么就直接调用linkLast插入</span></span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));<span class="comment">//调用linkBefore函数插入结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>node：在add函数中已经对index进行了合法判断，所以当前的index是在链表的合理范围内。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//我们需要找到index位置的结点，最坏的情况只需要找n/2次便能找到，因为记录了头节点和尾结点，我们只需要计算index在该链表中心的左边还是右边即可，若是在左边，则从头节点开始查找，若是在右边，则从尾结点开始查找。</span></span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;<span class="comment">//判断index是在链表中心的左边还是右边</span></span><br><span class="line">        Node&lt;E&gt; x = first;<span class="comment">//左边就从头节点开始查找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;<span class="comment">//若在右边则从尾结点开始查找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>linkBefore：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//succ就是我们要插入元素的后继结点，我们需要把我们的元素安排在该结点之前</span></span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;<span class="comment">//记录要插入元素的前驱结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);<span class="comment">//声明一个新的结点，前驱后继如上所说</span></span><br><span class="line">    succ.prev = newNode;<span class="comment">//更新succ节点的前驱，使得我们要插入的元素成为它的前驱结点。</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)<span class="comment">//如果我们要插入的元素是头节点的位置，那么就让这个新的结点成为头节点。</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//不然的话就更新前驱节点的后继结点为我们新的结点。</span></span><br><span class="line">        pred.next = newNode;<span class="comment">//该节点就融入进去了</span></span><br><span class="line">    size++;<span class="comment">//元素数量+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体步骤如下图：</p>
<p><img src="http://cdn.lehanbal.top/LinkedList%E5%8A%A0%E5%85%A5%E6%96%B0%E5%85%83%E7%B4%A0%E7%9A%84%E6%AD%A5%E9%AA%A4.png" alt="LinkedList加入新元素的步骤"></p>
<h4 id="删-1"><a href="#删-1" class="headerlink" title="删"></a>删</h4><p>与队列、栈相关的删除操作本质上是在调用unlinkFirst与unlinkLast</p>
<p>unlinkFirst：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//删除头结点元素</span></span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;<span class="comment">//保存头节点元素，之后要返回</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;<span class="comment">//记录下当前头结点的后继结点，要让它子承父业</span></span><br><span class="line">    f.item = <span class="keyword">null</span>;<span class="comment">//让当前头节点的item以及后继节点的指向都指空，有助于GC回收</span></span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    first = next;<span class="comment">//开始子承父业</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)<span class="comment">//如果成了空链表的话，那么就让头尾都指向null，成为头尾都指向null的空链表，没有指向</span></span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//如果还有元素，那就让子节点的前驱结点指向空，成为头节点（头节点没有前驱结点）</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">    <span class="comment">//如果你疑问为什么next为空了就不需要让next的前驱指针指向空，好好读我下面这句话</span></span><br><span class="line">    <span class="comment">//憨批，next都是null了，null能存什么元素，null就是null，null，什么都没有了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unlinkLast</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//要删除的结点是尾结点</span></span><br><span class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = l.item;<span class="comment">//保存要删除结点的元素以便之后返回</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;<span class="comment">//记录下当前结点的前驱结点，我们要让这个前驱结点成为尾结点</span></span><br><span class="line">    l.item = <span class="keyword">null</span>;<span class="comment">//与前面的删除头节点的时候一致，让当前的尾结点的前驱结点指向和item都标记为null，有助于GC回收</span></span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    last = prev;<span class="comment">//开始树立新的尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)<span class="comment">//同样的，如果删除了刚刚的尾结点让链表成空了，那就让头节点也指向空，彻底抛弃指向，成为头尾都指向空的两边</span></span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//如果删了尾结点还有元素的话就让目前的尾结点的next指向为null，抛弃指向上一个尾结点的指向，这样就能成为真正的尾结点了</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过下标进行元素的删除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       checkElementIndex(index);<span class="comment">//一样是对索引进行合理性判断，不合理则抛出异常</span></span><br><span class="line">       <span class="keyword">return</span> unlink(node(index));<span class="comment">//node(index)找到要删除的结点，然后解除它的应用</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// assert x != null;</span></span><br><span class="line">       <span class="keyword">final</span> E element = x.item;<span class="comment">//记录下x结点的item 前驱后继结点，都记录下来</span></span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;<span class="comment">//如果前驱结点是空，说明我们要删除的结点是头结点，所以让头节点指向x的后继节点即可</span></span><br><span class="line">           first = next;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果不是前驱结点的话</span></span><br><span class="line">           prev.next = next;<span class="comment">//就让x的前驱结点的next直接指向x的后继结点</span></span><br><span class="line">           x.prev = <span class="keyword">null</span>;<span class="comment">//然后将x的前驱结点的指向设为null，不让他指向任何结点</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;<span class="comment">//如果后继结点是空，说明我们要删除的是尾结点，所以让尾指针直接指向x的前驱结点</span></span><br><span class="line">           last = prev;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;<span class="comment">//不然的话，就越过x，让x的后继结点的前驱指向直接指向x的前驱，再把x的后继结点指向null</span></span><br><span class="line">           next.prev = prev;</span><br><span class="line">           x.next = <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       x.item = <span class="keyword">null</span>;<span class="comment">//将x的内容设为null，这样一来，经过上述操作，x.item x.prev x.next全都指向了null</span></span><br><span class="line">       size--;</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="keyword">return</span> element;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>删除指定内容的元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//删除指定元素的操作，就是穷举当前的链表找到值相等的元素，然后调用unlink解除这个结点的前驱和后继，</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;<span class="comment">//因为LinkedList能够存储null值，null值的判断需要单独进行判断</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    unlink(x);<span class="comment">//穷举找到null之后将该结点删除</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item)) &#123;<span class="comment">//一样的穷举思路</span></span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//具体思路也用在了indexOf中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>删除过程的逻辑图：</p>
<p><img src="http://cdn.lehanbal.top/LinkedList%E6%96%AD%E5%BC%80%E8%BF%87%E7%A8%8B.png" alt="LinkedList断开过程"></p>
<h4 id="查-1"><a href="#查-1" class="headerlink" title="查"></a>查</h4><p>队列、栈的头尾元素查询只需要通过对头尾结点的调用即可取得</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">       <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">       <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">       <span class="keyword">return</span> f.item;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">       <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">       <span class="keyword">return</span> l.item;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以上不解读了，一眼就看明白的东西</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       checkElementIndex(index);</span><br><span class="line">       <span class="keyword">return</span> node(index).item;<span class="comment">//node函数之前已经解读过了，通过对index的大小判断，在链表中心的哪一段，然后利用头尾结点就能实现n/2的查找速率</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>LinkedList解读完了，我们在一起来看看ArrayDeque和LinkedList吧。</p>
<h2 id="ArrayDeque与LinkedList"><a href="#ArrayDeque与LinkedList" class="headerlink" title="ArrayDeque与LinkedList"></a><em>ArrayDeque</em>与<em>LinkedList</em></h2><p>我说了这么多，源码也给读了，剩下就看你们来总结这两者的不同吧。</p>
<p>如果你总结不出，那只能说明你没看我写的文章，懒狗。</p>
<p>但是本人也是懒狗，这里记录下这两者的不同，以及正面回答为什么很多情况下推荐使用ArrayDeque。</p>
<ol>
<li>ArrayDeque底层通过数组实现，底层是一个循环数组，动态扩容；LinkedList则是通过一个双向链表实现。</li>
<li>ArrayDeque并不能够存储null元素，有意为之，但是LinkedList能够存储null。</li>
<li>ArrayDeque进行扩容的时候会需要比较大的性能开销，LinkedList是链表实现，并不需要扩容操作，只需要指针指向即可。</li>
</ol>
<p>但是ArrayDeque插入头尾数据和删除数据都是妥妥的O(1)复杂度，作为队列或者栈来使用的时候，还有什么比O(1)的头部尾部操作更优秀呢？对于循环数组而言，它的随机访问依旧是O(1)，链表则是O(n)，此时唯一的缺点就是扩容造成的性能开销；相比之下LinkedList是通过链表实现的，同时他还继承了List接口，除了能够当成双向队列来使用的时候，还能够通过下表进行数据的访问以及相关操作，并且链表的优点是删除元素的时候很方便只有O(1)的时间复杂度，但是删除元素的时候你需要先找到当前元素，所以还是一个O(n)的时间过程，在当作队列或者栈来说的时候，ArrayDeque在操作的复杂度上而言，完爆LinkedList。</p>
<p>但是读过ArrayDeque源码之后我们知道，这玩意扩容很耗空间，而且扩容的时候性能开销也是实实在在存在的，LinkedList则是动态的使用空间大小，每次添加新的结点的时候都是原地创建结点再创建应用，并不会造成先ArrayDeque那样的扩容开销，而且它能够通过下标访问，所以在不作为队列或者栈使用的时候，是有它的用武之地。</p>
<ul>
<li>在我们清楚我们的操作需要消耗多少空间的时候，优先推荐使用ArrayDeque作为队列或者栈的集合。</li>
<li>若是我们不清楚消耗的空间，并且消耗的空间会持续增大的话，可以考虑使用LinkedList来作为队列或者栈的集合。（防止ArrayDeque多次地扩容造成性能浪费）。</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
              <a href="/tags/JAVA/" rel="tag"># JAVA</a>
              <a href="/tags/Deque/" rel="tag"># Deque</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/10/29/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%A2%E9%BB%91%E6%A0%91/" rel="prev" title="什么是红黑树">
                  <i class="fa fa-chevron-left"></i> 什么是红黑树
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/10/29/%E8%B0%88%E8%B0%88PriorityQueue/" rel="next" title="谈谈PriorityQueue">
                  谈谈PriorityQueue <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lehanbal</span>
</div>

    </div>
  </footer>

  
  <script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://unpkg.com/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  





</body>
</html>
