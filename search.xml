<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>B-树、B+树</title>
    <url>/2020/10/29/B-%E6%A0%91%E3%80%81B-%E6%A0%91/</url>
    <content><![CDATA[<p><strong>B-树的“-”是不发音的！</strong></p>
<h2 id="先看2-3树"><a href="#先看2-3树" class="headerlink" title="先看2-3树"></a>先看2-3树</h2><p>本质上，2-3树是一颗最简单的B-树，其每个非叶节点都有两个或三个子女，而且所有叶都在统一层上。2-3树不是二叉树，其节点可拥有3个孩子。不过，2-3树与满二叉树相似。高为h的2-3树包含的节点数大于等于高度为h的满二叉树的节点数，即至少有2^h-1个节点。</p>
<p>说人话，2-3树就是比满二叉树的节点多。</p>
<p>先别看规则，向上个图，感受一下。</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/2-3%E6%A0%91.png" alt="2-3树"></p>
<p>2-3的节点规则：</p>
<ol>
<li>2-节点有两个孩子，必含一个数据项，其查找关键字大于左孩子的查 找关键字，而小于右孩子的查找关键字。</li>
<li>3-节点有三个孩子 ，必含两个数据项，其查找关键字S和L满足下列关系：S大于左孩子的查找关键字，而小于中孩子的查找关键字；L大于中孩子的查找关键字，而小于右孩子的查找关键字。</li>
<li>叶子可以包含一个或两个数据项。</li>
</ol>
<p>对着图读一遍规则，这样就能更快一点理解这是个啥东西。</p>
<h3 id="2-3树查找元素"><a href="#2-3树查找元素" class="headerlink" title="2-3树查找元素"></a>2-3树查找元素</h3><p>在上面的定义中，我们可以知道2-3树是根据元素的大小来决定查找的方向的。要找到我们需要的元素，我们就需要将元素和当前的节点进行比较，其实和二叉搜索树的查找的方式很相似，只不过这里不是二叉树罢了。我直接上个案例来说明整个查找情况。</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/2-3%E6%A0%91%E6%9F%A5%E6%89%BE1.png" alt="2-3树查找1"></p>
<h3 id="2-3树插入元素"><a href="#2-3树插入元素" class="headerlink" title="2-3树插入元素"></a>2-3树插入元素</h3><p>插入元素就显得略为复杂，主要分为以下四种情况，当然如果是空树的话直接创建一个节点即可。</p>
<ol>
<li><p>向一颗2-节点插入元素</p>
<p>如果未命中元素，并且是在2-节点结束的，那就把当前的2-节点变成3-节点，并且把插入的元素加进去即可。</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/2-3%E6%A0%91%E6%8F%92%E5%85%A5%E6%83%85%E5%86%B51.png" alt="2-3树插入情况1"></p>
</li>
<li><p>向一个父节点是2-节点的3-节点插入元素</p>
<p>将3-节点临时变成4-节点，然后将中间节点抽出分解成3个2-节点，将中间节点向上合并，完成插入操作。</p>
<p><img src="D:%5CWorkspace%5Cgitbook%5Crecord_source_code%5CJava%5CB%E6%A0%91%E3%80%81B+%E6%A0%91%5C2-3%E6%A0%91%E6%8F%92%E5%85%A5%E6%83%85%E5%86%B52.png" alt="2-3树插入情况2"></p>
</li>
<li><p>向一个父节点是3-节点的3-节点插入元素</p>
<p>插入元素的时候，先临时变成4-节点，然后把它分解了，将中间的元素向上合并，父节点继续变成4-节点，再分解，中间的元素再向上合并。知道遇到2-节点，把2-节点变成3-节点，此时便不再分解。<strong>如果根节点分解了，那么树高+1</strong>。</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/2-3%E6%A0%91%E6%8F%92%E5%85%A5%E6%83%85%E5%86%B53.1.png" alt="2-3树插入情况3.1"></p>
</li>
</ol>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/2-3%E6%A0%91%E6%8F%92%E5%85%A5%E6%83%85%E5%86%B53.2.png" alt="2-3树插入情况3.2"></p>
<h3 id="2-3树删除元素"><a href="#2-3树删除元素" class="headerlink" title="2-3树删除元素"></a>2-3树删除元素</h3><p>删除元素的思路和二叉搜索树的删除情况类似，如果删除的是非叶子节点，都是通过将非叶子节点的后继节点代替它，然后转换成删除叶子节点的问题。</p>
<p>删除叶子节点有以下五种情况：</p>
<ol>
<li><p>删除的节点不是2-节点，这种情况可以直接删除，将3-节点删除其中一个元素使它转换成2-节点。</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/2-3%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B51.png" alt="2-3树删除情况1"></p>
</li>
<li><p>删除的节点是2-节点，父节点是2-节点，兄弟节点是3-节点，这种时候删除节点后将父节点移动到被删除节点的位置然后将兄弟节点中最接近父节点的值移动到父节点的位置。（左旋）</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/2-3%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B52.png"></p>
</li>
<li><p>删除的节点是2-节点，兄弟节点也是2-节点，（不是满二叉树）这时候我们需要将父节点的父节点的直接后继拆分来顶替父节点的位置，然后父节点与兄弟节点结合从3-节点，进行左旋操作即可。</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/2-3%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B53.png" alt="2-3树删除情况3"></p>
</li>
<li><p>删除的节点是2-节点，父节点是3-节点，那么我们需要将父节点拆成两个2-节点，然后将父节点中最接近的一个元素与孩子结合，合并成一个3-节点。</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/2-3%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B54.png" alt="2-3树删除情况4"></p>
</li>
<li><p>删除的是一个满二叉树的叶子节点，这个时候，就开始降维打击了，将删除节点的兄弟节点与父节点结合成3-节点，父节点的所有兄弟节点合并到父节点的都节点中，如果生成4-节点，那就拆分4-节点即可。</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/2-3%E6%A0%91%E6%8F%92%E5%85%A5%E6%83%85%E5%86%B55.png" alt="2-3树插入情况5"></p>
</li>
</ol>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h2><p>B-树全名 Balance Tree<strong>读做B树(中间的-，只是分隔作用，不要读做B减树)。</strong></p>
<p>B树首先它也是属于树结构，除了树结构的节点有序、查找高效外，还有以下特性。以一个m阶的B树来举栗：</p>
<ol>
<li>根节点至少包含两个子节点；</li>
<li>每个中间节点包括k-1个元素和k个子节点，其中m/2 &lt;= k &lt;= m</li>
<li>每一个叶子节点包含k-1个元素，其中m/2 &lt;= k &lt;= m</li>
<li>每个节点的元素从大到小有序，节点当中k-1个元素是k个子节点的值域的划分。</li>
</ol>
<p>说人话，就是我们之前说的2-3树扩展，不过2-3树只不过是m=3的B-树罢了。</p>
<p>对应的，2-3-4树就是m=4的B-树。</p>
<p>查找、插入以及删除的概念在2-3树的时候已经完全介绍了，这里说明B-树有什么用，为什么数据库的索引会用到B-树。</p>
<h3 id="二叉搜索树的查询速度都已经是logN了，B-树B-树会比这个效率还高吗？"><a href="#二叉搜索树的查询速度都已经是logN了，B-树B-树会比这个效率还高吗？" class="headerlink" title="二叉搜索树的查询速度都已经是logN了，B-树B+树会比这个效率还高吗？"></a>二叉搜索树的查询速度都已经是logN了，B-树B+树会比这个效率还高吗？</h3><p>答案是当然不会，它的查询方式就是基于二分查找，但是当磁盘的存储数据较大的时候，树的高度会变高。在进行索引的查询的时候，并不会把整个索引全部加载到内存，会逐一加载每个磁盘页面，当树变高的时候，会需要增加读取磁盘页的次数，相对的也就增加了查询时间。</p>
<p>所以我们需要一种数据结构，压缩这棵树的高度，这就是B-树，把树变得矮胖，在内存中比较数值的速度的性能和时间消耗远远小于磁盘IO的速度，所以通过压缩树的高度对于大批的数据检索来说，是优于二叉搜索树的。</p>
<h3 id="B-树主要作用在什么地方"><a href="#B-树主要作用在什么地方" class="headerlink" title="B-树主要作用在什么地方"></a>B-树主要作用在什么地方</h3><p>B-树主要应用于文件系统以及部分数据库索引，非关系型数据库MongoDB的索引用的就是B-树结构。</p>
<h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h2><p>B+树是B-树的一种变形形式，B+树上的叶子结点存储关键字以及相应记录的地址，叶子结点以上各层作为索引使用。一棵m阶的B+树定义如下:</p>
<ol>
<li>中间元素不存数据，只是当索引用，所有数据都保存在叶子结点中。</li>
<li>所有的中间节点在子节点中要么是最大的元素，要么是最小的元素 。</li>
<li>叶子结点包含所有的数据，和指向这些元素的指针，而且叶子结点的元素形成了自小向大这样子的链表。</li>
</ol>
<p>B+树的查找与B树不同，当索引部分某个结点的关键字与所查的关键字相等时，并不停止查找，应继续沿着这个关键字左边的指针向下，一直查到该关键字所在的叶子结点为止。</p>
<p>上个图，体会一下：</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/B+%E6%A0%91.png" alt="B+树"></p>
<p>因为B+树的非叶子节点并没有存储数据，所以一个磁盘页可以存储更多的数据，也就是说，B+树会比B-树更加矮胖，所以查询IO次数更少，查询速度也就更快。</p>
<p>B+树的叶子节点会形成一个链表，当我们需要查询下一个数据的时候，并不需要从头开始继续查找，而是顺着链表就能够摸到我们需要的数，更优的查询效率。</p>
<p>B+树的插入删除操作与B-树的操作大同小异，我不写了，感兴趣的自行百度。</p>
<h3 id="B-树的优势"><a href="#B-树的优势" class="headerlink" title="B+树的优势"></a>B+树的优势</h3><ol>
<li>单一节点存储更多的元素，使得查询的IO次数更少。</li>
<li>所有查询都要查找到叶子节点，查询性能稳定。</li>
<li>所有叶子节点形成有序链表，便于范围查询。</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>GET与POST的本质区别</title>
    <url>/2020/10/29/GET%E4%B8%8EPOST%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>GET：从指定的服务器中获取数据。</p>
<p>POST：提交数据给指定服务器处理。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">GET</th>
<th align="center">POST</th>
</tr>
</thead>
<tbody><tr>
<td align="center">点击返回/刷新</td>
<td align="center">没有影响</td>
<td align="center">数据会重新发送</td>
</tr>
<tr>
<td align="center">数据内容位置</td>
<td align="center">在请求行中</td>
<td align="center">在请求体中</td>
</tr>
<tr>
<td align="center">编码类型</td>
<td align="center">application/x-www-form-urlencoded</td>
<td align="center">application/x-www-form-urlencoded or multipart/form-data. 请为二进制数据使用multipart编码</td>
</tr>
<tr>
<td align="center">长度限制</td>
<td align="center">有，取决于浏览器的url输入长度和服务器限制的url长度</td>
<td align="center">没有限制</td>
</tr>
<tr>
<td align="center">数据类型限制</td>
<td align="center">只允许ASCLL字符类型</td>
<td align="center">没有限制</td>
</tr>
<tr>
<td align="center">安全性</td>
<td align="center">查询字符串都会显示在请求行之中，肉眼可见，敏感数据不要使用GET请求提交</td>
<td align="center">数据不会出现在地址栏中，且也不会被缓冲和保存在历史记录中，，但是仍然会被抓包工具抓包读取到提交的数据，所以要传输敏感数据最好使用加密传输</td>
</tr>
<tr>
<td align="center">可见性</td>
<td align="center">查询字符串显示在地址栏URL中，可见</td>
<td align="center">查询字符串在请求体之中，不会显示在地址栏中，不可见</td>
</tr>
</tbody></table>
<p><strong>但是</strong>！写小项目的时候，GET和POST不都是在给服务器传输数据吗？为什么GET说就是获取数据呢？</p>
<p>业务期望，不是技术限制，GET一般是作为请求指定服务器上的相关资源，不做修改，而POST等方法才能对服务器的资源进行数据的修改。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP与HTTPS的区别</title>
    <url>/2020/10/29/HTTP%E4%B8%8EHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<ol>
<li>http协议：超文本传输协议，信息是明文传输，并且不验证通信方的身份，无法验证报文的完整性/</li>
<li>https协议：超文本传输安全协议（HTTP Secure），具有安全性的SSL（Secure Socket Layer 安全套接层）或者TLS（Transport Layer Security 安全层传输协议）的组合使用。在HTTP的基础上具备对报文的加密处理，通信方身份认证和内容完整性保护，这就是HTTPS</li>
</ol>
<p>HTTPS并不是应用层的一种新协议。只是HTTP通信接口部分使用的是SSL（Secure Socket Layer）和TLS（Transport Layer Security）协议代替。</p>
<p>一般来说，HTTP是直接和TCP进行通信。当我们使用了SSL在之后，就会变成先和SSL通信，再由SSL与TCP进行通信。所以说，HTTPS就是HTTP套了一层SSL的皮。</p>
<p>HTTP协议使用的端口是80，HTTPS使用的端口是443。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/2020/10/29/KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>KMP 算法是 D.E.Knuth、J,H,Morris 和 V.R.Pratt 三位神人共同提出的，称之为 Knuth-Morria-Pratt 算法，简称 KMP 算法。该算法相对于 Brute-Force（暴力）算法有比较大的改进，主要是消除了主串指针的回溯，从而使算法效率有了某种程度的提高。</p>
<p>KMP适用于重复字串多的短串，在这种模式下会有很好的效果，当重复的字串不太多的时候，并且串还有点长，那么KMP的表现和暴力匹配会差不多。KMP会额外的开辟一个匹配串长度大小的空间，相当于用空间换时间。但是，既然都会了KMP，并且题目并没有明确的要求空间复杂度的时候，能用上KMP就用上。</p>
<p>推荐观看的KMP教学视频：<a href="https://www.bilibili.com/video/BV1S64y1u74P?from=search&seid=13411543487636624526">KMP算法实例详解(易懂)</a></p>
<h2 id="暴力匹配"><a href="#暴力匹配" class="headerlink" title="暴力匹配"></a>暴力匹配</h2><p>在说KMP之前，有必要了解暴力匹配，KMP就是在暴力匹配的基础上进行的算法优化。</p>
<p>现在有个题目：在字符串“111011101”找到第一个“10”的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">violentMatch</span><span class="params">(String source, String text)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] str = source.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] match = text.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; str.length &amp;&amp; j &lt; match.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == match[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i = i - j + <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == match.length) <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ViolentMatch vm = <span class="keyword">new</span> ViolentMatch();</span><br><span class="line">    System.out.println(vm.violentMatch(<span class="string">&quot;111011101&quot;</span>, <span class="string">&quot;10&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述的代码中，暴力匹配就是将匹配的字符串挨个去匹配源字符串的每个字符，如果匹配成功，匹配的字符就各自往前移动一位，否则源字符串就退回到最开始匹配的地方并且往前跳一个位置，再开始继续匹配。</p>
<p>这种匹配模式，如果源字符串和匹配字符串中有很多重复的地方，这个匹配方式依旧会挨个进行全匹配，这会很耗时间，下面说的KMP就是比较智能的方式，这个算法会跳过字符串中出现重复的地方。</p>
<p>为了实现这个操作，我们需要构造一个Next表，这个表记录着匹配的字符串匹配失败后应该跳转的位置。</p>
<h2 id="制作Next表"><a href="#制作Next表" class="headerlink" title="制作Next表"></a>制作Next表</h2><p>next表所记录的就是匹配字符串当中相同的前后缀出现的位数，进行匹配的时候，如果前面的字符串出现过，那么就跳过就好了，不需要再进行匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getNext(String text)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[text.length()];</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;<span class="comment">//相当于next表的第一个是万能符，全都能匹配，不然下面会进行死循环</span></span><br><span class="line">    <span class="keyword">int</span> i = -<span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; text.length() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == -<span class="number">1</span> || text.charAt(j) == text.charAt(i)) &#123;</span><br><span class="line">            j++;</span><br><span class="line">            i++;</span><br><span class="line">            next[j] = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = next[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>KMP和暴力匹配挺像的，但是KMP会用到next作为辅助判断，来计算匹配失败后匹配字符串所需要跳转的位置，相当于经过了一部预处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(String source, String text)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] next = getNext(text);</span><br><span class="line">    <span class="keyword">char</span>[] str = source.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] match = text.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; str.length &amp;&amp; j &lt; match.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span> || str[i] == match[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == match.length) <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis简单入门</title>
    <url>/2020/10/29/Mybatis%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="Mybatis概述"><a href="#Mybatis概述" class="headerlink" title="Mybatis概述"></a>Mybatis概述</h2><p>mybatis 是一个优秀的基于 java 的持久层框架，它内部封装了 jdbc，使开发者只需要<strong>关注 sql 语句本身</strong>，而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。</p>
<p>mybatis 通过 xml 或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。</p>
<p>采用 ORM 思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了 jdbc api 底层访问细节，使我 们不用与 jdbc api 打交道，就可以完成对数据库的持久化操作。</p>
<p>也就是说，这是个在我们 java 代码与数据库打交道的一个框架。</p>
<h2 id="回顾JDBC过程以及问题"><a href="#回顾JDBC过程以及问题" class="headerlink" title="回顾JDBC过程以及问题"></a>回顾JDBC过程以及问题</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//加载驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">//通过驱动管理类来获取数据库的连接</span></span><br><span class="line">        conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306&quot;</span>,<span class="string">&quot;用户名&quot;</span>,<span class="string">&quot;密码&quot;</span>);</span><br><span class="line">        <span class="comment">//定义sql语句</span></span><br><span class="line">        String sql = <span class="string">&quot;select * from user where username = ?&quot;</span>;</span><br><span class="line">        <span class="comment">//获取预处理statement</span></span><br><span class="line">        ps = conn.prepareStatement(sql);</span><br><span class="line">        <span class="comment">//设置sql中的参数，下标从1开始</span></span><br><span class="line">        ps.setString(<span class="number">1</span>, <span class="string">&quot;lehanbal&quot;</span>);</span><br><span class="line">        <span class="comment">//执行查询语句</span></span><br><span class="line">        rs = ps.executeQuery();</span><br><span class="line">        <span class="comment">//遍历结果集</span></span><br><span class="line">        <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">            System.out.println(rs.getString(<span class="string">&quot;id&quot;</span>) + <span class="string">&quot;&quot;</span> + rs.getString(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//注意关闭顺序,从小到大</span></span><br><span class="line">        <span class="keyword">if</span>(rs != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ps != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ps.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDBC问题"><a href="#JDBC问题" class="headerlink" title="JDBC问题"></a>JDBC问题</h3><p>1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。</p>
<p>2、Sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变 java 代码。</p>
<p>3、使用 preparedStatement 向占有位符号传参数存在硬编码，因为 sql 语句的 where 条件不一定，可能多也可能少，修改 sql 还要修改代码，系统不易维护。</p>
<p>4、对结果集解析存在硬编码（查询列名），sql 变化导致解析代码变化，系统不易维护，如果能将数据库记 录封装成 pojo 对象解析比较方便。</p>
<h2 id="Mybatis初体验"><a href="#Mybatis初体验" class="headerlink" title="Mybatis初体验"></a>Mybatis初体验</h2><p>既然是持久层框架，肯定要有数据库环境，我使用的是mysql。</p>
<p>数据库创建表的sql语句和所插入的数据sql语句。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">id</span>       <span class="built_in">int</span> auto_increment</span><br><span class="line">        primary <span class="keyword">key</span>,</span><br><span class="line">    username <span class="built_in">varchar</span>(<span class="number">32</span>)  <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">&#x27;用户名称&#x27;</span>,</span><br><span class="line">    birthday datetime     <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">&#x27;生日&#x27;</span>,</span><br><span class="line">    sex      <span class="built_in">char</span>         <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">    address  <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">&#x27;地址&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.user (<span class="keyword">id</span>, username, birthday, sex, address) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;懒汉&#x27;</span>, <span class="string">&#x27;2020-02-27 21:23:01&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;四川&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.user (<span class="keyword">id</span>, username, birthday, sex, address) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;懒汉1&#x27;</span>, <span class="string">&#x27;2019-07-02 05:09:04&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;广西&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.user (<span class="keyword">id</span>, username, birthday, sex, address) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;一号&#x27;</span>, <span class="string">&#x27;2017-05-06 11:25:10&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;广东&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.user (<span class="keyword">id</span>, username, birthday, sex, address) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;二号&#x27;</span>, <span class="string">&#x27;2020-01-18 15:00:11&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;陕西&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.user (<span class="keyword">id</span>, username, birthday, sex, address) <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="string">&#x27;屎号&#x27;</span>, <span class="string">&#x27;2015-05-07 13:44:32&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;贵州&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.user (<span class="keyword">id</span>, username, birthday, sex, address) <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">&#x27;三号&#x27;</span>, <span class="string">&#x27;2010-11-08 04:53:06&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;云南&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>数据库环境搭建好了之后就可以开始整Mybatis了。</p>
<p>我的目录结构：</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="目录结构"></p>
<p>本文使用Maven来配置Mybatis环境，创建好项目后在pom.xml当中添加以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>mysql是8.0.18，mybatis则是3.5.6，各位按照实际情况来操作。</p>
<p>然后我们需要编写一个Bean来封装我们所查询的数据，字段保持和数据库的内容一致，User类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, birthday=&quot;</span> + birthday +</span><br><span class="line">                <span class="string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, address=&#x27;&quot;</span> + address + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之后我们需要写一个数据访问层的DAO接口，用于查询对应的用户数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.lehanbal.domain.User;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照常规步骤我们应该去写一个对应接口的实现类来实现对应的数据库查询，但是我们使用了Mybatis框架之后并不需要这么左，我们只需要编写对应的xml映射文件来映射对应的接口，让我们的代理方法能够找到对应的实现类。</p>
<p>映射文件的创建是有要求的，必须和dao层接口在相同的包内，并且要以dao层的接口命名文件名。</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/Mybatis%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="Mybatis层次结构"></p>
<p>映射文件UserDao.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Mybatis约束 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;top.lehanbal.dao.UserDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置查询所有--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;top.lehanbal.domain.User&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>namespace是对应着在main包中对应的接口，指名到对应的接口，全类名。</p>
<p>select id指定是的该接口中的方法。</p>
<p>resultType指定的是查询到的内容所封装到的类。</p>
<p>之后便是sql查询语句。</p>
<p>上面只是一个映射关系的xml，我们还需要指定对应的数据库连接并且还要写清楚对应的映射配置位置的配置文档。为了方便加载这个配置文件，我们一般直接放在resource文件夹根目录下。</p>
<p>SqlMapConfig.xml配置文件编写：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;用户名&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;密码&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;top/lehanbal/dao/UserDao.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>mapper指定了对应的映射文件xml的位置信息。框架会根据这个信息去寻找对应的xml配置文件，然后动态的声明代理方法来实现UserDao接口，来实现我们所需要的查询功能，并且根据xml配置文件指定的返回结果集封装到对应的Bean类之中。</p>
<p>当然我们也可以使用注解来完成映射关系。将mapper换成以下语句：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;top.lehanbal.dao.UserDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>当我们使用注解的方式时，指定了对应的类的位置，我们指向了我们声明的接口，注解上只需要写上对应的sql语句即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> top.lehanbal.domain.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>效果和使用了xml配置文件是一样的。</p>
<p>弄完上面就完事大吉了，我们写个测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> top.lehanbal.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> top.lehanbal.domain.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//加载配置文件</span></span><br><span class="line">        InputStream is = Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//声明构造工厂构造器</span></span><br><span class="line">        SqlSessionFactoryBuilder build = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">        <span class="comment">//使用配置文件和构造器来构造工厂</span></span><br><span class="line">        SqlSessionFactory factory = build.build(is);</span><br><span class="line">        <span class="comment">//通过工厂来声明对应的Sql实体</span></span><br><span class="line">        SqlSession session = factory.openSession();</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        UserDao userDao = session.getMapper(UserDao.class);</span><br><span class="line">        List&lt;User&gt; users = userDao.findAll();</span><br><span class="line">        <span class="keyword">for</span>(User user : users)&#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        session.close();</span><br><span class="line">        is.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来一张运行结果图</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E7%BB%93%E6%9E%9C.png" alt="结果"></p>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Mybatis</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>java反射</title>
    <url>/2020/10/29/java%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>JAVA反射机制是在运行状态中，对任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称之为java的反射机制。</p>
<p> JVM读取相应类的字节码文件叫做反射。</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>开发过程中经常会遇到某个类的某个成员变量、方法是私有的或者只对系统开放，这个时候使用JAVA反射机制就能够获取所需的私有成员或是方法，同样也能够使用反射来进行类的创建，降低耦合程度。另外，使用反射肯定会比直接调用慢，运行很多很多次程序的情况，反射大概比直接调用慢个50来倍，但是我们其实没有这么多需要运行百万级的反射程序。</p>
<p>如果我们需要大量的进行反射调用，那么进行缓存处理，不要反复去使用反射。</p>
<h2 id="反射相关的类"><a href="#反射相关的类" class="headerlink" title="反射相关的类"></a>反射相关的类</h2><table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Class类</td>
<td align="center">代表类的实体，在运行的Java应用程序中表示类和接口</td>
</tr>
<tr>
<td align="center">Field类</td>
<td align="center">代表类的成员变量</td>
</tr>
<tr>
<td align="center">Method类</td>
<td align="center">代表类的成员方法</td>
</tr>
<tr>
<td align="center">Constructor类</td>
<td align="center">代表类的构造方法</td>
</tr>
</tbody></table>
<h3 id="Class类-重点"><a href="#Class类-重点" class="headerlink" title="Class类(重点)"></a><strong>Class类(重点)</strong></h3><p><strong>获取类相关的方法</strong></p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">asSubclass(Class<U> class)</td>
<td align="center">把传递的类的对象转换成代表其子类的对象</td>
</tr>
<tr>
<td align="center">Cast</td>
<td align="center">把对象转换成代表类或者是接口的对象</td>
</tr>
<tr>
<td align="center">getClassLoader()</td>
<td align="center">获得类加载器</td>
</tr>
<tr>
<td align="center">getClasses()</td>
<td align="center">返回一个数组，数组中包含该类中所有公共类和接口类的对象</td>
</tr>
<tr>
<td align="center">getDeclaredClasses()</td>
<td align="center">返回一个数组，数组中包含该类中所有类和接口类的对象</td>
</tr>
<tr>
<td align="center">forName(String className)</td>
<td align="center">根据类名返回类的对象</td>
</tr>
<tr>
<td align="center">getName()</td>
<td align="center">获得类的完整路径名字</td>
</tr>
<tr>
<td align="center">newInstance()</td>
<td align="center">创建类的实例</td>
</tr>
<tr>
<td align="center">getPackage()</td>
<td align="center">获取类的包</td>
</tr>
<tr>
<td align="center">getSimpleName()</td>
<td align="center">获取类的名字</td>
</tr>
<tr>
<td align="center">getSuperclass()</td>
<td align="center">获取当前类继承的父类的名字</td>
</tr>
<tr>
<td align="center">getInterfaces()</td>
<td align="center">获取当前类实现的类或是接口</td>
</tr>
</tbody></table>
<p><strong>获取类中属性的方法</strong></p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getField(String name)</td>
<td align="center">获得某个共有的属性对象</td>
</tr>
<tr>
<td align="center">getField()</td>
<td align="center">获得所有共有的属性对象</td>
</tr>
<tr>
<td align="center">getDeclaredField(String name)</td>
<td align="center">获得某个属性对象</td>
</tr>
<tr>
<td align="center">getDeclaredFields()</td>
<td align="center">获得所有属性对象</td>
</tr>
</tbody></table>
<p><strong>获取类中注解相关的方法</strong></p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getAnnotation(Class<A> annotationClass)</td>
<td align="center">返回该类中参与参数类型匹配的公有注解对象</td>
</tr>
<tr>
<td align="center">getAnnotations()</td>
<td align="center">返回该类所有的共有注解对象</td>
</tr>
<tr>
<td align="center">getDeclaredAnnotation(Class<A> annotationClass)</td>
<td align="center">返回该类中与参数类型匹配的所有注解对象</td>
</tr>
<tr>
<td align="center">getDeclaredAnnotations()</td>
<td align="center">返回该类中所有的注解对象</td>
</tr>
</tbody></table>
<p><strong>获取类中构造器相关的方法</strong></p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getConstructor(Class..&lt;?&gt; parameterTypes)</td>
<td align="center">获得该类中与参数类型匹配的公有构造方法</td>
</tr>
<tr>
<td align="center">getConstructor()</td>
<td align="center">获得该类的所有共有构造方法</td>
</tr>
<tr>
<td align="center">getDeclaredConstructor(Class…&lt;?&gt; parameterTypes)</td>
<td align="center">获得该类中与参数类型匹配的构造方法</td>
</tr>
<tr>
<td align="center">getDeclaredConstructors()</td>
<td align="center">获得该类中所有构造方法</td>
</tr>
</tbody></table>
<p><strong>获取类中方法相关的方法</strong></p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getMethod(String name, Class…&lt;?&gt; parameterTypes)</td>
<td align="center">获得该类某个公有的方法</td>
</tr>
<tr>
<td align="center">getMethod()</td>
<td align="center">获得该类所有共有的方法</td>
</tr>
<tr>
<td align="center">getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes)</td>
<td align="center">获得该类某个方法</td>
</tr>
<tr>
<td align="center">getDeclaredMethods()</td>
<td align="center">获得该类所有方法</td>
</tr>
</tbody></table>
<p> <strong>类中其他重要的方法</strong></p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">isAnnotation()</td>
<td align="center">判断是否是注解类型</td>
</tr>
<tr>
<td align="center">isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</td>
<td align="center">判断是否是注定类型注解</td>
</tr>
<tr>
<td align="center">isAnonymousClass()</td>
<td align="center">判断是否是匿名类</td>
</tr>
<tr>
<td align="center">isArray()</td>
<td align="center">判断是否是数组</td>
</tr>
<tr>
<td align="center">isEnum()</td>
<td align="center">判断是否是枚举类型</td>
</tr>
<tr>
<td align="center">isInstance(Object obj)</td>
<td align="center">判断是否是obj</td>
</tr>
<tr>
<td align="center">isInterface()</td>
<td align="center">判断是否是接口</td>
</tr>
<tr>
<td align="center">isLocalClass()</td>
<td align="center">判断是否是局部类</td>
</tr>
<tr>
<td align="center">isMemberClass()</td>
<td align="center">判断是否是内部类</td>
</tr>
</tbody></table>
<h3 id="Field类"><a href="#Field类" class="headerlink" title="Field类"></a>Field类</h3><p>Field代表类的成员变量(成员变量也成为类的属性)</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">equals(Object obj)</td>
<td align="center">属性与obj相等则返回true</td>
</tr>
<tr>
<td align="center">get(Object obj)</td>
<td align="center">获得obj中对应的属性值</td>
</tr>
<tr>
<td align="center">set(Object obj)</td>
<td align="center">设置obj中对应的属性值</td>
</tr>
<tr>
<td align="center">setAccessible(Boolean flag)</td>
<td align="center">是否关闭java语言访问检查（关闭可提高反射运行速度）</td>
</tr>
</tbody></table>
<h3 id="Method类"><a href="#Method类" class="headerlink" title="Method类"></a>Method类</h3><p>只有一个执行方法，但是很重要</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">invoke(Object obj, Object … args)</td>
<td align="center">传递object对象及参数调用该对象对应的方法</td>
</tr>
</tbody></table>
<h3 id="Constructor类"><a href="#Constructor类" class="headerlink" title="Constructor类"></a>Constructor类</h3><p>类的构造方法</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">newInstance(Object… initargs)</td>
<td align="center">根据传递的参数创造类的对象</td>
</tr>
</tbody></table>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>要玩反射，那么就需要有个反射的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Lehanbal.study.Reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, String age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;起飞&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">toilet</span><span class="params">(<span class="keyword">int</span> genderIdx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (genderIdx) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> -&gt; System.out.println(<span class="string">&quot;进男厕所&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> -&gt; System.out.println(<span class="string">&quot;进女厕所&quot;</span>);</span><br><span class="line">            <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;宁就是女权终结者？&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&#x27;&quot;</span> + age + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>封装一下反射的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Lehanbal.study.Reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String personPath = <span class="string">&quot;Lehanbal.study.Reflect.Person&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reflectNewInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class&lt;?&gt; classPerson = Class.forName(personPath);</span><br><span class="line">            Person person = (Person) classPerson.getConstructor().newInstance();</span><br><span class="line">            person.setName(<span class="string">&quot;懒汉&quot;</span>);</span><br><span class="line">            person.setAge(<span class="string">&quot;24&quot;</span>);</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reflctPrivateConstructor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Person person = (Person)Class.forName(personPath).getDeclaredConstructor(String.class, String.class).newInstance(<span class="string">&quot;懒汉&quot;</span>, <span class="string">&quot;23&quot;</span>);</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射私有属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reflectPrivateField</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class&lt;?&gt; personClass = Class.forName(personPath);</span><br><span class="line">            Object personObj = personClass.getConstructor().newInstance();</span><br><span class="line">            Field field = personClass.getDeclaredField(<span class="string">&quot;TEST&quot;</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            System.out.println((String) field.get(personObj));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射私有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reflectPrivateMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class&lt;?&gt; personClass = Class.forName(personPath);</span><br><span class="line">            Method method = personClass.getDeclaredMethod(<span class="string">&quot;toilet&quot;</span>, <span class="keyword">int</span>.class);</span><br><span class="line">            method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object o = personClass.getConstructor().newInstance();</span><br><span class="line">            method.invoke(o, <span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        reflectNewInstance();</span><br><span class="line">        reflctPrivateConstructor();</span><br><span class="line">        reflectPrivateField();</span><br><span class="line">        reflectPrivateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p>Person{name=’懒汉’, age=’24’}</p>
<p>Person{name=’懒汉’, age=’23’}</p>
<p>Test</p>
<p>进男厕所</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>三次握手四次挥手</title>
    <url>/2020/10/29/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>注：注意: SYN/ACK包是仅SYN 和 ACK 标记为1的包.  </p>
<ol>
<li>当客户端（client）要与服务端（server）进行通信的时候，客户端会向服务端发SYN（Synchronized）标记的包，告诉服务端自己的初始化序列号（seq）请求建立连接。</li>
<li>服务端收到后会发送一个对SYN包的确认包（SYN/ACK）回去，表示已经收到第一个SYN包，并且告诉客户端自己的初始序列号，并继续握手操作。</li>
<li>客户端收到SYN/ACK包，之后发送一个ACK（Acknowledgement）确认包，去告诉服务端链接已经建立。</li>
</ol>
<p>Server 发送 SYN 包是作为发起连接的 SYN 包，还是作为响应发起者的 SYN 包呢？怎么区分？</p>
<p>Server 的 ACK 确认包和接下来的 SYN 包可以合成一个 SYN/ACK 包一起发送的，没必要分别单独发送，这样省了一次交互同时也解决了问题。这样 TCP 建立一个连接，三次握手在进行最少次交互的情况下完成了 Peer 两端的资源分配和初始化序列号的交换。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><ol>
<li>客户端发送一个FIN包来告诉服务端我没有数据需要发给你了。</li>
<li>服务端收到后会回复一个ACK确认包说我知道了，但是等一下我还有东西要给你。</li>
<li>过了一下，服务端自己也没有数据发送给客户端后，服务端也会发送一个FIN包给客服端告诉客户端我没东西了，关闭连接。</li>
<li>客户端收到后会回复一个ACK确认包给服务端说我知道了。</li>
</ol>
<p>四次挥手到此完毕，TCP连接就可以完全拆除了。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>大小堆的实现</title>
    <url>/2020/10/20/%E5%A4%A7%E5%B0%8F%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>我在讲PriorityQueue这一个优先级队列的时候，说了它底层其实是一个大小堆来实现的优先级存储，我也粗略的点了一下大小堆的概念，这次的文章就详细的说一下堆排序是如何实现的。</p>
<h2 id="堆与堆排序的定义"><a href="#堆与堆排序的定义" class="headerlink" title="堆与堆排序的定义"></a>堆与堆排序的定义</h2><p><strong>堆</strong>：堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p>
<p><strong>堆排序</strong>：（英语：Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足<strong>堆积的性质</strong>：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E5%A4%A7%E9%A1%B6%E5%A0%86%E4%B8%8E%E5%B0%8F%E9%A1%B6%E5%A0%86.png" alt="大顶堆与小顶堆"></p>
<p>那就有一个公式：</p>
<p><strong>大顶堆</strong>：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</p>
<p><strong>小顶堆</strong>：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</p>
<h2 id="堆排序过程"><a href="#堆排序过程" class="headerlink" title="堆排序过程"></a>堆排序过程</h2><p>整体过程：将待排序的序列构造成大顶堆，此时最大值就是堆的顶点，此时将堆顶和末尾元素进行交换，此时末尾就是最大节点。再把除了末尾节点的剩下元素重新构造成大顶堆，此时堆顶是次最大元素，再与末尾元素-1的位置交换······如此反复，得到的就是一个升序的序列。（如果要降序序列，那就使用小顶堆重复一样的过程）</p>
<p>接下来模拟整个过程：</p>
<h3 id="堆调整"><a href="#堆调整" class="headerlink" title="堆调整"></a>堆调整</h3><ol>
<li><p>首先假定一个无序序列</p>
<p><img src="D:%5CWorkspace%5Cgitbook%5Crecord_source_code%5CJava%5C%E5%A4%A7%E5%B0%8F%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0%5C%E5%A0%86%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B1.png" alt="堆排序过程1"></p>
</li>
<li><p>然后从最后一个非叶子节点开始（arr.length / 2 - 1），也就是图中的序号1节点，调整它的位置。</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E5%A0%86%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B2.png" alt="堆排序过程2"></p>
</li>
<li><p>再继续找下一个非叶子节点，也就是根节点，对它进行堆调整。</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E5%A0%86%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B3.png" alt="堆排序过程3"></p>
</li>
<li><p>注意这个时候我们把0和1的位置进行的调换，换下来的值可能会造成原先已经是大顶堆的子节点顺序被破坏，此时就需要重新对子节点进行依次堆调整。（换句话说，就是只要我们动了非叶子节点的父节点，那么它父节点往下的非叶子节点都需要重新堆调整一次，使用递归来完成）</p>
<p>我们得到了我们需要的大顶堆：</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E5%A0%86%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B4.png" alt="堆排序过程4"></p>
<p><img src="D:%5CWorkspace%5Cgitbook%5Crecord_source_code%5CJava%5C%E5%A4%A7%E5%B0%8F%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0%5C%E5%A0%86%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B4.png" alt="堆排序过程4"></p>
</li>
</ol>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ol>
<li><p>我们将堆顶元素和末尾元素交换顺序。</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E5%A0%86%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B5.png" alt="堆排序过程5"></p>
</li>
<li><p>重新调整除了末尾元素的堆，使得再次成为大顶堆。</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E5%A0%86%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B6.png" alt="堆排序过程6"></p>
</li>
<li><p>将堆顶元素和次末尾元素交换顺序。</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E5%A0%86%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B7.png" alt="堆排序过程7"></p>
</li>
<li><p>重复2、3操作，最终得到的结果</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E5%A0%86%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B8.png" alt="堆排序过程8"></p>
</li>
</ol>
<p>最终我们通过大顶堆实现了一个升序序列。</p>
<h3 id="堆排序的时间复杂度"><a href="#堆排序的时间复杂度" class="headerlink" title="堆排序的时间复杂度"></a>堆排序的时间复杂度</h3><p>堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。其中构建初始堆经推导复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)…1]逐步递减，近似为nlogn。所以堆排序时间复杂度一般认为就是O(nlogn)级。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;<span class="comment">//从第一个非叶子节点，从下到上，从左到右调整</span></span><br><span class="line">            adjustHeap(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = arr.length - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">            swap(arr, <span class="number">0</span>, j);<span class="comment">//与队尾元素交换</span></span><br><span class="line">            adjustHeap(arr, <span class="number">0</span>, j);<span class="comment">//重新调整剩下的堆</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];<span class="comment">//取出当前元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i * <span class="number">2</span> + <span class="number">1</span>; k &lt; length; k = k * <span class="number">2</span> + <span class="number">1</span>)&#123;<span class="comment">//跳到i的左节点，每次都先跳到左节点</span></span><br><span class="line">            <span class="keyword">if</span>(k + <span class="number">1</span> &lt; length &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>]) k++;<span class="comment">//如果右节点存在并且比左节点还要大，那就指向右节点</span></span><br><span class="line">            <span class="keyword">if</span>(arr[k] &gt; temp)&#123;<span class="comment">//如果子节点大于父节点，那就覆盖掉父节点的值</span></span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                i = k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp;<span class="comment">//将被覆盖的父节点放到最终的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>JAVA</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统的主要功能和提供的服务</title>
    <url>/2020/10/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%E5%92%8C%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<ol>
<li><p>处理器管理</p>
<p>处理器管理的主要任务是对处理器的分配和运行实施有效的管理。在多道程序环境下处理器的分配和运行是以进程位基本单位的，因此对处理器的管理可归纳为对进程的管理。</p>
<ul>
<li>进程控制。负责进程的创建、撤销及状态转换。</li>
<li>进程同步。对并发执行的进程进行协调。</li>
<li>进程通信。负责完成进程间的信息交换。</li>
<li>进程调度。按一定算法进行处理器分配。</li>
</ul>
</li>
<li><p>存储器管理</p>
<p>存储器管理的主要任务是对内存进行分配、保护和扩充。</p>
<ul>
<li>内存分配。按一定的策略为每道程序分配内存。</li>
<li>内存保护。保证各程序在自己的内存区域内运行而不互相干扰。</li>
<li>内存扩充。为允许大型作业或多作业的运行，必须借助虚拟存储技术去获得增加内存的效果。</li>
</ul>
</li>
<li><p>设备管理</p>
<ul>
<li>设备分配。根据一定的设备分配原则对设备进行分配。为了使设备与主机并行工作，还需要采用缓冲技术和虚拟技术。</li>
<li>设备传输控制。实现物理的输入/输出操作，即启动设备、中断处理、结束处理等。</li>
<li>设备独立性。即用户程序中的设备与实际使用的物理设备无关。</li>
</ul>
</li>
<li><p>文件管理</p>
<p>操作系统中负责信息管理的部分称为文件系统，因此称为文件管理。文件管理的主要任务就是有效地支持文件的存储、检索和修改等操作，解决文件的共享、保密和保护问题。</p>
<ul>
<li>文件存储空间的管理。负责对文件存储空间进行管理，包括存储空间的分配与回收等。</li>
<li>目录管理。目录是为了方便文件管理而设置的数据结构，它能提供按名存取的功能。</li>
<li>文件操作管理。实现文件的操作，负责完成数据的读写。</li>
<li>文件保护。提供文件保护功能，防止文件遭到破坏。</li>
</ul>
</li>
<li><p>用户管理</p>
<p>方便用户使用操作系统。</p>
<ul>
<li>命令接口</li>
<li>程序接口</li>
<li>图形接口</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>线程安全和线程不安全</title>
    <url>/2020/10/28/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<p><strong>线程安全</strong>：就是多线程访问的时候，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问。直到该线程操作完毕，其他线程才可使用。不会出现数据不一致或者数据污染。</p>
<p><strong>线程不安全</strong>：即使不提供数据访问保护，会出现多个线程先后更新数据造成脏数据。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>如果进程中有多个线程在同时运行，这些线程可能会同时运行这段代码，若每次运行结果都是一样的，而且其他变量的值也都是和预期一样，那么我们就可以说这就是线程安全。</p>
<p>若每个线程中对全局变量、静态变量只有读操作而无写操作，那么这些变量就是线程安全的，如果有多个线程同时执行写操作，就需要考虑线程同步，否则的话就可能有线程安全问题。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>一个卖票用例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Lehanbal.study.threadRunable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> Ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(Ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前在卖第&quot;</span> + Ticket + <span class="string">&quot;票&quot;</span>);</span><br><span class="line">            Ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>主函数方法：开1K个线程，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Lehanbal.study.threadRunable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo02Ticket a = <span class="keyword">new</span> Demo02Ticket();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(a).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(a).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(a).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(a).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终的执行结果如下：</p>
<p>当前在卖第100票</p>
<p>当前在卖第100票</p>
<p>当前在卖第100票</p>
<p>当前在卖第100票</p>
<p>….</p>
<p>当前在卖第1票</p>
<p>当前在卖第0票</p>
<p>当前在卖第-1票</p>
<p>当前在卖第-1票</p>
<p>会出现一些不一致的情况，这就是线程不安全。解决的办法就是加上Synchronized让方法同步。</p>
<p>修改如下：</p>
<p>1、Synchronized修饰词，可以保证被修饰的方法同步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Lehanbal.study.threadRunable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> Ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(Ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前在卖第&quot;</span> + Ticket + <span class="string">&quot;票&quot;</span>);</span><br><span class="line">            Ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、加上锁，加上锁与解开锁的中间代码就是一整个原子代码，这一段保证了线程安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Lehanbal.study.threadRunable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> Ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(Ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span>(Ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;当前在卖第&quot;</span> + Ticket + <span class="string">&quot;票&quot;</span>);</span><br><span class="line">                Ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统的分类</title>
    <url>/2020/10/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="批处理操作系统"><a href="#批处理操作系统" class="headerlink" title="批处理操作系统"></a>批处理操作系统</h2><p>主要特点：</p>
<ul>
<li>用户脱机使用计算机。用户提交作业之后，在获取结果之前几乎不和计算机交互。</li>
<li>成批处理。工作人员把用户提交的作业分批进行处理，由监督程序负责每批作业间的自动调度。</li>
<li>多道程序运行。按多道程序设计的调度原则，从一批后备作业中选取多个作业调入内存并组织其运行，成为多道批处理系统。</li>
</ul>
<h2 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h2><p>由于批处理操作系统在获取结果前用户都不能和计算机交互，所以出现了错误的结果会导致再进行一次结果的输入，这很不便利。</p>
<p>分时操作系统提供了交互性更好的交互方式。</p>
<p>分时技术就是把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各个联机作业使用。若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时停止运行，把处理器让给另一个作业使用，等到下一轮时再继续运行。由于计算机运行速度很快，作业运行轮转也很快。</p>
<p>主要特点：</p>
<ul>
<li>简单分时操作系统。在简单分时操作系统中，内存只驻留一道作业，其他作业都在外存上，每当内存中的作业运行了一个时间片之后，就会被调出，再从外存上选一个作业调入并运行一个时间片。</li>
<li>具有“前台”和“后台”的分时操作系统。为了改善系统系能，引入了“前台”和“后台”的概念。将作业划分为“前台”和“后台”两类。“前台”存放按时间片调入/调出的作业流，其工作方式与简单分时操作系统相同；“后台”存放批处理作业。仅当“前台”正在调入/调出或无调入/无调出作业流时，才运行“后台”的批处理作业，并给它分配更长的时间片。</li>
<li>多道分时操作系统。引入多道程序设计技术，内存中可以通知装入多道作业，系统把所有具备运行条件的作业排成一个队列，使它们依次轮流获得一个时间片运行。</li>
<li>多路性。一台计算机可以连接多个终端。</li>
<li>交互性。分时操作系统中用户的操作方式是联机方式，即用户通过终端采用人机会话的方式直接控制程序运行。</li>
<li>独占性。由于粉丝操作系统采用时间片轮转的方法使一台计算机同时为多个终端用户服务，运行速度又快，所以感觉像是在独占一样。</li>
<li>及时性。能够在较短的时间内相应用户请求。</li>
</ul>
<h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><p>实时操作系统能够在规定的时间内处理完毕并做出响应。实时操作系统对响应时间的要求比分时操作系统要更高。</p>
<p>可分成以下两类：</p>
<ol>
<li>实时控制系统。</li>
<li>实时信息处理系统。</li>
</ol>
<p>主要特点：</p>
<ul>
<li>及时响应速度。</li>
<li>高可靠性。</li>
</ul>
<h2 id="其他操作系统"><a href="#其他操作系统" class="headerlink" title="其他操作系统"></a>其他操作系统</h2><ol>
<li>嵌入式操作系统</li>
<li>集群系统</li>
<li>网络操作系统</li>
<li>分布式操作系统</li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络必杀题</title>
    <url>/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BF%85%E6%9D%80%E9%A2%98/</url>
    <content><![CDATA[<h2 id="简单介绍一下TCP三次握手，为什么要三次握手"><a href="#简单介绍一下TCP三次握手，为什么要三次握手" class="headerlink" title="简单介绍一下TCP三次握手，为什么要三次握手"></a>简单介绍一下TCP三次握手，为什么要三次握手</h2><p>TCP报文中有两个重要的字段，一个是序号字段，一个是确认号字段，这两个字段在握手阶段以及整个信息传输过程中起到重要作用。</p>
<p>1、客户端TCP会向服务端TCP发送一个不带额外数据的特殊TCP报文段，该字段的SYN标志会被置1，所以把它称为SYN报文段。这时客户端会选取一个初始序列号（客户端的序列号），并将此编号放置到序号字段中。该报文会被封装在一个IP数据报中并发送给服务端。</p>
<p>2、服务端接收到SYN报文段后，会为该TCP连接分配缓存和变量，并发送允许连接的确认报文。在允许连接的确认报文中，SYN位依旧被置为1，序号字段中会存放服务端的序列号，确认号字段会填上客户端序列号+1的值。这个报文段被称为SYN/ACK报文段。</p>
<p>3、客户端在接收到SYN/ACK报文段后，客户端最后向服务端发送一个确认报文段，这个报文段的SYN标志位置0，在确认号上填上服务端序列号+1的值，并且这个报文段可以携带数据。</p>
<p>完成以上三步之后，服务端和客户端就可以互相发送数据了。</p>
<p>如果不是三次握手，而是两次的话，服务端就不知道客户端是否收到了自己的SYN/ACK报文段，从而无法确立连接，四次握手就会显得多余。</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手"></p>
<h2 id="SYN洪泛攻击和解决策略"><a href="#SYN洪泛攻击和解决策略" class="headerlink" title="SYN洪泛攻击和解决策略"></a>SYN洪泛攻击和解决策略</h2><p>什么是SYN洪泛攻击？在TCP三次握手机制的第一步中，客户端会向服务端发送SYN报文段。服务器接收到SYN报文段后为该TCP连接分配缓存和变量，如果攻击分子大量的往服务器发送SYN报文段，服务器就会不断地给这些TCP连接分配变量和缓存，最终服务器的资源会被耗尽，导致内存溢出而无法正常服务。</p>
<p>解决策略：SYN cookie：服务端在接收到客户端的SYN报文段时，不直接为该TCP分配资源，而是之打开一个半开的套接字。接着会使用SYN报文段的源id，目的id，端口号以及只有服务器自己知道的一个秘密函数生成一个cookie，并把cookie作为序列号相应给客户端。如果客户端是正常确认连接，就会返回一个确认字段为cookie + 1的报文段。接下来的服务器会根据确认报文的源id，目的id，端口号以及秘密函数计算出一个结果，如果这个结果的值+1等于确认字段的值，则证明是刚刚请求连接的客户端，这时才为该TCP分配资源。</p>
<p>当然也可以使用降低SYN timeout时间的策略，使得主机尽快释放半连接的占用。</p>
<h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p>当客户端要向服务端断开连接时，客户端TCP会向服务器发送一个特殊的报文段，该报文段的FIN位会被置1，接着服务器会向客户端发送一个确认报文（CLOSE_WAIT）。然后服务端也会像客户端发送一个FIN标志位为1的终止报文段，随后客户端回送一个确认报文段，服务器立即断开连接。客户端等待一段时间后（TIME_WAIT）也断开连接。</p>
<p>大致如上，接下来我一步一步讲：</p>
<p>1、TCP客户端向TCP服务端发送终止报文，FIN位和ACK位置1，（FIN等于1的报文段即使不携带数据也会消耗一个序号），seq的值是客户端之前已传送过的最后一个字节的序号+1，ack的值等于客户端之前已收到的最后一个字节的序号+1。（客户端告诉服务端，老子要断开连接了）</p>
<p>2、TCP服务端接收到该终止报文后，进入CLOSE_WAIT状态，会向客户端发送一个ACK确认报文，ACK位置1，ack为之前的终止报文的序列号+1，seq向客服端之前所发送的最后一个字节的序号+1，这与之前终止报文的ack的值一致。（服务端告诉客户端，老子晓得了）</p>
<p>3、TCP服务端再发送完ACK确认报文后，TCP服务器仍然可以继续发送服务端剩下的数据内容，直到没有数据要发送了，就会向客户端发送终止报文，FIN位、ACK位置1，seq为刚刚传输过去的最后一个字节的序列号+1，ack为对客户端的终止报文的序列号再一次确认。（服务端告诉客户端剩下没讲完的话，讲完剩下的话后就告诉客户端老子讲完话了，可以关了）</p>
<p>4、TCP客户端接收到这个终止报文后，会进入TIME_WAIT状态，会向服务端发送一个ACK确认报文，告诉服务器收到它的关闭报文。该报文ACK位置1，ack为服务端的终止报文序号+1，seq为客户端所发送的终止报文的seq+1（因为FIN报文会消耗一个序号）。当服务端收到这个ACK确认报文，服务端就会关闭连接，客户端会在TIME_WAIT这个状态等待2MSL的时长才会关闭连接。（客户端听到服务端的“可以关了”的话之后，告诉服务端，晓得了，然后服务端就关闭了连接，但是客户端需要等一段时间才能关闭，为了防止出现超时重传的情况）</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手"></p>
<h3 id="为什么要有TIME-WAI状态"><a href="#为什么要有TIME-WAI状态" class="headerlink" title="为什么要有TIME_WAI状态"></a>为什么要有TIME_WAI状态</h3><p>因为客户端需要确保服务端能够收到客户端最后发出去的ACK确认报文段，避免客户端过早进入关闭状态，服务端发送超时重传的状态，这个时候会占用服务器的资源。TIME_WAIT状态也能够确保本次TCP连接中全部的连接报文信息能够在本次连接中完全关闭，避免了新旧连接杂糅的问题。</p>
<h3 id="大量CLOSE-WAIT状态是为什么"><a href="#大量CLOSE-WAIT状态是为什么" class="headerlink" title="大量CLOSE_WAIT状态是为什么"></a>大量CLOSE_WAIT状态是为什么</h3><p>出现了大量的CLOSE_WAIT说明服务器一致向客户端发送终止报文而客户端并没有响应，说明客户端已经关闭了，但是客户端仍然在CLOSE_WAIT状态，也就是说资源没释放，那就需要检查那些资源释放的代码。</p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>TCP是全双工的，客户端和服务端都可以互相发送和接受数据，现在假设是单向的传输数据，接收方有一块接受缓存区，发送方发送数据过来的时候数据会缓存到接收缓存区中，上层应用会在缓存区中有数据的时候来取出数据使用。如果发送方一个劲的发送数据，而接收方的应用并没有及时的将缓存区中的数据取出，就会出现缓存溢出，造成数据丢失，为了解决这个问题，采用流量控制窗口。</p>
<p>假设程序独奏的最后的数据序号是lastByteRead，接收缓存区中接收到的最后一个数据序号是lastByteRcv，接收缓存区的大小为RcvSize，那么必须要满足有lastByteRcv - lastByteRead &lt;= RcvSize才能保证不会出现缓存溢出的情况，所以我们的流量控制窗口就有Rcv = RcvSize - (lastByteRcv - lastByteRead)。因此只要在发送ACK确认报文的时候将流量控制窗口的大小（Rcv）发送给对方，对方就能直到接受方最多能接收多少数据，作为调整发送方的滑动窗口条件之一。</p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>拥塞控制则是考虑到网络环境的拥堵情况，动态的调整每次在网络中发包的数量，采用以下四种算法进行拥塞控制</p>
<ul>
<li>慢开始</li>
<li>拥塞避免</li>
<li>快重传</li>
<li>快恢复</li>
</ul>
<p>假设网络拥塞的阈值为x，慢开始则是将第一次发包的时候设置为1，若没出现拥塞状况，则将发包次数*2，直到一次发包的数量超过了阈值，就停止慢开始算法，使用拥塞避免算法，每次发包的数量+1，直到发生丢包。出现丢包后，认为发生了拥塞现象，那么就将拥塞阈值设置为丢包时的发包量/2，并且重新设置发包的数量为1。之后在开始慢开始算法。</p>
<p>上述的情况，出现丢包后，并不一定是网络拥塞情况，也有可能只是发送了一些网络状况导致对应的数据包丢失。接收方在接收到乱序的数据包后，会立即向发送方发送ACK报文，来告诉发送方并没有接受到指定顺序的数据报，这个ACK数据包会定时发送给发送方，当发送方接收到3个相同的ACK报文后，会立即重新传送一次接收方所缺失的数据报，避免因为超时重传而进入慢开始状态，造成网络吞吐量降低。在进入快重传后，会跟着进入快恢复状态，拥塞阈值变成当前发送的数据报的一半，并且发送数据包的数量变成拥塞阈值+3（因为前面3个ack报文在快重传后就离开了），继续进入拥塞避免状态。</p>
<p>拥塞窗口就是每次传送数据报的数量大小。</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AA%97%E5%8F%A3.png" alt="拥塞控制窗口"></p>
<h2 id="TCP的滑动窗口"><a href="#TCP的滑动窗口" class="headerlink" title="TCP的滑动窗口"></a>TCP的滑动窗口</h2><p>滑动窗口的图分为四部分，并不是说滑动窗口分为四部分，滑动窗口占其中的两个部分（2、3），第一部分是已经发送并且已经确认的数据，这一部分数据已经从滑动窗口中划出，第二部分是已经发送但是还不确定接收方是否收到数据，在等接收方的ACK报文来确认数据是否接收到，若收到了对应的ACK报文，会从对应的数据也会从滑动窗口中滑出，第三部分是即将发送的数据，这一部分数据在滑动窗口中在等待被发送出去，第四部分就是未被发送的数据且不在滑动窗口中，在等待进入滑动窗口。</p>
<p>滑动窗口起到一个限流的作用，滑动窗口的大小决定了当前TCP发包的速率。</p>
<p>滑动窗口的大小 = min(拥塞窗口，流量控制窗口)。</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png" alt="滑动窗口"></p>
<h2 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h2><p>HTTP协议是运行在TCP之上，具有明文传输，服务端与客户端都无法验证对方身份的缺点。HTTPS则是身披SSL（Secure Socket Layer）外壳的HTTP，运行在SSL之上，让SSL与TCP进行通信，添加了加密和认证机制的HTTP。二者之间存在以下不同：</p>
<ol>
<li>端口不同，HTTP与HTTPS使用不同的连接，用得端口也不一样，一个是80端口一个是443端口。</li>
<li>资源消耗不同，HTTPS通信需要进行加减密处理，消耗更多的CPU和内存资源</li>
<li>资金开销：HTTPS通信需要证书，而证书一般需要向认证机构购买。</li>
</ol>
<p>HTTPS的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。</p>
<h2 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h2><ol>
<li>TCP是面向连接的，TCP需要经过三次握手，断开需要经过四次挥手。UDP是面向无连接的，随时可通信，只要设置了监听端口，就可随时监听UDP发送的数据包。</li>
<li>TCP对数据发送的速率是有限制的，通过滑动窗口控制网络发包速率，取决于拥塞控制窗口和流量控制窗口的大小。而UDP理论上可以无限地向网络发送数据包，它的发包速率取决于应用程序地设置。</li>
<li>TCP保证可靠的数据传输，根据速率控制，重传控制还有数据效验提供可靠的数据传输服务。而UDP只是尽力保证数据传输，并不保证数据的可靠性。</li>
<li>TCP头部报文有20字节，而UDP头部字节有8字节，消耗的资源更多。并且TCP建立连接的时候，存在握手机制，使得TCP的使用效率比UDP要低一些。</li>
</ol>
<h2 id="在地址栏键入-URL-后，网络世界发生了什么？"><a href="#在地址栏键入-URL-后，网络世界发生了什么？" class="headerlink" title="在地址栏键入 URL 后，网络世界发生了什么？"></a>在地址栏键入 URL 后，网络世界发生了什么？</h2><ol>
<li>浏览器输入URL之后，DNS会解析当前的域名获取对应的IP地址：具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存，读取本地的Host文件和先本地DNS服务器进行查询等。对于本地DNS服务器进行查询，如果要查询的域名包含在本机配置区域资源中，就将解析结果返回给客户机，完成域名解析；如果查询的域名不由本地的DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析；如果本地域名服务器未缓存该网址映射关系，那么将根据其设置发起递归查询。</li>
<li>浏览器获取域名对应的IP地址后，浏览器向服务器请求连接，发起三次握手。</li>
<li>TCP/IP连接建立后，浏览器向服务器发送HTTP请求。</li>
<li>服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器。</li>
<li>浏览器解析并渲染视图，若遇到对js文件、css文件以及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源。</li>
<li>浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</li>
</ol>
<h2 id="HTTP的常见状态码有哪些，代表什么含义？"><a href="#HTTP的常见状态码有哪些，代表什么含义？" class="headerlink" title="HTTP的常见状态码有哪些，代表什么含义？"></a>HTTP的常见状态码有哪些，代表什么含义？</h2><p>HTTP请求结构： 请求方式 + 请求URI + 协议及其版本<br>　　HTTP响应结构： 状态码 + 原因短语 + 协议及其版本</p>
<p>1xx：请求处理中，请求已被接受，正在处理</p>
<hr>
<p>2xx：请求成功，请求被成功处理</p>
<p>200 OK</p>
<hr>
<p>3xx：重定向，要完成请求必须进一步处理</p>
<p>301 永久性转移</p>
<p>302 暂时性转移</p>
<p>304 已缓存</p>
<hr>
<p>4xx：客户端错误，请求不合法</p>
<p>400 Bad Request，请求有语法问题</p>
<p>401 认证失败</p>
<p>403 拒绝请求</p>
<p>404 所访问的页面不存在</p>
<hr>
<p>5xx：服务器错误，服务器不能处理合法请求</p>
<p>500 服务器内部错误</p>
<p>503 服务器正忙，稍等</p>
<h2 id="GET-请求和-POST-请求的区别"><a href="#GET-请求和-POST-请求的区别" class="headerlink" title="GET 请求和 POST 请求的区别"></a>GET 请求和 POST 请求的区别</h2><ol>
<li>从功能上讲，GET是从服务器获取数据，POST是更新服务器上的资源。</li>
<li>从REST服务角度上说，GET是幂等的，即读取同一个资源，获取到的是相等的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的，也就是说GET不会改变服务器上的资源，而POST会对服务器资源进行改变。</li>
<li>POST安全性比GET高一些，因为POST请求会把参数包装到请求体中，而GET会将参数以明文的方式放在URL中。</li>
<li>GET请求的长度受限于浏览器或服务器对URL的长度限制，允许发送的数据量比较小，而POST请求没有大小限制。</li>
</ol>
<h2 id="什么是-Cookie，Cookie-的使用过程是怎么样的？"><a href="#什么是-Cookie，Cookie-的使用过程是怎么样的？" class="headerlink" title="什么是 Cookie，Cookie 的使用过程是怎么样的？"></a>什么是 Cookie，Cookie 的使用过程是怎么样的？</h2><p>因为HTTP协议是无状态协议，不能够保存用户的访问状态，也就不能够跟踪应用的操作。所以cookie是浏览器的一种缓存机制，它可用于维持客户端和服务端之间的会话。cookie会将会话内容保存在<strong>客户端</strong>。</p>
<p>使用过程：</p>
<ol>
<li>用户在客户端浏览器向服务器发起登录请求。</li>
<li>登陆成功后，服务端会把登录的用户信息保存在cookie中，返回给客户端浏览器。</li>
<li>客户端浏览器接收到cookie之后，一般会将cookie保存到本地。</li>
<li>下次再访问该web应用的时候，客户端浏览器会带上本地的cookie，服务器就能根据cookie获得用户信息。</li>
</ol>
<h2 id="什么是-session，有哪些实现-session-的机制？"><a href="#什么是-session，有哪些实现-session-的机制？" class="headerlink" title="什么是 session，有哪些实现 session 的机制？"></a>什么是 session，有哪些实现 session 的机制？</h2><p>session也是一种维持客户端和服务端的会话机制。但是cookie是将信息内容保存在客户端，而session则是将信息内容保存在服务端。</p>
<p>使用过程如下：</p>
<ol>
<li>用户在客户端浏览器发起请求。</li>
<li>登陆成功后，服务端会把用户信息保存在服务端，并返回一个唯一的session表示给客户端浏览器。</li>
<li>客户端浏览器将这个唯一的session标识起来。</li>
<li>下次再访问该web应用时，客户端浏览器会将这个唯一的sessionID带上，这样服务器就能根据这个sessionID获取到对应的用户信息。</li>
</ol>
<p>session是一种会话机制，在许多的web应用中，session就是用过cookie实现的。它只是使用了cookie功能，并不是说它使用cookie完成会话。</p>
<h2 id="session-和-cookie-有什么区别"><a href="#session-和-cookie-有什么区别" class="headerlink" title="session 和 cookie 有什么区别"></a>session 和 cookie 有什么区别</h2><ol>
<li>cookie是浏览器提供的一种缓存机制，它可以维持客户端和服务端的会话。</li>
<li>session指的是维持客户端客户端与服务端会话的一种机制，它可以通过cookie实现，也可以通过别的手段实现。</li>
<li>如果使用cookie实现会话，那么用户信息会存储在客户端浏览器中。</li>
<li>如果使用session实现会话，用户信息会存储在服务端。</li>
<li>session存储敏感信息会比cookie安全。</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>进程与线程</title>
    <url>/2020/10/29/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>在计算机操作系统中，<strong>进程是资源分配的基本单位</strong>，也是独立运行的基本单位。</p>
<h3 id="程序的执行顺序"><a href="#程序的执行顺序" class="headerlink" title="程序的执行顺序"></a>程序的执行顺序</h3><ul>
<li>顺序性。程序规定顺序执行</li>
<li>封闭性。程序运行后执行结果不会受外界因素影响。</li>
<li>可再现性。程序重复执行会获得相同效果</li>
</ul>
<h3 id="程序的并发执行"><a href="#程序的并发执行" class="headerlink" title="程序的并发执行"></a>程序的并发执行</h3><ul>
<li>间断性。</li>
<li>失去封闭性。程序执行并发的时候，共享资源，也就失去了封闭性。</li>
<li>不可再现性。因为失去了封闭性，资源共享，会导致程序执行的时候资源发生变化，受到外界因素的影响。</li>
</ul>
<p>并发执行的失去封闭性和不可再现性是我们说不期望发生的，我们现在要消除这种情况。</p>
<h3 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a><strong>进程的定义</strong></h3><ul>
<li>进程是程序在处理器上的一次执行过程。</li>
<li>进程是可以和别的进程并行执行的计算。</li>
<li>进程是程序在一个数据集合上的运行过程，是系统进行资源分配和调度的一个独立单位。</li>
<li>进程可定义为一个数据结构及能在其上进行操作的一个程序。</li>
<li>进程是一个程序关于某个数据集合在处理器上顺序执行所发生的活动。</li>
</ul>
<h3 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h3><ul>
<li>动态性。进程是程序在处理器上的一次执行过程，所以是动态的。</li>
<li>并发性。多个进程同时存在于内存中，能在一段时间内同时运行。</li>
<li>独立性。进程是一个能独立运行的基本单位，也是系统进行资源分配和调度的独立单位。</li>
<li>异步性。进程以各自独立，不可预知的速度向前推进。</li>
<li>结构特征。每个进程都具备进程控制块（PCB）。每个进程都由程序段、数据段和一个进程控制块组成。</li>
</ul>
<h3 id="进程和程序的关系"><a href="#进程和程序的关系" class="headerlink" title="进程和程序的关系"></a><strong>进程和程序的关系</strong></h3><ul>
<li>进程是动态的，程序是静态的。进程是程序的执行，每个进程包含了程序段和数据段以及PCB，而程序是有序代码的集合，无执行意义。</li>
<li>进程是暂时的，程序是永久的。进程是一个状态变化的过程，程序可以长久保存。</li>
<li>进程与程序组成不同。进程的组成包括程序段、数据段和进程控制块，程序则只是有序代码的集合。</li>
<li>通过多次执行，一个程序可以产生多个进程；通过调用关系，一个进程可以执行多个程序。进程可创建其他进程，而程序不能形成新的程序。</li>
<li>进程具有并行特性，程序没有。</li>
</ul>
<h3 id="进程的状态转化（重点的重点）"><a href="#进程的状态转化（重点的重点）" class="headerlink" title="进程的状态转化（重点的重点）"></a><strong>进程的状态转化</strong>（重点的重点）</h3><p>5种状态：就绪状态，执行状态，阻塞状态，创建状态，结束状态。</p>
<ul>
<li>就绪状态：进程以获得除了处理器以外的所有资源，一旦进程获得处理器资源，就会立马执行。</li>
<li>执行状态：当一个进程获得必要的资源并正在cpu上执行的时候，该程序所处的状态为执行状态。</li>
<li>阻塞状态：正在执行的程序，由于发生了某件事件而暂时无法执行下去，此时所处的状态成为阻塞状态。这个状态下，即使把处理器分配给该线程，也无法运行。</li>
<li>创建状态，进程正在被创建，尚未转到就绪状态。</li>
<li>结束状态：进程正在从系统中消失。</li>
</ul>
<p>状态转换如下：</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8C%96.png" alt="进程状态转化"></p>
<ul>
<li>就绪-&gt;执行状态：一个进程被进程调度程序选中。</li>
<li>执行-&gt;阻塞状态：请求并等待某个事件发生。</li>
<li>执行-&gt;就绪状态：时间片用完或者在抢占式调度中有更高优先级的进程变为就绪状态。</li>
<li>阻塞-&gt;就绪状态。进程因为等待的某个条件发生而被唤醒。</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h3><ul>
<li>线程是进程内的一个执行单元，比进程更小。</li>
<li>线程是进程内的一个可调度实体。</li>
<li>线程是程序（或进程）中相对独立的一个控制流序列。</li>
<li>线程本身不能单独运行，只能包含在进程中，只能在进程中执行。</li>
</ul>
<h3 id="线程和进程的比较"><a href="#线程和进程的比较" class="headerlink" title="线程和进程的比较"></a>线程和进程的比较</h3><ul>
<li>调度：在传统操作系统中，拥有资源和独立调度的基本单位都是进程。而在引入线程的操作系统中，线程是独立调度的基本单位，进程是拥有资源的基本单位。在同一进程中，线程的切换不会引起进程的切换。在不同进程中线程切换，如同一个进程内的线程切换到另一个进程的线程中，会引起进程切换。</li>
<li>拥有资源：不论是传统操作系统还是设有线程的操作系统，进程都是拥有资源的基本单位，而线程不拥有系统资源，但线程可以访问其归属的进程的系统资源，</li>
<li>并发性：进程之间可以并发执行，而同一进程内的多个线程之间也可以并发执行。这使得操作系统具有更好的并发性，大大提高了系统的吞吐量。</li>
<li>系统开销：进程开销很大，线程开销很小。</li>
</ul>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a><strong>进程通信</strong></h3><ul>
<li><p>共享存储器系统</p>
<p>为了传输大量数据，在存储器中划出一大块共享存储区，多个进程可以通过对共享存储区进行读写来实现通信。在通信前，进程向系统申请建立一个共享存储区，并指定该共享存储区的关键字。若该共享存储区已经建立，则将该共享存储区的描述符返回给申请者。然后，申请者把获得的共享存储区附接到进程上。这样，进程便可以像读写普通寄存器一样读写共享存储区了。</p>
</li>
<li><p>消息传递系统</p>
<p>进程间以消息为单位交换数据，用户直接利用系统提供的一组通信命令来实现通信。操作系统隐藏了同行的实现细节，简化了通信程序，得到了广泛应用。根据实现方式不同，消息传递系统可以分为以下两类：</p>
<ol>
<li>直接通信方式：发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中获取消息。</li>
<li>间接通信方式。发送进程把消息发送到某个中间实体中，接收进程从中取得消息。</li>
</ol>
</li>
<li><p>管道通信系统</p>
<p>管道是用于连接读取进程和写进程以实现它们之间通信的共享文件。向管道提供输入的发送进程以字符流形式将大量的数据送入管道，而接受管道输出的进程可以从管道中接收数据。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>线程</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈PriorityQueue</title>
    <url>/2020/10/29/%E8%B0%88%E8%B0%88PriorityQueue/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>我们需要清楚的一个概念，<strong>什么是队列</strong></p>
<p>百度百科：</p>
<p>队列是一种特殊的<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A1%A8/3228081">线性表</a>，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</p>
<p>换成一句话就是，是一个能够元素先进先出的数据结构。</p>
<p>一般的队列并不会对存储的元素下手，只会按照他们的先后入队顺序存储他们的位置。</p>
<p>清楚了这个，我们再来说一下PriorityQueue这个队列。</p>
<p>标准定义：</p>
<p>PriorityQueue类在Java1.5中引入。PriorityQueue是基于优先堆的一个无界队列，这个优先队列中的元素可以默认自然排序或者通过提供的Comparator（比较器）在队列实例化的时排序。要求使用Java Comparable和Comparator接口给对象排序，并且在排序时会按照优先级处理其中的元素。</p>
<p>PriorityQueue是一个优先级队列，也就是说他会按照一定的规律将内部存储的数据进行排序，我们可以提供Comparator来定义我们的排序形式。</p>
<p>举个例子：</p>
<p>现在该队列里有1 3 5，现在往里面插入 2，该队列的元素顺序会变成1 2 3 5。</p>
<p><strong>会自动排序的队列！</strong></p>
<h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><p>底层就是一颗二叉堆。</p>
<p><strong>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</strong>  </p>
<p><strong>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</strong>  </p>
<p>二叉堆具备以下特点：</p>
<ol>
<li>二叉堆是一个完全二叉树。</li>
<li>根节点总是大于左右节点（大顶堆），或者小于左右节点（小顶堆）。</li>
</ol>
<p>我们向堆内插入数据是自低向上插入</p>
<p>我来模拟一下排序过程：</p>
<p>先是随便整个完全二叉树</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E5%A4%A7%E9%A1%B6%E5%A0%86.png" alt="大顶堆"></p>
<p>好！他很乱！</p>
<p>从底部开始！</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E5%A4%A7%E9%A1%B6%E5%A0%86%E7%9A%84%E5%AD%90%E8%8A%82%E7%82%B9.png" alt="大顶堆的子节点"></p>
<p>给他按照相关规则排序！</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E5%A4%A7%E9%A1%B6%E5%A0%86%E6%8E%92%E5%BA%8F1.png" alt="大顶堆排序1"></p>
<p>好！该节点完事，下一个节点！</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E5%A4%A7%E9%A1%B6%E5%A0%86%E7%9A%84%E5%AD%90%E8%8A%82%E7%82%B91.png" alt="大顶堆的子节点1"></p>
<p>继续排序！</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E5%A4%A7%E9%A1%B6%E5%A0%86%E6%8E%92%E5%BA%8F2.png" alt="大顶堆排序2"></p>
<p>排序完毕。</p>
<p>但是这只是一个比较凑巧的情况，如果顶部的68被换到左子树上，并且比左子树上的左右子树还要小的话怎么办呢？</p>
<p><del>因为例子没有出现所以不讨论</del></p>
<p>这时候就需要对这个子堆再进行一次堆排序，也就是说，如果我们对堆顶的元素位置改变了，那么我们就需要递归的去对他的子堆再来一次排序。后续我会专门说一次堆排序，这里就大致提一下。</p>
<p>我刚刚模拟了一边堆排序的过程，在PriorityQueue队列中，每加入一个元素就相当于在刚刚那样的完全二叉树底部插入一个元素并且再进行一次刚刚的堆排序模拟。</p>
<p>底层数据结构看了，我们看看源码。</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><strong>属性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认初始容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"><span class="comment">//创建的一个队列，队列内的元素下标满足 queue[i]的子节点为queue[2*i+1]和queue[2*i+2]</span></span><br><span class="line"><span class="keyword">transient</span> Object[] queue;</span><br><span class="line"><span class="comment">//队列内的元素个数</span></span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//比较器，用于升序或者降序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"><span class="comment">//队列修改次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure>

<p><strong>构造方法</strong></p>
<p><code>PriorityQueue()</code>  ：创建一个PriorityQueue ，具有默认的初始容量（11），根据它们的自然顺序对其元素进行排序 。 </p>
<p><code>PriorityQueue(Collection&lt;? extends E&gt; c)</code>  ：创建一个collection集合中的元素的PriorityQueue。 </p>
<p><code>PriorityQueue(Comparator&lt;? super E&gt; comparator)</code>  ：创建具有默认初始容量的PriorityQueue，并根据指定的比较器对其元素进行排序。 </p>
<p><code>PriorityQueue(int initialCapacity)</code> ：使用指定的初始容量创建一个 PriorityQueue，并根据其自然顺序对元素进行排序。</p>
<p><code>PriorityQueue(PriorityQueue&lt;? extends E&gt; c)</code>：  创建包含 <code>PriorityQueue</code>优先级队列中的元素的PriorityQueue。 </p>
<p><code>PriorityQueue(SortedSet&lt;? extends E&gt; c)</code>  ：创建一个包含指定排序set集中的元素的PriorityQueue。 </p>
<p><strong>方法</strong></p>
<p><strong>（1）add：插入一个元素，不成功会抛出异常</strong></p>
<p>调用的offer方法。</p>
<p><strong>（2）offer：插入一个元素，不能被立即执行的情况下会返回一个特殊的值（true 或者 false）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    modCount++;<span class="comment">//修改次数加一</span></span><br><span class="line">    <span class="keyword">int</span> i = size;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        grow(i + <span class="number">1</span>);</span><br><span class="line">    siftUp(i, e);</span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入空元素是会报空指针异常的。会先判断队列容量够不够，不够就调用grow来进行队列的扩容，然后插入操作就进入了siftUp()函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        siftUpUsingComparator(k, x, queue, comparator);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUpComparable(k, x, queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里判断我们是否传入了比较器，之后便是插入操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] es)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;) x;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = es[parent];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((T) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        es[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    es[k] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）remove：删除一个元素，如果不成功会返回false。</strong></p>
<p>调用的其实是removeAt()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = indexOf(o);</span><br><span class="line">    <span class="keyword">if</span> (i == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        removeAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">E <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert i &gt;= 0 &amp;&amp; i &lt; size;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] es = queue;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    <span class="keyword">if</span> (s == i) <span class="comment">// removed last element</span></span><br><span class="line">        es[i] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        E moved = (E) es[s];</span><br><span class="line">        es[s] = <span class="keyword">null</span>;</span><br><span class="line">        siftDown(i, moved);</span><br><span class="line">        <span class="keyword">if</span> (es[i] == moved) &#123;</span><br><span class="line">            siftUp(i, moved);</span><br><span class="line">            <span class="keyword">if</span> (es[i] != moved)</span><br><span class="line">                <span class="keyword">return</span> moved;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>堆排序的上浮与下沉。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        siftDownUsingComparator(k, x, queue, size, comparator);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftDownComparable(k, x, queue, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断比较器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] es, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert n &gt; 0;</span></span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;)x;</span><br><span class="line">    <span class="keyword">int</span> half = n &gt;&gt;&gt; <span class="number">1</span>;           <span class="comment">// loop while a non-leaf</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line">        Object c = es[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; n &amp;&amp;</span><br><span class="line">            ((Comparable&lt;? <span class="keyword">super</span> T&gt;) c).compareTo((T) es[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = es[child = right];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((T) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        es[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    es[k] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（4）poll：删除一个元素，并返回删除的元素</strong></p>
<p>调用的siftDown()函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] es;</span><br><span class="line">    <span class="keyword">final</span> E result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((result = (E) ((es = queue)[<span class="number">0</span>])) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">final</span> E x = (E) es[(n = --size)];</span><br><span class="line">        es[n] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; cmp;</span><br><span class="line">            <span class="keyword">if</span> ((cmp = comparator) == <span class="keyword">null</span>)</span><br><span class="line">                siftDownComparable(<span class="number">0</span>, x, es, n);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                siftDownUsingComparator(<span class="number">0</span>, x, es, n, cmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（5）peek：查询队顶元素</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) queue[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（6）indexOf(Object o)：查询对象o的索引</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> Object[] es = queue;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = size; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(es[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（7）contains(Object o)：判断是否容纳了元素</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是红黑树</title>
    <url>/2020/10/29/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<p>在知乎上看到老刘写的<a href="https://zhuanlan.zhihu.com/p/79980618?utm_source=cn.wiz.note">红黑树，超强动静图详解，简单易懂</a>，写得真的很棒，所以这里做下学习记录，再翻版一次。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在学习红黑树之前，需要先了解以下二叉搜索树（二叉平衡树，二叉排序树都是一个东西）。</p>
<p><strong>二叉搜索树</strong>：</p>
<ol>
<li>某节点的左子树节点值仅包含小于该节点值</li>
<li>某节点的右子树节点值仅包含大于该节点值</li>
<li>左右子树每个也必须是二叉查找树</li>
</ol>
<p>二叉搜索树查找元素核心的实现就是二分查找，如果要查找的元素比当前节点的值要大就去右子树找，如果比当前节点小就去左子树找。一颗合格的二叉搜索树应该长以下的样子。</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.png" alt="二叉搜索树"></p>
<p>题外话：二叉搜索树的中序遍历结果是一个递增序列。</p>
<p>我们现在知道了二叉搜索树，那么什么是红黑树呢？</p>
<p>在二叉搜索树插入数据会出现一些比较极端的情况：</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/jio%E6%8E%B0%E6%A0%91.png" alt="jio掰树"></p>
<p>这种情况下的二叉搜索树检索检索元素和线性表无异，这棵树太歪了。</p>
<p>红黑树就是用来解决这类问题的，</p>
<p>简单地说，红黑树就是会动态的调节根节点的位置，使这棵树趋近左右平衡，让这颗树长得不这么歪。</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E7%BA%A2%E9%BB%91%E6%A0%91.png" alt="红黑树"></p>
<p>调节过后这就变成了红黑树。</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树，Red-Black Tree 「RBT」是一个自平衡(不是绝对的平衡)的二叉搜索树(BST)，树上的每个节点都遵循下面的规则:</p>
<p>性质1. 节点是红色或黑色。 </p>
<p>性质2. 根节点是黑色。 </p>
<p>性质3. 所有叶子都是黑色。（叶子是NUIL节点） </p>
<p>性质4. 每个红色节点的两个子节点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色节点，<strong>并没有说不能出现连续的黑色节点</strong>）</p>
<p>性质5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p>
<p>满足以上条件的二叉搜索树就是一颗红黑树。</p>
<p>虽然说条件看起来很复杂，我们直接跟着走几个案例试试。</p>
<p>在走案例之前，我们需要清楚以下操作</p>
<ul>
<li>染色</li>
</ul>
<p>红黑树以红色和黑色分别标记每个节点的颜色信息，所以我们需要会需要对节点进行重新染色的操作。</p>
<hr>
<ul>
<li>左旋转与右旋转</li>
</ul>
<p>个人觉得这就是红黑树的灵魂，就是因为旋转的步骤才保持着满足红黑树的约束条件的同时还能保证最基本的二叉搜索树的约束条件。</p>
<p>分别上个左旋和右旋的操作（该举例只是为了说明旋转的时候节点的去向，并不代表要转成红黑树需要这么做）</p>
<p>左旋：<img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E5%B7%A6%E6%97%8B%E8%BD%AC.png" alt="左旋转"></p>
<p>右旋：<img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E5%8F%B3%E6%97%8B%E8%BD%AC.png" alt="右旋转"></p>
<p><strong>上面的左旋右旋一定看清楚怎么旋转的！</strong></p>
<p><strong>上面的左旋右旋一定看清楚怎么旋转的！</strong></p>
<p><strong>上面的左旋右旋一定看清楚怎么旋转的！</strong></p>
<hr>
<h3 id="红黑树插入操作"><a href="#红黑树插入操作" class="headerlink" title="红黑树插入操作"></a>红黑树插入操作</h3><p>红黑树插入节点与二叉搜索树的插入方式一致，在二叉搜索树插入节点后，会动态的调整根节点位置。</p>
<p>在插入结点的时候，我们会考虑先把节点染色，当染色后不能够满足性质4的时候再进行旋转操作。</p>
<p>算法公式如下：</p>
<p>假设新插入的节点为x</p>
<ol>
<li><p>将新插入的节点标记为红色。</p>
</li>
<li><p>如果x是根节点（root），则标记为黑色。</p>
</li>
<li><p>如果x的父节点不是黑色，同时x也不是根节点：</p>
<p>3.1 如果x的叔叔节点是红色</p>
<p>​    3.1.1 将父节点和叔叔节点标记为黑色</p>
<p>​    3.1.2 将祖父节点标记为红色</p>
<p>​    3.1.3 让x节点的颜色与x祖父的颜色相同，然后重复2、3步骤。</p>
</li>
</ol>
<p>上案例！</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E5%8F%94%E5%8F%94%E8%8A%82%E7%82%B9%E4%B8%BA%E7%BA%A2%E8%89%B2.png" alt="叔叔节点为红色"></p>
<p>​    3.2 如果x的叔叔节点是黑色，就有四种情况需要进行处理</p>
<p>​        3.2.1 x的父节点是x的祖父节点的左孩子，x是父节点的左孩子，左左关系</p>
<p>​        3.2.2 x的父节点是x的祖父节点的左孩子，x是父节点的右孩子，左右关系</p>
<p>​        3.2.3 与3.2.1反过来，镜像，右右关系</p>
<p>​        3.2.4 与 3.2.2反过来，镜像有，右左关系</p>
<p><strong>3.2.1 情况：左左关系：</strong></p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E5%B7%A6%E5%B7%A6%E6%83%85%E5%86%B5.png" alt="左左情况"></p>
<p><strong>3.2.2情况：左右关系：</strong></p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E5%B7%A6%E5%8F%B3%E6%83%85%E5%86%B5.png" alt="左右情况"></p>
<p><strong>3.2.3右右情况</strong></p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E5%8F%B3%E5%8F%B3%E6%83%85%E5%86%B5.png" alt="右右情况"></p>
<p><strong>3.2.4右左情况</strong></p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E5%8F%B3%E5%B7%A6%E6%83%85%E5%86%B5.png" alt="右左情况"></p>
<h3 id="红黑树删除操作"><a href="#红黑树删除操作" class="headerlink" title="红黑树删除操作"></a>红黑树删除操作</h3><p>删除操作则是阅读了<a href="https://blog.csdn.net/m0_37589327/article/details/78518324">该篇博文</a>，讲得是真的好，看了蛮多的红黑树删除操作得视频以及文章只觉得这篇最有价值。</p>
<p>删除操作就需要将所有情况都穷举一遍，是情况是真的多，但是无论我们怎么操作，我们的唯一的目的就是保持红黑树的平衡。</p>
<p>要了解红黑树的删除操作，那么就必须要清楚二叉搜索树的删除操作。</p>
<p>二叉搜索树删除结点会有三种情况出现：</p>
<ol>
<li>如果删除的结点是叶子结点，直接删除即可。</li>
<li>如果删除的结点只有一个结点，直接将父节点的指针指向它的孩子即可。</li>
<li>如果删除的结点有两个孩子，则可以找它的后继，覆盖它的值，之后情况转变为删除前驱结点或者后继结点，也就是回到（1）和（2）两种情况。</li>
</ol>
<p>红黑树删除结点的操作来了：</p>
<p>情况3解决方案：可以转化为情况2与情况1，所以红黑树的删除操作也就转化为下面得两种大情况。</p>
<p>情况2解决方案：这种情况待删除的结点一定是黑色，因为红色结点不能只有一个孩子，这会导致红黑树不平衡，并且他的孩子一定是红色。直接使他的孩子替换掉待删除结点的位置并且染色即可。</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%E6%83%85%E5%86%B52.png" alt="删除结点情况2"></p>
<p>情况1解决方案：这是最为复杂的情况了。</p>
<ol>
<li><p>待删除的结点是红色，删就完事了，不会影响到红黑树平衡。<br><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%E6%98%AF%E7%BA%A2%E8%89%B2.png" alt="删除结点是红色"></p>
</li>
<li><p>待删除的结点是黑色，它兄弟是黑色。</p>
<p>2.1.它兄弟没有孩子，并且它们的爹是红色</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B52.1.png" alt="删除情况2.1"></p>
<p>2.2.它兄弟没有孩子，并且它们的爹是黑色</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B52.2.png" alt="删除情况2.2"></p>
<p>​        这种情况需要注意，因为我们删除了一个黑色节点，所以这种情况该路线不会平衡，我们就需要对父节点进行递归操作处理，重新判断各种情况。</p>
<p>2.3.它兄弟只有一个红色左孩子</p>
<p>​        红色节点不会影响红黑树的性质。从下图看出，父亲结点被拖去左边抵儿子的债了。<br><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%E6%83%85%E5%86%B52.3.png" alt="删除结点情况2.3"></p>
<p>2.4.它兄弟只有一个红色右孩子</p>
<p>​        和2.3的情况十分相似，都是子债父偿，但是2.3情况下当家作主的是侄子结点，在2.4情况下它兄弟当家做主了。</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%E6%83%85%E5%86%B52.4.png" alt="删除结点情况2.4"></p>
</li>
<li><p>待删除的结点是黑色，兄弟结点是红色（该情况下红色肯定是带着两个红色孩子，不然树不会平衡）<br><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%E6%83%85%E5%86%B53.png" alt="删除结点情况3"></p>
</li>
</ol>
<p>这就是全部的红黑树删除情况，剩下的右情况镜像处理即可。</p>
<h2 id="灵魂拷问"><a href="#灵魂拷问" class="headerlink" title="灵魂拷问"></a>灵魂拷问</h2><h3 id="jdk-1-8-HashMap-中有使用到红黑树，你知道触发条件是什么吗？有读过源码是如何-put-和-remove-的吗？"><a href="#jdk-1-8-HashMap-中有使用到红黑树，你知道触发条件是什么吗？有读过源码是如何-put-和-remove-的吗？" class="headerlink" title="jdk 1.8 HashMap 中有使用到红黑树，你知道触发条件是什么吗？有读过源码是如何 put 和 remove 的吗？"></a>jdk 1.8 HashMap 中有使用到红黑树，你知道触发条件是什么吗？有读过源码是如何 put 和 remove 的吗？</h3><p>红黑树插入为O(lgn),查询为O(lgn)，链表插入为O(1)，查询为O(n)。个数少时，插入删除成本高，用链表；个数多时，查询成本高，用红黑树。需要定一个值，比这个值大就转红黑树，比这个值小就转链表，而且要避免频繁的转换。根据泊松分布，在负载因子0.75（HashMap默认）的情况下，单个hash槽内元素个数为8的概率小于百万分之一，将7作为一个分水岭，等于7时不做转换，大于等于8才转红黑树，小于等于6才转链表。</p>
<p>触发转化的两个条件是：一个是链表的长度达到8个，一个是数组的长度达到64个。</p>
<p>put源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>putVal源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;<span class="comment">//定义一个临时链表数组，对hashmap中的table进行操作，n是table的长度，为hashmap初始化时定义的值，是2的幂，i为tab的游标</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)<span class="comment">//如果这个hashmap是空的</span></span><br><span class="line">        n = (tab = resize()).length;<span class="comment">//就resize一下这个hashmap，获取容量（16）</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)<span class="comment">//这行代码的意思是获取tab链表数组中的第length个链表，如果链表为空，就创建新节点添加进去，它的nextnode为null</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))<span class="comment">//如果hash相同，键相同，就直接把p指向e</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)<span class="comment">//如果已经是红黑树了就执行红黑树的添加操作</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;<span class="comment">//链表数组中如果不出现hash碰撞，最完美的情况应该是每个链表都是单结点，这里统计链表中节点的个数</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//TREEIFY_THRESHOLD = 8；判断当前链表长度，如果大于8就把链表转化为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);<span class="comment">//把这个链表转化成红黑树，然后直接退出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))<span class="comment">//在结点遍历的过程中，如果有hash值相同的情况，且key值相同，就直接退出循环，把这个找到的结点直接赋值</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;<span class="comment">//每次都指向下一个结点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)<span class="comment">//根据参数onlyIfAbsent决定是否覆盖</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;返回的是e.value的指向</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;<span class="comment">//操作数+1</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)<span class="comment">//如果链表数组大小大于了阈值，就扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过hash计算要填记得key准备插入的位置，如果key一样就看参数是否决定覆盖，如果是空的就执行插入方法，如果对应的位置有值就判断是红黑树结构还是链表结构，如果是链表结构的话就顺着链表寻找，找到一样的key就跟参数选择覆盖，没找到的话就放在链表的最后面，链表长度大于8的话就进行红黑树化，如果是红黑树结构就按照书的添加方式进行添加。</p>
<p>treeifyBin源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//MIN_TREEIFY_CAPACITY = 64,这里是重点，如果table小于64，那么是走的扩容resize的方法，超过这个数字，才会走到else的TreeNode的构建</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>remove源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>removeNode源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;<span class="comment">// 定义节点数组tab用于指向table、节点p、数组长度n、hash所映射的数组下标</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;<span class="comment">// 节点数组在hash位置处的节点不为空,若为空则直接返回null(不存在可删除元素)</span></span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;<span class="comment">// 定义局部节点变量node存储需要删除的元素、循环变量e、key、value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))<span class="comment">// 头结点即为需要删除的节点</span></span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;<span class="comment">// 链表还存在其他元素,并将e指向头结点的后继元</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)<span class="comment">// 该链表是一个红黑树结构</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);<span class="comment">// 在红黑树中查询指定hash、key的节点并返回</span></span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">// 链表是一个单项链表</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;<span class="comment">// 节点e时需要移除的节点,结束循环</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;<span class="comment">// 循环结束时,节点p为目标节点的前驱元</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;<span class="comment">// 存在需要移除的节点且值匹配删除为false或者不为false且值匹配</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)<span class="comment">// node为树形节点,使用treeNode的移除方法</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)<span class="comment">// 若node为头结点,直接将node 的后继元作为新的头结点</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;<span class="comment">// 链表下移除节点且不为头结点,此时将目标节点的前驱元的后继元指向目标节点的后继元</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是红黑树退成链表的源码，不解读了，在hashMap中的元素小于6的时候会从红黑树退成链表，选择6是为了防止在刚刚转化成红黑树后出现频繁地增加与删除操作导致查询效率低下，所以中间设置缓冲。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">    TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">    TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        tab[index] = first = succ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = succ;</span><br><span class="line">    <span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>)</span><br><span class="line">        root = root.root();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span></span><br><span class="line">        || (movable</span><br><span class="line">            &amp;&amp; (root.right == <span class="keyword">null</span></span><br><span class="line">                || (rl = root.left) == <span class="keyword">null</span></span><br><span class="line">                || rl.left == <span class="keyword">null</span>))) &#123;</span><br><span class="line">        tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">    <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">        <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor</span></span><br><span class="line">            s = sl;</span><br><span class="line">        <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">        TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s&#x27;s direct parent</span></span><br><span class="line">            p.parent = s;</span><br><span class="line">            s.right = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">            <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                    sp.left = p;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sp.right = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">                pr.parent = s;</span><br><span class="line">        &#125;</span><br><span class="line">        p.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">            sr.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">            pl.parent = s;</span><br><span class="line">        <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">            root = s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = s;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = s;</span><br><span class="line">        <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">            replacement = sr;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            replacement = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">        replacement = pl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">        replacement = pr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        replacement = p;</span><br><span class="line">    <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">            (root = replacement).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = replacement;</span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        p.parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                pp.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (movable)</span><br><span class="line">        moveRootToFront(tab, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="哪些场景可以应用红黑树？"><a href="#哪些场景可以应用红黑树？" class="headerlink" title="哪些场景可以应用红黑树？"></a>哪些场景可以应用红黑树？</h3><p>map和set都是用红黑树实现的。它可以在O(log n)时间内做查找，插入和删除等操作。</p>
<p>著名的linux进程调度<strong>Completely Fair Scheduler</strong>,用红黑树管理<strong>进程控制块。</strong></p>
<p><strong>epoll</strong>在内核中的实现，用红黑树管理事件块</p>
<p><strong>nginx</strong>中，用红黑树管理timer等</p>
<p>Java的<strong>TreeMap</strong>实现</p>
<h3 id="你了解各种树的时间复杂度吗？"><a href="#你了解各种树的时间复杂度吗？" class="headerlink" title="你了解各种树的时间复杂度吗？"></a>你了解各种树的时间复杂度吗？</h3><p><strong>二叉树</strong>：</p>
<p>​        查找时间复杂度：最好：<img src="https://math.jianshu.com/math?formula=O(lgn)" alt="O(lgn)">,最差<img src="https://math.jianshu.com/math?formula=O(n)" alt="O(n)">。最差情况是所有的数据全部在一端时。</p>
<p><strong>二叉搜索树（二叉排序树、二叉查找树）：</strong></p>
<p>​        查找时间复杂度：最好：<img src="https://math.jianshu.com/math?formula=O(lgn)" alt="O(lgn)">,最差<img src="https://math.jianshu.com/math?formula=O(n)" alt="O(n)">。最差情况是所有的数据全部在一端时。</p>
<p><strong>平衡二叉树：</strong></p>
<p>​        查找时间复杂度：<img src="https://math.jianshu.com/math?formula=O(lgn)" alt="O(lgn)"></p>
<p><strong>红黑树：</strong></p>
<p>​        查找删除插入时间复杂度：<img src="https://math.jianshu.com/math?formula=O(lgn)" alt="O(lgn)"></p>
<p><strong>B-树、B+树</strong></p>
<p>​        查找时间复杂度：<img src="https://math.jianshu.com/math?formula=O(lgn)" alt="O(lgn)"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title>实现一个自己的简单Mybatis</title>
    <url>/2020/10/29/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%AE%80%E5%8D%95Mybatis/</url>
    <content><![CDATA[<h1 id="实现一个自己的简单Mybatis"><a href="#实现一个自己的简单Mybatis" class="headerlink" title="实现一个自己的简单Mybatis"></a>实现一个自己的简单Mybatis</h1><p>没有什么比自己直接实现一遍框架能够更让人看清楚这个框架是个啥了，手撕开始。</p>
<p>最终的整体目录结构如下：</p>
<p><img src="D:%5CWorkspace%5Cgitbook%5Crecord_source_code%5CMybatis%5C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%AE%80%E5%8D%95Mybatis%5C%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="目录结构"></p>
<p>首先解析一下Mybatis入门的时候所使用到的这些类都是个啥：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//加载配置文件</span></span><br><span class="line">        InputStream is = Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//声明构造工厂构造器</span></span><br><span class="line">        SqlSessionFactoryBuilder build = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">        <span class="comment">//使用配置文件和构造器来构造工厂</span></span><br><span class="line">        SqlSessionFactory factory = build.build(is);</span><br><span class="line">        <span class="comment">//通过工厂来声明对应的Sql实体</span></span><br><span class="line">        SqlSession session = factory.openSession();</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line"></span><br><span class="line">        UserDao userDao = session.getMapper(UserDao.class);</span><br><span class="line">        List&lt;User&gt; users = userDao.findAll();</span><br><span class="line">        <span class="keyword">for</span>(User user : users)&#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        session.close();</span><br><span class="line">        is.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>Resources类：</p>
<p>这个类是获取相关的配置资源的类，它下面的getResourceAsStream()方法是获取到我们项目下的xml文件，使这个xml文件变成输入流。</p>
</li>
<li><p>SqlSessionFactoryBuilder类：</p>
<p>这是个SqlSessionFactory的构造类，类下的build()方法通过给他传递配置文件的字节流，他会读取到其中的配置文件的关键信息（驱动、sql的url、用户名以及密码）的配置信息，然后创建出SqlSessionFactory的实例对象。</p>
</li>
<li><p>SqlSessionFactory类：</p>
<p>会根据SqlSessionFactoryBuilder类的build()方法传递的字节流信息来创建相关的SqlSessionFactory类实例。该类下有个openSession()方法，能够创造出对应的代理对象。</p>
</li>
<li><p>SqlSession类：</p>
<p>代理方法的实现类，用于实现DAO层的接口方法，根据工厂的openSession()方法，从配置文件中获取到DAO层接口的映射信息，通过Proxy.newProxyInstance()方法动态的声明我们的代理方法，实现代理方法就需要一个方法集成InvocationHandler接口并且实现它的invoke()方法。</p>
</li>
</ol>
<p>整体流程如上所述，我并没有讲全，在第2步的时候，我们是读到了xml文件，但是我们怎么解析它呢？</p>
<p>我们使用 dom4j 和 jaxen 两个 jar 包来实现xml文件的解析，下面是maven的依赖配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jaxen<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxen<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>有个小坑，dom4j 2.0.0版本往上解析xml的方式变了，为了能和博文的XML解析的工具类对应上所以推荐用以上的依赖配置。</p>
<p>我们注重的是框架的执行过程，所以xml的解析过程我就不会去说了，直接提供工具类。</p>
<p>我把上面提到的4点中的细节补全。</p>
<p>在第二点中，我们通过XML解析到了配置文件的关键数据，那么我们就需要将这些数据存储到一个资源类之中，先看看我们的配置文件需要存储一点什么：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;899421&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;top.lehanbal.dao.UserDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        &lt;mapper class=&quot;top.lehanbal.dao.UserDao&quot;/&gt;</span></span><br><span class="line"><span class="comment">        &lt;mapper resource=&quot;top/lehanbal/dao/UserDao.xml&quot;/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>数据库的连接信息以及驱动，还有mappers的映射路径。</p>
<p>那么我们的资源类Configuration类就将这些资源封装。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.mybatis.cfg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Mapper&gt; mappers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDriver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> driver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDriver</span><span class="params">(String driver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.driver = driver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrl</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMappers</span><span class="params">(Map&lt;String, Mapper&gt; mappers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mappers.putAll(mappers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Mapper&gt; <span class="title">getMappers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mappers;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Configuration&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;drive=&#x27;&quot;</span> + driver + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, url=&#x27;&quot;</span> + url + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, password=&#x27;&quot;</span> + password + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样我们每次需要相关的配置信息之后，就可以通过这个资源类获取到对应的配置信息。</p>
<p>Mapper类，这里用来存储对应我们再之前的配置文件所写下的映射地址信息以及对应的sql语句。queryString用于封装所存储的sql语句，resultType则是存储对应的类的相对地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.mybatis.cfg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String queryString;</span><br><span class="line">    <span class="keyword">private</span> String resultType;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getQueryString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queryString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQueryString</span><span class="params">(String queryString)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queryString = queryString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getResultType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resultType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResultType</span><span class="params">(String resultType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resultType = resultType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要对配置文件xml进行相关的处理才能读取到对应的文件信息，但是我们处理他们并不是我们所需要关心的重点，所以这里直接提供相关的xml解析工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.mybatis.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.dom4j.Attribute;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"><span class="keyword">import</span> top.lehanbal.mybatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> top.lehanbal.mybatis.cfg.Configuration;</span><br><span class="line"><span class="keyword">import</span> top.lehanbal.mybatis.cfg.Mapper;</span><br><span class="line"><span class="keyword">import</span> top.lehanbal.mybatis.io.Resources;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  用于解析配置文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLConfigBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析主配置文件，把里面的内容填充到DefaultSqlSession所需要的地方</span></span><br><span class="line"><span class="comment">     * 使用的技术：</span></span><br><span class="line"><span class="comment">     *      dom4j+xpath</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Configuration <span class="title">loadConfiguration</span><span class="params">(InputStream config)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//定义封装连接信息的配置对象（mybatis的配置对象）</span></span><br><span class="line">            Configuration cfg = <span class="keyword">new</span> Configuration();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//1.获取SAXReader对象</span></span><br><span class="line">            SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">            <span class="comment">//2.根据字节输入流获取Document对象</span></span><br><span class="line">            Document document = reader.read(config);</span><br><span class="line">            <span class="comment">//3.获取根节点</span></span><br><span class="line">            Element root = document.getRootElement();</span><br><span class="line">            <span class="comment">//4.使用xpath中选择指定节点的方式，获取所有property节点</span></span><br><span class="line">            List&lt;Element&gt; propertyElements = root.selectNodes(<span class="string">&quot;//property&quot;</span>);</span><br><span class="line">            <span class="comment">//5.遍历节点</span></span><br><span class="line">            <span class="keyword">for</span>(Element propertyElement : propertyElements)&#123;</span><br><span class="line">                <span class="comment">//判断节点是连接数据库的哪部分信息</span></span><br><span class="line">                <span class="comment">//取出name属性的值</span></span><br><span class="line">                String name = propertyElement.attributeValue(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;driver&quot;</span>.equals(name))&#123;</span><br><span class="line">                    <span class="comment">//表示驱动</span></span><br><span class="line">                    <span class="comment">//获取property标签value属性的值</span></span><br><span class="line">                    String driver = propertyElement.attributeValue(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">                    cfg.setDriver(driver);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;url&quot;</span>.equals(name))&#123;</span><br><span class="line">                    <span class="comment">//表示连接字符串</span></span><br><span class="line">                    <span class="comment">//获取property标签value属性的值</span></span><br><span class="line">                    String url = propertyElement.attributeValue(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">                    cfg.setUrl(url);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;username&quot;</span>.equals(name))&#123;</span><br><span class="line">                    <span class="comment">//表示用户名</span></span><br><span class="line">                    <span class="comment">//获取property标签value属性的值</span></span><br><span class="line">                    String username = propertyElement.attributeValue(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">                    cfg.setUsername(username);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;password&quot;</span>.equals(name))&#123;</span><br><span class="line">                    <span class="comment">//表示密码</span></span><br><span class="line">                    <span class="comment">//获取property标签value属性的值</span></span><br><span class="line">                    String password = propertyElement.attributeValue(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">                    cfg.setPassword(password);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//取出mappers中的所有mapper标签，判断他们使用了resource还是class属性</span></span><br><span class="line">            List&lt;Element&gt; mapperElements = root.selectNodes(<span class="string">&quot;//mappers/mapper&quot;</span>);</span><br><span class="line">            <span class="comment">//遍历集合</span></span><br><span class="line">            <span class="keyword">for</span>(Element mapperElement : mapperElements)&#123;</span><br><span class="line">                <span class="comment">//判断mapperElement使用的是哪个属性</span></span><br><span class="line">                Attribute attribute = mapperElement.attribute(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(attribute != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;使用的是XML&quot;</span>);</span><br><span class="line">                    <span class="comment">//表示有resource属性，用的是XML</span></span><br><span class="line">                    <span class="comment">//取出属性的值</span></span><br><span class="line">                    String mapperPath = attribute.getValue();<span class="comment">//获取属性的值&quot;com/itheima/dao/IUserDao.xml&quot;</span></span><br><span class="line">                    <span class="comment">//把映射配置文件的内容获取出来，封装成一个map</span></span><br><span class="line">                    Map&lt;String,Mapper&gt; mappers = loadMapperConfiguration(mapperPath);</span><br><span class="line">                    <span class="comment">//给configuration中的mappers赋值</span></span><br><span class="line">                    cfg.setMappers(mappers);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;使用的是注解&quot;</span>);</span><br><span class="line">                    <span class="comment">//表示没有resource属性，用的是注解</span></span><br><span class="line">                    <span class="comment">//获取class属性的值</span></span><br><span class="line">                    String daoClassPath = mapperElement.attributeValue(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">                    <span class="comment">//根据daoClassPath获取封装的必要信息</span></span><br><span class="line">                    Map&lt;String,Mapper&gt; mappers = loadMapperAnnotation(daoClassPath);</span><br><span class="line">                    <span class="comment">//给configuration中的mappers赋值</span></span><br><span class="line">                    cfg.setMappers(mappers);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//返回Configuration</span></span><br><span class="line">            <span class="keyword">return</span> cfg;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                config.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据传入的参数，解析XML，并且封装到Map中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mapperPath    映射配置文件的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  map中包含了获取的唯一标识（key是由dao的全限定类名和方法名组成）</span></span><br><span class="line"><span class="comment">     *          以及执行所需的必要信息（value是一个Mapper对象，里面存放的是执行的SQL语句和要封装的实体类全限定类名）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Mapper&gt; <span class="title">loadMapperConfiguration</span><span class="params">(String mapperPath)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//定义返回值对象</span></span><br><span class="line">            Map&lt;String,Mapper&gt; mappers = <span class="keyword">new</span> HashMap&lt;String,Mapper&gt;();</span><br><span class="line">            <span class="comment">//1.根据路径获取字节输入流</span></span><br><span class="line">            in = Resources.getResourceAsStream(mapperPath);</span><br><span class="line">            <span class="comment">//2.根据字节输入流获取Document对象</span></span><br><span class="line">            SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">            Document document = reader.read(in);</span><br><span class="line">            <span class="comment">//3.获取根节点</span></span><br><span class="line">            Element root = document.getRootElement();</span><br><span class="line">            <span class="comment">//4.获取根节点的namespace属性取值</span></span><br><span class="line">            String namespace = root.attributeValue(<span class="string">&quot;namespace&quot;</span>);<span class="comment">//是组成map中key的部分</span></span><br><span class="line">            <span class="comment">//5.获取所有的select节点</span></span><br><span class="line">            List&lt;Element&gt; selectElements = root.selectNodes(<span class="string">&quot;//select&quot;</span>);</span><br><span class="line">            <span class="comment">//6.遍历select节点集合</span></span><br><span class="line">            <span class="keyword">for</span>(Element selectElement : selectElements)&#123;</span><br><span class="line">                <span class="comment">//取出id属性的值      组成map中key的部分</span></span><br><span class="line">                String id = selectElement.attributeValue(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                <span class="comment">//取出resultType属性的值  组成map中value的部分</span></span><br><span class="line">                String resultType = selectElement.attributeValue(<span class="string">&quot;resultType&quot;</span>);</span><br><span class="line">                <span class="comment">//取出文本内容            组成map中value的部分</span></span><br><span class="line">                String queryString = selectElement.getText();</span><br><span class="line">                <span class="comment">//创建Key</span></span><br><span class="line">                String key = namespace+<span class="string">&quot;.&quot;</span>+id;</span><br><span class="line">                <span class="comment">//创建Value</span></span><br><span class="line">                Mapper mapper = <span class="keyword">new</span> Mapper();</span><br><span class="line">                mapper.setQueryString(queryString);</span><br><span class="line">                mapper.setResultType(resultType);</span><br><span class="line">                <span class="comment">//把key和value存入mappers中</span></span><br><span class="line">                mappers.put(key,mapper);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mappers;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            in.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据传入的参数，得到dao中所有被select注解标注的方法。</span></span><br><span class="line"><span class="comment">     * 根据方法名称和类名，以及方法上注解value属性的值，组成Mapper的必要信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> daoClassPath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Mapper&gt; <span class="title">loadMapperAnnotation</span><span class="params">(String daoClassPath)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//定义返回值对象</span></span><br><span class="line">        Map&lt;String,Mapper&gt; mappers = <span class="keyword">new</span> HashMap&lt;String, Mapper&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.得到dao接口的字节码对象</span></span><br><span class="line">        Class daoClass = Class.forName(daoClassPath);</span><br><span class="line">        <span class="comment">//2.得到dao接口中的方法数组</span></span><br><span class="line">        Method[] methods = daoClass.getMethods();</span><br><span class="line">        <span class="comment">//3.遍历Method数组</span></span><br><span class="line">        <span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">            <span class="comment">//取出每一个方法，判断是否有select注解</span></span><br><span class="line">            <span class="keyword">boolean</span> isAnnotated = method.isAnnotationPresent(Select.class);</span><br><span class="line">            <span class="keyword">if</span>(isAnnotated)&#123;</span><br><span class="line">                <span class="comment">//创建Mapper对象</span></span><br><span class="line">                Mapper mapper = <span class="keyword">new</span> Mapper();</span><br><span class="line">                <span class="comment">//取出注解的value属性值</span></span><br><span class="line">                Select selectAnno = method.getAnnotation(Select.class);</span><br><span class="line">                String queryString = selectAnno.value();</span><br><span class="line">                mapper.setQueryString(queryString);</span><br><span class="line">                <span class="comment">//获取当前方法的返回值，还要求必须带有泛型信息</span></span><br><span class="line">                Type type = method.getGenericReturnType();<span class="comment">//List&lt;User&gt;</span></span><br><span class="line">                <span class="comment">//判断type是不是参数化的类型</span></span><br><span class="line">                <span class="keyword">if</span>(type <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">                    <span class="comment">//强转</span></span><br><span class="line">                    ParameterizedType ptype = (ParameterizedType)type;</span><br><span class="line">                    <span class="comment">//得到参数化类型中的实际类型参数</span></span><br><span class="line">                    Type[] types = ptype.getActualTypeArguments();</span><br><span class="line">                    <span class="comment">//取出第一个</span></span><br><span class="line">                    Class domainClass = (Class)types[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">//获取domainClass的类名</span></span><br><span class="line">                    String resultType = domainClass.getName();</span><br><span class="line">                    <span class="comment">//给Mapper赋值</span></span><br><span class="line">                    mapper.setResultType(resultType);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//组装key的信息</span></span><br><span class="line">                <span class="comment">//获取方法的名称</span></span><br><span class="line">                String methodName = method.getName();</span><br><span class="line">                String className = method.getDeclaringClass().getName();</span><br><span class="line">                String key = className+<span class="string">&quot;.&quot;</span>+methodName;</span><br><span class="line">                <span class="comment">//给map赋值</span></span><br><span class="line">                mappers.put(key,mapper);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mappers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了这些工具类，我们可以开始干点事了。</p>
<p>首先我们通过SqlSessionFactoryBuilder的build方法来使用工具类来解析配置文件，封装对应的Configuration对象，建造对应的设计工厂，也就是return相关的新的工厂类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.mybatis.sqlsession;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.lehanbal.mybatis.cfg.Configuration;</span><br><span class="line"><span class="keyword">import</span> top.lehanbal.mybatis.sqlsession.defalut.DefaultSqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> top.lehanbal.mybatis.utils.XMLConfigBuilder;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionFactoryBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream config)</span> </span>&#123;</span><br><span class="line">        Configuration cfg = XMLConfigBuilder.loadConfiguration(config);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(cfg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过工厂类我们就可以通过openSession来创建对应的sqlSession对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.mybatis.sqlsession.defalut;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.lehanbal.mybatis.cfg.Configuration;</span><br><span class="line"><span class="keyword">import</span> top.lehanbal.mybatis.sqlsession.SqlSession;</span><br><span class="line"><span class="keyword">import</span> top.lehanbal.mybatis.sqlsession.SqlSessionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlSessionFactory</span> <span class="keyword">implements</span> <span class="title">SqlSessionFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Configuration cfg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultSqlSessionFactory</span><span class="params">(Configuration cfg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cfg = cfg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSession <span class="title">openSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(cfg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sqlSession实例如下，getMapper方法来生成对应的代理对象，也就是动态的实现了DAO的实现方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.mybatis.sqlsession.defalut;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.lehanbal.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> top.lehanbal.mybatis.cfg.Configuration;</span><br><span class="line"><span class="keyword">import</span> top.lehanbal.mybatis.sqlsession.SqlSession;</span><br><span class="line"><span class="keyword">import</span> top.lehanbal.mybatis.sqlsession.proxy.MapperProxy;</span><br><span class="line"><span class="keyword">import</span> top.lehanbal.mybatis.utils.DataSourceUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlSession</span> <span class="keyword">implements</span> <span class="title">SqlSession</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Configuration cfg;</span><br><span class="line">    <span class="keyword">private</span> Connection conn;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultSqlSession</span><span class="params">(Configuration cfg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cfg = cfg;</span><br><span class="line">        <span class="keyword">this</span>.conn = DataSourceUtil.getConnection(cfg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; daoIntefaceClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(daoIntefaceClass.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;daoIntefaceClass&#125;, <span class="keyword">new</span> MapperProxy(cfg.getMappers(), conn));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产代理方法，这一步是需要我们手动去实现的，代理方法类必须实现InvocationHandler接口的invoke来实现方法增强。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.mybatis.sqlsession.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.lehanbal.mybatis.cfg.Mapper;</span><br><span class="line"><span class="keyword">import</span> top.lehanbal.mybatis.utils.Executor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Mapper&gt; map;</span><br><span class="line">    <span class="keyword">private</span> Connection conn;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapperProxy</span><span class="params">(Map&lt;String, Mapper&gt; map, Connection conn)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.map = map;</span><br><span class="line">        <span class="keyword">this</span>.conn = conn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法增强</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//获取方法名</span></span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        String className = method.getDeclaringClass().getName();</span><br><span class="line">        String key = className + <span class="string">&quot;.&quot;</span> + methodName;</span><br><span class="line">        Mapper mapper = map.get(key);</span><br><span class="line">        <span class="keyword">if</span>(mapper == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalAccessException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Executor().selectList(mapper, conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代理方法还需要connection对象，所以我们可以写一个工具类获取连接对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.mybatis.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.lehanbal.mybatis.cfg.Configuration;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(Configuration cfg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class.forName(cfg.getDriver());</span><br><span class="line">            <span class="keyword">return</span> DriverManager.getConnection(cfg.getUrl(),cfg.getUsername(),cfg.getPassword());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代理方法中，从mapper中获取对应的sql语句和类的地址信息，负责执行SQL语句，并且封装结果集。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.mybatis.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.lehanbal.mybatis.cfg.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.beans.PropertyDescriptor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSetMetaData;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 负责执行SQL语句，并且封装结果集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(Mapper mapper, Connection conn)</span> </span>&#123;</span><br><span class="line">        PreparedStatement pstm = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.取出mapper中的数据</span></span><br><span class="line">            String queryString = mapper.getQueryString();<span class="comment">//select * from user</span></span><br><span class="line">            String resultType = mapper.getResultType();<span class="comment">//com.itheima.domain.User</span></span><br><span class="line">            Class domainClass = Class.forName(resultType);</span><br><span class="line">            <span class="comment">//2.获取PreparedStatement对象</span></span><br><span class="line">            pstm = conn.prepareStatement(queryString);</span><br><span class="line">            <span class="comment">//3.执行SQL语句，获取结果集</span></span><br><span class="line">            rs = pstm.executeQuery();</span><br><span class="line">            <span class="comment">//4.封装结果集</span></span><br><span class="line">            List&lt;E&gt; list = <span class="keyword">new</span> ArrayList&lt;E&gt;();<span class="comment">//定义返回值</span></span><br><span class="line">            <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">                <span class="comment">//实例化要封装的实体类对象</span></span><br><span class="line">                E obj = (E)domainClass.newInstance();</span><br><span class="line">                <span class="comment">//取出结果集的元信息：ResultSetMetaData</span></span><br><span class="line">                ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line">                <span class="comment">//取出总列数</span></span><br><span class="line">                <span class="keyword">int</span> columnCount = rsmd.getColumnCount();</span><br><span class="line">                <span class="comment">//遍历总列数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= columnCount; i++) &#123;</span><br><span class="line">                    <span class="comment">//获取每列的名称，列名的序号是从1开始的</span></span><br><span class="line">                    String columnName = rsmd.getColumnName(i);</span><br><span class="line">                    <span class="comment">//根据得到列名，获取每列的值</span></span><br><span class="line">                    Object columnValue = rs.getObject(columnName);</span><br><span class="line">                    <span class="comment">//给obj赋值：使用Java内省机制（借助PropertyDescriptor实现属性的封装）</span></span><br><span class="line">                    PropertyDescriptor pd = <span class="keyword">new</span> PropertyDescriptor(columnName,domainClass);<span class="comment">//要求：实体类的属性和数据库表的列名保持一种</span></span><br><span class="line">                    <span class="comment">//获取它的写入方法</span></span><br><span class="line">                    Method writeMethod = pd.getWriteMethod();</span><br><span class="line">                    <span class="comment">//把获取的列的值，给对象赋值</span></span><br><span class="line">                    writeMethod.invoke(obj,columnValue);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//把赋好值的对象加入到集合中</span></span><br><span class="line">                list.add(obj);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            release(pstm,rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(PreparedStatement pstm,ResultSet rs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rs != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pstm != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pstm.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要使用注解的方式，那就写一个注解，XML解析文件当中另外标记了注解的存储方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.mybatis.annotations;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Select &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止，我们的简单Mybatis就写完了。</p>
<p>附上一个运行图：</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E7%BB%93%E6%9E%9C1.png" alt="结果1"></p>
<p>（其实我自己也知道自己讲得八行，但是还是要记录，以后有本事了自己写个更全面的mybatis，主要是涉及到的设计模式没办法详细的说明）</p>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Mybatis</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈Deque</title>
    <url>/2020/10/29/%E8%B0%88%E8%B0%88Deque/</url>
    <content><![CDATA[<p><code>ArrayDeque</code>是<code>Deque</code>接口的一个实现，使用了可变数组，所以没有容量上的限制。同时，<code>ArrayDeque</code>是线程不安全的，在没有外部同步的情况下，不能再多线程环境下使用。<code>ArrayDeque</code>是<code>Deque</code>的实现类，可以作为栈来使用，效率高于<code>Stack</code>；也可以作为队列来使用，效率高于<code>LinkedList</code>。需要注意的是，<code>ArrayDeque</code>不支持<code>null</code>值。</p>
<p>说人话，就是一个比Stack栈效率高，比LinkedList队列效率高的又能当栈又能当队列用的万金油集合，但是不支持多线程，我们来详细看看这到底是个啥，为什么说他性能比Stack和LinkedList要高。</p>
<h2 id="Deque接口"><a href="#Deque接口" class="headerlink" title="Deque接口"></a>Deque接口</h2><p>继承关系如下图：</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="继承关系"></p>
<p>学习一个类，就从它的父类进行学习，所以我们从它的继承关系来看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDeque</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p>继承了Deque接口，Deque这个接口啊，提供了插入，移除和检查元素的方法。deque是“双端队列”的缩写，也就是说，只要是集成了Deque这个接口，都能够实现双端操作。</p>
<p>与List不同，这个接口不支持索引访问元素。</p>
<p>Queue、Stack以及Deque各个接口的方法对比</p>
<table>
<thead>
<tr>
<th align="center">Queue Method</th>
<th align="center">Stack Method</th>
<th align="center">Deque Method</th>
<th align="center"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">add(e)</td>
<td align="center">push(e)</td>
<td align="center">addLast(e)</td>
<td align="center">向队尾\栈顶插入元素，失败则抛出异常</td>
</tr>
<tr>
<td align="center">offer(e)</td>
<td align="center">无</td>
<td align="center">offerLast(e)</td>
<td align="center">向队尾\栈顶插入元素，失败则返回false</td>
</tr>
<tr>
<td align="center">remove()</td>
<td align="center">pop()</td>
<td align="center">removeFirst()</td>
<td align="center">获取并删除队首\栈顶元素，失败则抛出异常</td>
</tr>
<tr>
<td align="center">poll()</td>
<td align="center">无</td>
<td align="center">pollFirst()</td>
<td align="center">获取并删除队首\栈顶元素，失败则返回null</td>
</tr>
<tr>
<td align="center">element()</td>
<td align="center">peek()</td>
<td align="center">getFirst()</td>
<td align="center">获取但不删除队首\栈顶元素，失败则抛出异常</td>
</tr>
<tr>
<td align="center">peek()</td>
<td align="center">无</td>
<td align="center">peekFirst()</td>
<td align="center">获取但不删除队\栈顶首元素，失败则返回null</td>
</tr>
</tbody></table>
<p>这个类给我们分别定义了两套获取元素和插入元素的方法，一套会抛出异常，而另一套只会返回对应的状态值。</p>
<p><strong>Stack不被支持继续使用，它继承自Vector类，Vector因为性能问题已经忌用，所以它的子类也会有类似的问题</strong></p>
<h2 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h2><p><em>ArrayDeque</em>是Deque的一个实现类，底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即<strong>循环数组（circular array）</strong>，也就是说数组的任何一点都可能被看作起点或者终点。</p>
<p><em>ArrayDeque</em>是非线程安全的（not thread-safe），当多个线程同时使用的时候，需要程序员手动同步；另外，<strong>该容器不允许放入null元素</strong>，<strong>该容器不允许放入null元素</strong>，<strong>该容器不允许放入null元素</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存储元素的数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elements;</span><br><span class="line">   <span class="comment">//头部元素索引</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> head;</span><br><span class="line">   <span class="comment">//尾部要加入元素的索引</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> tail;</span><br></pre></td></tr></table></figure>

<p>数组遇到插入元素是一件很苦恼的事情，巧妙地利用循环数组可以直接将元素向头部之前添加元素，并不需要大面积地移动数据。</p>
<p>线性数组与循环数组插入元素地区别图：<strong>（注意头指针和尾指针的位置！头指针指向的是第一个元素，尾指针则是指向最后一个元素的后一位）</strong></p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/%E7%BA%BF%E6%80%A7%E6%95%B0%E7%BB%84%E4%B8%8E%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84.png" alt="线性数组与循环数组"></p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>我们从增删查入手，以此把每个要点的老大看了，就能彻底弄懂的源码。</p>
<h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><p>offer、add、push都是根据插入的位置的不同来分别调用addFirst或者addLast。它俩的源码如下：</p>
<p>addFirst：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)<span class="comment">//前面说过ArrayDeque不能存储空元素，这里源码再一次证明。</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elements;</span><br><span class="line">    es[head = dec(head, es.length)] = e;<span class="comment">//当前头指针指向的是第一个元素，头部指针向前减一位，由于是循环队列，所以会在dec()里面判断并且循环。</span></span><br><span class="line">    <span class="keyword">if</span> (head == tail)<span class="comment">//如果头指针指到尾指针了，就进行扩容，注意是先插入，后扩容，所以插入元素的时候并不需要考虑是否能插入，此时头指针永远都是指向空的位置。</span></span><br><span class="line">        grow(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addFirst所依赖的dec：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> modulus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (--i &lt; <span class="number">0</span>) i = modulus - <span class="number">1</span>;<span class="comment">//如果头指针向前移动了一位就导致数组下标越界了，那么就让这个头指针指向改数组的最后一个位置。</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addLast：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elements;</span><br><span class="line">    es[tail] = e;<span class="comment">//因为是尾指针，尾指针指向的地方为空元素，所以直接将元素插入即可，移动尾指针的步骤在inc里面执行。</span></span><br><span class="line">    <span class="keyword">if</span> (head == (tail = inc(tail, es.length)))<span class="comment">//判断是否需要扩容（顺便移动了尾指针）</span></span><br><span class="line">        grow(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addLast所依赖的inc：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> modulus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (++i &gt;= modulus) i = <span class="number">0</span>;<span class="comment">//尾指针移动之后如果超出了该数组的最大长度，那就让尾指针指向数组的第一个位置。</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><p>与增一致，remove、poll、pop都是调用pollFirst或者pollLast方法，源码如下：</p>
<p>pollFirst：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] es;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> h;</span><br><span class="line">    E e = elementAt(es = elements, h = head);<span class="comment">//获取头元素</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        es[h] = <span class="keyword">null</span>;<span class="comment">//将当前头元素的内容设为null</span></span><br><span class="line">        head = inc(h, es.length);<span class="comment">//调用inc函数让头指针先后移动以为，继续指向当前队列中的第一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pollLast：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] es;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> t;</span><br><span class="line">    E e = elementAt(es = elements, t = dec(tail, es.length));<span class="comment">//因为尾指针指向的位置是空元素，所以需要先进行dec操作将尾指针进行前移，才能获取到队列中的最后一个元素。</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">        es[tail = t] = <span class="keyword">null</span>;<span class="comment">//将当前尾指针指向的内容设值为null</span></span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>一样一样一样，都一样，get、peek、element都是调用的elementAt方法。</p>
<p>elementAt：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;E&gt; <span class="function">E <span class="title">elementAt</span><span class="params">(Object[] es, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) es[i];<span class="comment">//就这么简单,根据下标查询数组内容，所以会在数组下标的参数传递上做功夫。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> elementAt(elements, head);<span class="comment">//直接将头指针的位置传递即可</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] es;</span><br><span class="line">    <span class="keyword">return</span> elementAt(es = elements, dec(tail, es.length));<span class="comment">//尾指针先调用dec向前移动一位才能访问到数组元素，然后根据下标查询数据即可。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增删查就这么搞定了。</p>
<h4 id="扩增函数"><a href="#扩增函数" class="headerlink" title="扩增函数"></a>扩增函数</h4><p>grow函数（看个乐呵）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> needed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldCapacity = elements.length;<span class="comment">//记录下原来数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity;<span class="comment">//声明用于表示新数组长度的变量</span></span><br><span class="line">    <span class="comment">// Double capacity if small; else grow by 50%</span></span><br><span class="line">    <span class="keyword">int</span> jump = (oldCapacity &lt; <span class="number">64</span>) ? (oldCapacity + <span class="number">2</span>) : (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//当原数组的空间小于64的时候，每次就翻倍增则（这里的jump是扩容的量，后面还需要在原数组长度的基础上再加上jump），不然的后就按原数组长度的50%增长（&gt;&gt;1相当于*0.5）</span></span><br><span class="line">    <span class="keyword">if</span> (jump &lt; needed</span><br><span class="line">        || (newCapacity = (oldCapacity + jump)) - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)<span class="comment">//当我们扩容的长度比我们所需要的长度要小的时候，或者是我们扩容的长度已经比我们所设定的最大数组长度还要大的时候，我们会调用newCapacity方法（下一个代码详解）</span></span><br><span class="line">        newCapacity = newCapacity(needed, jump);</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elements = Arrays.copyOf(elements, newCapacity);<span class="comment">//我们把当前的数组用新空间拷贝一份</span></span><br><span class="line">    <span class="keyword">if</span> (tail &lt; head || (tail == head &amp;&amp; es[head] != <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="comment">//tail &lt; head 当头指针在尾指针后面的时候</span></span><br><span class="line">        <span class="comment">//tail == head &amp;&amp; es[head] != null 当头指针等于尾指针且它们指向的内容不为空</span></span><br><span class="line">        <span class="comment">//数组满了的情况就是头指到尾了，所以需要扩容</span></span><br><span class="line">        <span class="keyword">int</span> newSpace = newCapacity - oldCapacity;<span class="comment">//新空间的大小，等价于jump</span></span><br><span class="line">        System.arraycopy(es, head,</span><br><span class="line">                         es, head + newSpace,</span><br><span class="line">                         oldCapacity - head);<span class="comment">//调用系统复制数组，将原数组的元素移动到加了新空间的位置上，同时移动了头指针的位置，与尾指针分开</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head, to = (head += newSpace); i &lt; to; i++)</span><br><span class="line">            es[i] = <span class="keyword">null</span>;<span class="comment">//将新空间中的元素设置为null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>newCapacity：（这个函数是用来判断边界条件以及溢出处理的）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> needed, <span class="keyword">int</span> jump)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldCapacity = elements.length, minCapacity;</span><br><span class="line">    <span class="keyword">if</span> ((minCapacity = oldCapacity + needed) - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//minCapacity是所需要的最小扩容空间，当最小的扩容空间比我们给定的最大数组方法还要大的时候</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>)<span class="comment">//这里是溢出了，直接抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Sorry, deque too big&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;<span class="comment">//不然的话直接返回int的最大值</span></span><br><span class="line">        <span class="comment">//  private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class="line">        <span class="comment">//原先设定的最大数组长度比int的最大值小8，所以还能有剩余空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (needed &gt; jump)<span class="comment">//当我们所需的空间比自动扩容要大，则返回我们能够完成的最小空间</span></span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    <span class="keyword">return</span> (oldCapacity + jump - MAX_ARRAY_SIZE &lt; <span class="number">0</span>)</span><br><span class="line">        ? oldCapacity + jump</span><br><span class="line">        : MAX_ARRAY_SIZE;<span class="comment">//自动扩容的空间如果不比最大数组长度大则返回自动扩容的容量，否则返回指定的最大数组长度。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p><em>LinkedList</em>也是Deque的一个实现类，底层是一个双向链表实现的，记录着前驱和后继两个结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to first node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to last node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该集合的元素存储结构也可以形象的表示为以下图：</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/LinkedList%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E5%9B%BE.png" alt="LinkedList逻辑存储图"></p>
<p>它的继承关系如下图：</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/LinkedList.png" alt="LinkedList"></p>
<p>我们能看到<em>LinkedList</em>实现了Deque和List接口，那么<em>LinkedList</em>就具备了list和deque两个接口的属性，list能够通过下标进行索引访问，deque在前面也介绍了，能够实现双向队列（同样能够当作栈或者队列来使用）。</p>
<p>除此之外，<em>LinkedList</em>能够存储null元素。</p>
<p>那么我们来看看源码。</p>
<h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><h4 id="增-1"><a href="#增-1" class="headerlink" title="增"></a>增</h4><p>与队列和栈的增加元素方法相关的操作都与linkFirst函数和linkLast函数相关，根据插入元素的位置的不同会调用相关操作。</p>
<p>linkFirst：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;<span class="comment">//保存当前first结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);<span class="comment">//声明一个新的结点来作为当前的头节点</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)<span class="comment">//如果之前是空链表，那么就让头和尾指针指向同一个元素，因为当前元素是该链表中唯一的元素</span></span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;<span class="comment">//如果之前不是空链表，那么就让之前的头节点的前驱结点指向当前的头节点</span></span><br><span class="line">    size++;<span class="comment">//链表元素+1</span></span><br><span class="line">    modCount++;<span class="comment">//修改次数+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>linkLast：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;<span class="comment">//保存当前的last结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);<span class="comment">//声明一个新的结点来作为当前的尾结点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)<span class="comment">//如果之前是空链表，那么就让头和尾指针指向同一个元素，因为当前元素是该链表中唯一的元素</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;<span class="comment">//如果之前不是空链表，那么就让之前的尾结点的后继结点指向新的尾结点</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然继承了list接口，就有够通过下标进行元素操作的方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);<span class="comment">//检测index是否合理，必须是链表长度内才行，不然就抛出越界异常</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)<span class="comment">//如果要插入的元素是链表的末尾，那么就直接调用linkLast插入</span></span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));<span class="comment">//调用linkBefore函数插入结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>node：在add函数中已经对index进行了合法判断，所以当前的index是在链表的合理范围内。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//我们需要找到index位置的结点，最坏的情况只需要找n/2次便能找到，因为记录了头节点和尾结点，我们只需要计算index在该链表中心的左边还是右边即可，若是在左边，则从头节点开始查找，若是在右边，则从尾结点开始查找。</span></span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;<span class="comment">//判断index是在链表中心的左边还是右边</span></span><br><span class="line">        Node&lt;E&gt; x = first;<span class="comment">//左边就从头节点开始查找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;<span class="comment">//若在右边则从尾结点开始查找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>linkBefore：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//succ就是我们要插入元素的后继结点，我们需要把我们的元素安排在该结点之前</span></span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;<span class="comment">//记录要插入元素的前驱结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);<span class="comment">//声明一个新的结点，前驱后继如上所说</span></span><br><span class="line">    succ.prev = newNode;<span class="comment">//更新succ节点的前驱，使得我们要插入的元素成为它的前驱结点。</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)<span class="comment">//如果我们要插入的元素是头节点的位置，那么就让这个新的结点成为头节点。</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//不然的话就更新前驱节点的后继结点为我们新的结点。</span></span><br><span class="line">        pred.next = newNode;<span class="comment">//该节点就融入进去了</span></span><br><span class="line">    size++;<span class="comment">//元素数量+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体步骤如下图：</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/LinkedList%E5%8A%A0%E5%85%A5%E6%96%B0%E5%85%83%E7%B4%A0%E7%9A%84%E6%AD%A5%E9%AA%A4.png" alt="LinkedList加入新元素的步骤"></p>
<h4 id="删-1"><a href="#删-1" class="headerlink" title="删"></a>删</h4><p>与队列、栈相关的删除操作本质上是在调用unlinkFirst与unlinkLast</p>
<p>unlinkFirst：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//删除头结点元素</span></span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;<span class="comment">//保存头节点元素，之后要返回</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;<span class="comment">//记录下当前头结点的后继结点，要让它子承父业</span></span><br><span class="line">    f.item = <span class="keyword">null</span>;<span class="comment">//让当前头节点的item以及后继节点的指向都指空，有助于GC回收</span></span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    first = next;<span class="comment">//开始子承父业</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)<span class="comment">//如果成了空链表的话，那么就让头尾都指向null，成为头尾都指向null的空链表，没有指向</span></span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//如果还有元素，那就让子节点的前驱结点指向空，成为头节点（头节点没有前驱结点）</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">    <span class="comment">//如果你疑问为什么next为空了就不需要让next的前驱指针指向空，好好读我下面这句话</span></span><br><span class="line">    <span class="comment">//憨批，next都是null了，null能存什么元素，null就是null，null，什么都没有了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unlinkLast</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//要删除的结点是尾结点</span></span><br><span class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = l.item;<span class="comment">//保存要删除结点的元素以便之后返回</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;<span class="comment">//记录下当前结点的前驱结点，我们要让这个前驱结点成为尾结点</span></span><br><span class="line">    l.item = <span class="keyword">null</span>;<span class="comment">//与前面的删除头节点的时候一致，让当前的尾结点的前驱结点指向和item都标记为null，有助于GC回收</span></span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    last = prev;<span class="comment">//开始树立新的尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)<span class="comment">//同样的，如果删除了刚刚的尾结点让链表成空了，那就让头节点也指向空，彻底抛弃指向，成为头尾都指向空的两边</span></span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//如果删了尾结点还有元素的话就让目前的尾结点的next指向为null，抛弃指向上一个尾结点的指向，这样就能成为真正的尾结点了</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过下标进行元素的删除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       checkElementIndex(index);<span class="comment">//一样是对索引进行合理性判断，不合理则抛出异常</span></span><br><span class="line">       <span class="keyword">return</span> unlink(node(index));<span class="comment">//node(index)找到要删除的结点，然后解除它的应用</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// assert x != null;</span></span><br><span class="line">       <span class="keyword">final</span> E element = x.item;<span class="comment">//记录下x结点的item 前驱后继结点，都记录下来</span></span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;<span class="comment">//如果前驱结点是空，说明我们要删除的结点是头结点，所以让头节点指向x的后继节点即可</span></span><br><span class="line">           first = next;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果不是前驱结点的话</span></span><br><span class="line">           prev.next = next;<span class="comment">//就让x的前驱结点的next直接指向x的后继结点</span></span><br><span class="line">           x.prev = <span class="keyword">null</span>;<span class="comment">//然后将x的前驱结点的指向设为null，不让他指向任何结点</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;<span class="comment">//如果后继结点是空，说明我们要删除的是尾结点，所以让尾指针直接指向x的前驱结点</span></span><br><span class="line">           last = prev;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;<span class="comment">//不然的话，就越过x，让x的后继结点的前驱指向直接指向x的前驱，再把x的后继结点指向null</span></span><br><span class="line">           next.prev = prev;</span><br><span class="line">           x.next = <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       x.item = <span class="keyword">null</span>;<span class="comment">//将x的内容设为null，这样一来，经过上述操作，x.item x.prev x.next全都指向了null</span></span><br><span class="line">       size--;</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="keyword">return</span> element;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>删除指定内容的元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//删除指定元素的操作，就是穷举当前的链表找到值相等的元素，然后调用unlink解除这个结点的前驱和后继，</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;<span class="comment">//因为LinkedList能够存储null值，null值的判断需要单独进行判断</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    unlink(x);<span class="comment">//穷举找到null之后将该结点删除</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item)) &#123;<span class="comment">//一样的穷举思路</span></span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//具体思路也用在了indexOf中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>删除过程的逻辑图：</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/LinkedList%E6%96%AD%E5%BC%80%E8%BF%87%E7%A8%8B.png" alt="LinkedList断开过程"></p>
<h4 id="查-1"><a href="#查-1" class="headerlink" title="查"></a>查</h4><p>队列、栈的头尾元素查询只需要通过对头尾结点的调用即可取得</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">       <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">       <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">       <span class="keyword">return</span> f.item;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">       <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">       <span class="keyword">return</span> l.item;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以上不解读了，一眼就看明白的东西</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       checkElementIndex(index);</span><br><span class="line">       <span class="keyword">return</span> node(index).item;<span class="comment">//node函数之前已经解读过了，通过对index的大小判断，在链表中心的哪一段，然后利用头尾结点就能实现n/2的查找速率</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>LinkedList解读完了，我们在一起来看看ArrayDeque和LinkedList吧。</p>
<h2 id="ArrayDeque与LinkedList"><a href="#ArrayDeque与LinkedList" class="headerlink" title="ArrayDeque与LinkedList"></a><em>ArrayDeque</em>与<em>LinkedList</em></h2><p>我说了这么多，源码也给读了，剩下就看你们来总结这两者的不同吧。</p>
<p>如果你总结不出，那只能说明你没看我写的文章，懒狗。</p>
<p>但是本人也是懒狗，这里记录下这两者的不同，以及正面回答为什么很多情况下推荐使用ArrayDeque。</p>
<ol>
<li>ArrayDeque底层通过数组实现，底层是一个循环数组，动态扩容；LinkedList则是通过一个双向链表实现。</li>
<li>ArrayDeque并不能够存储null元素，有意为之，但是LinkedList能够存储null。</li>
<li>ArrayDeque进行扩容的时候会需要比较大的性能开销，LinkedList是链表实现，并不需要扩容操作，只需要指针指向即可。</li>
</ol>
<p>但是ArrayDeque插入头尾数据和删除数据都是妥妥的O(1)复杂度，作为队列或者栈来使用的时候，还有什么比O(1)的头部尾部操作更优秀呢？对于循环数组而言，它的随机访问依旧是O(1)，链表则是O(n)，此时唯一的缺点就是扩容造成的性能开销；相比之下LinkedList是通过链表实现的，同时他还继承了List接口，除了能够当成双向队列来使用的时候，还能够通过下表进行数据的访问以及相关操作，并且链表的优点是删除元素的时候很方便只有O(1)的时间复杂度，但是删除元素的时候你需要先找到当前元素，所以还是一个O(n)的时间过程，在当作队列或者栈来说的时候，ArrayDeque在操作的复杂度上而言，完爆LinkedList。</p>
<p>但是读过ArrayDeque源码之后我们知道，这玩意扩容很耗空间，而且扩容的时候性能开销也是实实在在存在的，LinkedList则是动态的使用空间大小，每次添加新的结点的时候都是原地创建结点再创建应用，并不会造成先ArrayDeque那样的扩容开销，而且它能够通过下标访问，所以在不作为队列或者栈使用的时候，是有它的用武之地。</p>
<ul>
<li>在我们清楚我们的操作需要消耗多少空间的时候，优先推荐使用ArrayDeque作为队列或者栈的集合。</li>
<li>若是我们不清楚消耗的空间，并且消耗的空间会持续增大的话，可以考虑使用LinkedList来作为队列或者栈的集合。（防止ArrayDeque多次地扩容造成性能浪费）。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>JAVA</tag>
        <tag>Deque</tag>
      </tags>
  </entry>
</search>
