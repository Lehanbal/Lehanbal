---
title: Redis事务
date: 2020-11-13 10:39:09
tags:
- Redis
categories:
- Redis
---

我们所学过的事务是遵循一个ACID原则，也就是保证原子性、一致性、隔离性和持久性。

但是对于Redis来说，它的事务并不会保证原子性，和隔离性。

当出现运行时异常的错误语句时，其他语句依旧会成功执行。也就是说，Redis的单条语句具有原子性，但是它的事务却没有原子性。

Redis事务所具备的三个阶段：

- 开始事务（multi）
- 输入命令，如果任意命令执行失败，其他命令依旧会被执行。
- 执行事务（exec）

Redis事务具有以下命令：

| 命令         | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| discard      | 取消事务，放弃执行事务块内的全部命令                         |
| exec         | 执行所有事务块内的命令                                       |
| multi        | 被标记一个事务块的开始                                       |
| unwatch      | 取消watch命令对所有key的监视                                 |
| watch key... | 监视一个或多个key，如果在事务执行前这个key被其他命令改动，那么就会打断事务 |

## 事务实例

```
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set k1 v1
QUEUED
127.0.0.1:6379> set k2 v2
QUEUED
127.0.0.1:6379> set k3 v3
QUEUED
127.0.0.1:6379> get k3
QUEUED
127.0.0.1:6379> exec
1) OK
2) OK
3) OK
4) "v3"
```

### Redis事务没有原子性的实例

```bash
127.0.0.1:6379> set k1 v1
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set k2 v2
QUEUED
127.0.0.1:6379> incr k1
QUEUED
127.0.0.1:6379> get k2
QUEUED
127.0.0.1:6379> exce
1) OK
2) (error) ERR value is not an integer or out of range
3) "v2"
```

## 乐观锁实例

先说一下乐观锁与悲观锁的区别：

悲观锁：无论做什么都会先去加锁，只有加锁了才继续下一步操作。比较影响性能，一般用在重写数据量会造成较大损失的场景，保证数据不需要重写。

乐观锁：直接不加锁，记录下原来数据的值，当需要执行数据的时候就将原数据的值与记录下的数据的值进行比对，如果一致就说明没被修改过，接着正常执行语句。但是如果不一致说明有其他进程对数据进行了修改，不一致的情况就会抛弃掉之前所需要执行的操作。乐观锁性能很好，因为它不会对数据进行加锁操作造成阻塞状态。一般用在重写操作步骤能够接受的场景下。

在Redis中实现乐观锁就是通过**watch**命令进行操作的。watch和mysql中的vesion关键字一样，都是实现乐观锁的关键字。

演示一个乐观锁场景：

### 正常执行

```bash
127.0.0.1:6379> set money 1000
OK
127.0.0.1:6379> set consume 0
OK
127.0.0.1:6379> watch money
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> decrby money 200
QUEUED
127.0.0.1:6379> incrby consume 200
QUEUED
127.0.0.1:6379> exec
1) (integer) 800
2) (integer) 200
```

### 乐观锁触发场景

在执行一条事务的过程中，有其他的进程对被监视的数据进行了修改。

```bash
127.0.0.1:6379> set money 1000
OK
127.0.0.1:6379> set consume 0
OK
127.0.0.1:6379> watch money
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> decrby money 200
QUEUED
127.0.0.1:6379> incrby consume 200
QUEUED
```

此时事务并没有执行完，出现另一个进程对数据进行了修改。

```bash
127.0.0.1:6379> get money
"1000"
127.0.0.1:6379> incrby money 200
(integer) 1200
```

数据被修改了之后再执行原来的事务，触发乐观锁。

```bash
127.0.0.1:6379> set money 1000
OK
127.0.0.1:6379> set consume 0
OK
127.0.0.1:6379> watch money
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> decrby money 200
QUEUED
127.0.0.1:6379> incrby consume 200
QUEUED
127.0.0.1:6379> exec
(nil)
```

