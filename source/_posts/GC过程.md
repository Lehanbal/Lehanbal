---
title: GC过程
date: 2020-11-03 20:33:49
tags:
- GC
- JAVA
categories:
- JAVA
---

## jvm内存回收算法

1. 引用计数法：如果有地方引用该对象，那么该对象的引用计数+1。引用失效就-1。为0的对象不可以被使用。
2. 可达性分析：如果我们将一些GCRoots对象作为起点，从这些节点向下搜索，搜索的路径为引用链，如果有一些对象没有任何引用链相连，那么就说明这个对象对于GCRoots是不可达的。所以将其判定为可回收对象。

如果两个对象互相引用，引用计数法无法判定其死亡，所以JVM使用的是可达性分析算法。

## 什么可以作为GCRoots

- java虚拟机栈中的引用对象。
- 方法区中的类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI引用的对象。

## 处理的GC算法

- **标记-清理法**：通过GCRoots的可达性分析，将能够达到的节点都加上一个标记，进行遍历过后，会将没有标记的节点进行资源回收。缺点是会产生内存碎片，不能够更好的利用内存空间，
- **标记-整理法**：如果下一个内存是空的，就移动后面的数据，占据空内存的位置，压缩空间，减少内存碎片。缺点是性能开销过大，因为需要移动全部的内存。
- **复制算法**：将内存一分为二（假设a内存和b内存），a内存中被标记了的元素，紧凑的复制到b内存中，避免了产生过多的内存碎片和性能开销过大的问题，但是缺点是需要两倍的内存空间。（拿空间换时间的意思）

## 实际的GC过程

![image-20201103211825342](http://cdn.lehanbal.top/image-20201103211825342.png)

1. 将内存进行了划分，划分为新生代（young）和老年代（old）。

2. 将新生代继续划分，划分成Eden区（伊甸园区）和2个Survivor区（s0和s1）；老年代则是一整块区域。

3. new对象产生在伊甸园区，当伊甸园区快慢的时候会触发GC，这个GC是发生在Young区的，所以也叫YoungGC，YoungGC使用的是复制算法，在伊甸园区需要复制的节点做上一个标记，标记了的节点会被复制到Survivor区（s0或s1均可，内存大小为 s0:s1:Eden = 1:1:8）。

   至于为什么需要两块Survivor区？因为这两块区域是交替工作的，在E区标记完后，活下来的元素被放到s0，然后将s1和Eden区的节点一起GC了，等到下一次GC的时候，将s0和Eden区进行一次标记，然后再将活下来的元素复制到s1，然后将s0和Eden区的元素删除，如此反复。（针对一些朝生夕死的特点设计的）。

4. 每次触发YoungGC，活下来的元素年龄都会加1，直到年龄到了15（这个界限可调整），他就不在Survivor区复制了，直接将不需要删除的对象放到Old区里，因为他活了很久，说明很可能是重要的引用对象，需要很久才会被做掉；老年代除了存放年龄大于15岁的对象，还会存放大的对象，当Old区满的时候也会触发GC，这个叫OldGC，一般会触发YoungGC，所以也叫FullGC，此时会发生Stop-The-World，整个Java程序暂停，全力协助GC。

5. 标记-清理算法、标记-整理算法主要发生在old区；复制算法主要发生在Young区。

## 比较著名的垃圾收集器

- 新生代：Serial、ParNew（Serial的多线程版本）、Parallel Scavenge（关注吞吐率）

- 老年代：serial Old、CMS、Parallel Old

**一般**新生代和老年代的垃圾收集器是按照Serial与Serial Old做组合、ParNew和CMS做组合、Parallel Scavenge和Parallel Old做组合。

最新的垃圾收集器G1（Garbege First）。