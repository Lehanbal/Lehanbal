title: 线程安全和线程不安全
tags:
  - 操作系统
  - 线程
categories:
  - 操作系统
date: 2020-10-10 17:46:00
---



**线程安全**：就是多线程访问的时候，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问。直到该线程操作完毕，其他线程才可使用。不会出现数据不一致或者数据污染。

**线程不安全**：即使不提供数据访问保护，会出现多个线程先后更新数据造成脏数据。

## 概念

如果进程中有多个线程在同时运行，这些线程可能会同时运行这段代码，若每次运行结果都是一样的，而且其他变量的值也都是和预期一样，那么我们就可以说这就是线程安全。

若每个线程中对全局变量、静态变量只有读操作而无写操作，那么这些变量就是线程安全的，如果有多个线程同时执行写操作，就需要考虑线程同步，否则的话就可能有线程安全问题。

## 实例

一个卖票用例

```java
package Lehanbal.study.threadRunable;

public class Demo02Ticket implements Runnable{
    private int Ticket = 100;

    @Override
    public void run() {
        while(Ticket > 0){
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("当前在卖第" + Ticket + "票");
            Ticket--;
        }
    }
}

```

主函数方法：开1K个线程，

```java
package Lehanbal.study.threadRunable;

public class Test {
    public static void main(String[] args) {
        Demo02Ticket a = new Demo02Ticket();

        new Thread(a).start();
        new Thread(a).start();
        new Thread(a).start();
        new Thread(a).start();

    }
}
```

最终的执行结果如下：

当前在卖第100票

当前在卖第100票

当前在卖第100票

当前在卖第100票

....

当前在卖第1票

当前在卖第0票

当前在卖第-1票

当前在卖第-1票

会出现一些不一致的情况，这就是线程不安全。解决的办法就是加上Synchronized让方法同步。

修改如下：

1、Synchronized修饰词，可以保证被修饰的方法同步

```java
package Lehanbal.study.threadRunable;

public class Demo02Ticket implements Runnable{
    private int Ticket = 100;

    @Override
    public synchronized void run() {
        while(Ticket > 0){
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("当前在卖第" + Ticket + "票");
            Ticket--;
        }
    }
}
```

2、加上锁，加上锁与解开锁的中间代码就是一整个原子代码，这一段保证了线程安全。

```java
package Lehanbal.study.threadRunable;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Demo02Ticket implements Runnable{
    private int Ticket = 100;

    Lock lock = new ReentrantLock();

    @Override
    public void run() {
        while(Ticket > 0){
            lock.lock();
            if(Ticket > 0){
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("当前在卖第" + Ticket + "票");
                Ticket--;
            }
            lock.unlock();
        }
    }
}
```

