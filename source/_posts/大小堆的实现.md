title: 大小堆的实现
tags:
  - 数据结构
  - JAVA
  - 堆
categories:
  - 数据结构
date: 2020-10-20 14:57:00
---

我在讲PriorityQueue这一个优先级队列的时候，说了它底层其实是一个大小堆来实现的优先级存储，我也粗略的点了一下大小堆的概念，这次的文章就详细的说一下堆排序是如何实现的。

## 堆与堆排序的定义

**堆**：堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。

**堆排序**：（英语：Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足**堆积的性质**：即子结点的键值或索引总是小于（或者大于）它的父节点。

![大顶堆与小顶堆](http://cdn.lehanbal.top/%E5%A4%A7%E9%A1%B6%E5%A0%86%E4%B8%8E%E5%B0%8F%E9%A1%B6%E5%A0%86.png)

那就有一个公式：

**大顶堆**：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]

**小顶堆**：arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]

## 堆排序过程

整体过程：将待排序的序列构造成大顶堆，此时最大值就是堆的顶点，此时将堆顶和末尾元素进行交换，此时末尾就是最大节点。再把除了末尾节点的剩下元素重新构造成大顶堆，此时堆顶是次最大元素，再与末尾元素-1的位置交换······如此反复，得到的就是一个升序的序列。（如果要降序序列，那就使用小顶堆重复一样的过程）

接下来模拟整个过程：

### 堆调整

1. 首先假定一个无序序列

   ![堆排序过程1](http://cdn.lehanbal.top/%E5%A0%86%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B1.png)

2. 然后从最后一个非叶子节点开始（arr.length / 2 - 1），也就是图中的序号1节点，调整它的位置。

   ![堆排序过程2](http://cdn.lehanbal.top/%E5%A0%86%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B2.png)

3. 再继续找下一个非叶子节点，也就是根节点，对它进行堆调整。

   ![堆排序过程3](http://cdn.lehanbal.top/%E5%A0%86%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B3.png)

4. 注意这个时候我们把0和1的位置进行的调换，换下来的值可能会造成原先已经是大顶堆的子节点顺序被破坏，此时就需要重新对子节点进行依次堆调整。（换句话说，就是只要我们动了非叶子节点的父节点，那么它父节点往下的非叶子节点都需要重新堆调整一次，使用递归来完成）

   我们得到了我们需要的大顶堆：

   ![堆排序过程4](http://cdn.lehanbal.top/%E5%A0%86%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B4.png)

### 堆排序

1. 我们将堆顶元素和末尾元素交换顺序。

   ![堆排序过程5](http://cdn.lehanbal.top/%E5%A0%86%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B5.png)

2. 重新调整除了末尾元素的堆，使得再次成为大顶堆。

   ![堆排序过程6](http://cdn.lehanbal.top/%E5%A0%86%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B6.png)

3. 将堆顶元素和次末尾元素交换顺序。

   ![堆排序过程7](http://cdn.lehanbal.top/%E5%A0%86%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B7.png)

4. 重复2、3操作，最终得到的结果

   ![堆排序过程8](http://cdn.lehanbal.top/%E5%A0%86%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B8.png)

最终我们通过大顶堆实现了一个升序序列。

### 堆排序的时间复杂度

堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。其中构建初始堆经推导复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)...1]逐步递减，近似为nlogn。所以堆排序时间复杂度一般认为就是O(nlogn)级。

## 代码实现

```java
public class HeapSort {
    public void sort(int[] arr){
        for(int i = arr.length / 2 - 1; i >= 0; i--){//从第一个非叶子节点，从下到上，从左到右调整
            adjustHeap(arr, i, arr.length);
        }
        for(int j = arr.length - 1; j > 0; j--){
            swap(arr, 0, j);//与队尾元素交换
            adjustHeap(arr, 0, j);//重新调整剩下的堆
        }
    }

    private void adjustHeap(int[] arr, int i, int length){
        int temp = arr[i];//取出当前元素
        for(int k = i * 2 + 1; k < length; k = k * 2 + 1){//跳到i的左节点，每次都先跳到左节点
            if(k + 1 < length && arr[k] < arr[k + 1]) k++;//如果右节点存在并且比左节点还要大，那就指向右节点
            if(arr[k] > temp){//如果子节点大于父节点，那就覆盖掉父节点的值
                arr[i] = arr[k];
                i = k;
            }
            else break;
        }
        arr[i] = temp;//将被覆盖的父节点放到最终的位置
    }

    private void swap(int[] arr, int i, int j){
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

