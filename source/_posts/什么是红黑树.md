---
title: 什么是红黑树
date: 2020-10-29 15:03:07
tags: 
- 红黑树
- 数据结构
categories:
- 数据结构
---

在知乎上看到老刘写的[红黑树，超强动静图详解，简单易懂](https://zhuanlan.zhihu.com/p/79980618?utm_source=cn.wiz.note)，写得真的很棒，所以这里做下学习记录，再翻版一次。

## 概念

在学习红黑树之前，需要先了解以下二叉搜索树（二叉平衡树，二叉排序树都是一个东西）。

**二叉搜索树**：

1. 某节点的左子树节点值仅包含小于该节点值
2. 某节点的右子树节点值仅包含大于该节点值
3. 左右子树每个也必须是二叉查找树

二叉搜索树查找元素核心的实现就是二分查找，如果要查找的元素比当前节点的值要大就去右子树找，如果比当前节点小就去左子树找。一颗合格的二叉搜索树应该长以下的样子。

![二叉搜索树](http://cdn.lehanbal.top/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.png)

题外话：二叉搜索树的中序遍历结果是一个递增序列。

我们现在知道了二叉搜索树，那么什么是红黑树呢？

在二叉搜索树插入数据会出现一些比较极端的情况：

![jio掰树](http://cdn.lehanbal.top/jio%E6%8E%B0%E6%A0%91.png)

这种情况下的二叉搜索树检索检索元素和线性表无异，这棵树太歪了。

红黑树就是用来解决这类问题的，

简单地说，红黑树就是会动态的调节根节点的位置，使这棵树趋近左右平衡，让这颗树长得不这么歪。

![红黑树](http://cdn.lehanbal.top/%E7%BA%A2%E9%BB%91%E6%A0%91.png)

调节过后这就变成了红黑树。

## 红黑树

红黑树，Red-Black Tree 「RBT」是一个自平衡(不是绝对的平衡)的二叉搜索树(BST)，树上的每个节点都遵循下面的规则:

性质1. 节点是红色或黑色。 

性质2. 根节点是黑色。 

性质3. 所有叶子都是黑色。（叶子是NUIL节点） 

性质4. 每个红色节点的两个子节点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色节点，**并没有说不能出现连续的黑色节点**）

性质5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

满足以上条件的二叉搜索树就是一颗红黑树。

虽然说条件看起来很复杂，我们直接跟着走几个案例试试。

在走案例之前，我们需要清楚以下操作

- 染色

红黑树以红色和黑色分别标记每个节点的颜色信息，所以我们需要会需要对节点进行重新染色的操作。

----

- 左旋转与右旋转

个人觉得这就是红黑树的灵魂，就是因为旋转的步骤才保持着满足红黑树的约束条件的同时还能保证最基本的二叉搜索树的约束条件。

分别上个左旋和右旋的操作（该举例只是为了说明旋转的时候节点的去向，并不代表要转成红黑树需要这么做）

左旋：![左旋转](http://cdn.lehanbal.top/%E5%B7%A6%E6%97%8B%E8%BD%AC.png)

右旋：![右旋转](http://cdn.lehanbal.top/%E5%8F%B3%E6%97%8B%E8%BD%AC.png)

**上面的左旋右旋一定看清楚怎么旋转的！**

**上面的左旋右旋一定看清楚怎么旋转的！**

**上面的左旋右旋一定看清楚怎么旋转的！**

----

### 红黑树插入操作

红黑树插入节点与二叉搜索树的插入方式一致，在二叉搜索树插入节点后，会动态的调整根节点位置。

在插入结点的时候，我们会考虑先把节点染色，当染色后不能够满足性质4的时候再进行旋转操作。

算法公式如下：

假设新插入的节点为x

1. 将新插入的节点标记为红色。

2. 如果x是根节点（root），则标记为黑色。

3. 如果x的父节点不是黑色，同时x也不是根节点：

   3.1 如果x的叔叔节点是红色

   ​	3.1.1 将父节点和叔叔节点标记为黑色

   ​	3.1.2 将祖父节点标记为红色

   ​	3.1.3 让x节点的颜色与x祖父的颜色相同，然后重复2、3步骤。

上案例！

![叔叔节点为红色](http://cdn.lehanbal.top/%E5%8F%94%E5%8F%94%E8%8A%82%E7%82%B9%E4%B8%BA%E7%BA%A2%E8%89%B2.png)

​	3.2 如果x的叔叔节点是黑色，就有四种情况需要进行处理

​		3.2.1 x的父节点是x的祖父节点的左孩子，x是父节点的左孩子，左左关系

​		3.2.2 x的父节点是x的祖父节点的左孩子，x是父节点的右孩子，左右关系

​		3.2.3 与3.2.1反过来，镜像，右右关系

​		3.2.4 与 3.2.2反过来，镜像有，右左关系

**3.2.1 情况：左左关系：**

![左左情况](http://cdn.lehanbal.top/%E5%B7%A6%E5%B7%A6%E6%83%85%E5%86%B5.png)

**3.2.2情况：左右关系：**

![左右情况](http://cdn.lehanbal.top/%E5%B7%A6%E5%8F%B3%E6%83%85%E5%86%B5.png)

**3.2.3右右情况**

![右右情况](http://cdn.lehanbal.top/%E5%8F%B3%E5%8F%B3%E6%83%85%E5%86%B5.png)

**3.2.4右左情况**

![右左情况](http://cdn.lehanbal.top/%E5%8F%B3%E5%B7%A6%E6%83%85%E5%86%B5.png)

### 红黑树删除操作

删除操作则是阅读了[该篇博文](https://blog.csdn.net/m0_37589327/article/details/78518324)，讲得是真的好，看了蛮多的红黑树删除操作得视频以及文章只觉得这篇最有价值。

删除操作就需要将所有情况都穷举一遍，是情况是真的多，但是无论我们怎么操作，我们的唯一的目的就是保持红黑树的平衡。

要了解红黑树的删除操作，那么就必须要清楚二叉搜索树的删除操作。

二叉搜索树删除结点会有三种情况出现：

1. 如果删除的结点是叶子结点，直接删除即可。
2. 如果删除的结点只有一个结点，直接将父节点的指针指向它的孩子即可。
3. 如果删除的结点有两个孩子，则可以找它的后继，覆盖它的值，之后情况转变为删除前驱结点或者后继结点，也就是回到（1）和（2）两种情况。

红黑树删除结点的操作来了：

情况3解决方案：可以转化为情况2与情况1，所以红黑树的删除操作也就转化为下面得两种大情况。

情况2解决方案：这种情况待删除的结点一定是黑色，因为红色结点不能只有一个孩子，这会导致红黑树不平衡，并且他的孩子一定是红色。直接使他的孩子替换掉待删除结点的位置并且染色即可。

![删除结点情况2](http://cdn.lehanbal.top/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%E6%83%85%E5%86%B52.png)

情况1解决方案：这是最为复杂的情况了。

1. 待删除的结点是红色，删就完事了，不会影响到红黑树平衡。
   ![删除结点是红色](http://cdn.lehanbal.top/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%E6%98%AF%E7%BA%A2%E8%89%B2.png)

2. 待删除的结点是黑色，它兄弟是黑色。

   2.1.它兄弟没有孩子，并且它们的爹是红色

   ![删除情况2.1](http://cdn.lehanbal.top/%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B52.1.png)

   2.2.它兄弟没有孩子，并且它们的爹是黑色

   ![删除情况2.2](http://cdn.lehanbal.top/%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B52.2.png)

   ​		这种情况需要注意，因为我们删除了一个黑色节点，所以这种情况该路线不会平衡，我们就需要对父节点进行递归操作处理，重新判断各种情况。

   2.3.它兄弟只有一个红色左孩子

   ​		红色节点不会影响红黑树的性质。从下图看出，父亲结点被拖去左边抵儿子的债了。
   ![删除结点情况2.3](http://cdn.lehanbal.top/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%E6%83%85%E5%86%B52.3.png)

   2.4.它兄弟只有一个红色右孩子

   ​		和2.3的情况十分相似，都是子债父偿，但是2.3情况下当家作主的是侄子结点，在2.4情况下它兄弟当家做主了。

   ![删除结点情况2.4](http://cdn.lehanbal.top/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%E6%83%85%E5%86%B52.4.png)

3. 待删除的结点是黑色，兄弟结点是红色（该情况下红色肯定是带着两个红色孩子，不然树不会平衡）
   ![删除结点情况3](http://cdn.lehanbal.top/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%E6%83%85%E5%86%B53.png)

这就是全部的红黑树删除情况，剩下的右情况镜像处理即可。

## 灵魂拷问

### jdk 1.8 HashMap 中有使用到红黑树，你知道触发条件是什么吗？有读过源码是如何 put 和 remove 的吗？

红黑树插入为O(lgn),查询为O(lgn)，链表插入为O(1)，查询为O(n)。个数少时，插入删除成本高，用链表；个数多时，查询成本高，用红黑树。需要定一个值，比这个值大就转红黑树，比这个值小就转链表，而且要避免频繁的转换。根据泊松分布，在负载因子0.75（HashMap默认）的情况下，单个hash槽内元素个数为8的概率小于百万分之一，将7作为一个分水岭，等于7时不做转换，大于等于8才转红黑树，小于等于6才转链表。

触发转化的两个条件是：一个是链表的长度达到8个，一个是数组的长度达到64个。

put源码

```java
    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
```

putVal源码

```java
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node<K,V>[] tab; Node<K,V> p; int n, i;//定义一个临时链表数组，对hashmap中的table进行操作，n是table的长度，为hashmap初始化时定义的值，是2的幂，i为tab的游标
        if ((tab = table) == null || (n = tab.length) == 0)//如果这个hashmap是空的
            n = (tab = resize()).length;//就resize一下这个hashmap，获取容量（16）
        if ((p = tab[i = (n - 1) & hash]) == null)//这行代码的意思是获取tab链表数组中的第length个链表，如果链表为空，就创建新节点添加进去，它的nextnode为null
            tab[i] = newNode(hash, key, value, null);
        else {
            Node<K,V> e; K k;
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))//如果hash相同，键相同，就直接把p指向e
                e = p;
            else if (p instanceof TreeNode)//如果已经是红黑树了就执行红黑树的添加操作
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {//链表数组中如果不出现hash碰撞，最完美的情况应该是每个链表都是单结点，这里统计链表中节点的个数
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        //TREEIFY_THRESHOLD = 8；判断当前链表长度，如果大于8就把链表转化为红黑树
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);//把这个链表转化成红黑树，然后直接退出循环
                        break;
                    }
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))//在结点遍历的过程中，如果有hash值相同的情况，且key值相同，就直接退出循环，把这个找到的结点直接赋值
                        break;
                    p = e;//每次都指向下一个结点
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)//根据参数onlyIfAbsent决定是否覆盖
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;返回的是e.value的指向
            }
        }
        ++modCount;//操作数+1
        if (++size > threshold)//如果链表数组大小大于了阈值，就扩容
            resize();
        afterNodeInsertion(evict);
        return null;
    }

```

通过hash计算要填记得key准备插入的位置，如果key一样就看参数是否决定覆盖，如果是空的就执行插入方法，如果对应的位置有值就判断是红黑树结构还是链表结构，如果是链表结构的话就顺着链表寻找，找到一样的key就跟参数选择覆盖，没找到的话就放在链表的最后面，链表长度大于8的话就进行红黑树化，如果是红黑树结构就按照书的添加方式进行添加。

treeifyBin源码

```java
    final void treeifyBin(Node<K,V>[] tab, int hash) {
        int n, index; Node<K,V> e;
        //MIN_TREEIFY_CAPACITY = 64,这里是重点，如果table小于64，那么是走的扩容resize的方法，超过这个数字，才会走到else的TreeNode的构建
        if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)
            resize();
        else if ((e = tab[index = (n - 1) & hash]) != null) {
            TreeNode<K,V> hd = null, tl = null;
            do {
                TreeNode<K,V> p = replacementTreeNode(e, null);
                if (tl == null)
                    hd = p;
                else {
                    p.prev = tl;
                    tl.next = p;
                }
                tl = p;
            } while ((e = e.next) != null);
            if ((tab[index] = hd) != null)
                hd.treeify(tab);
        }
    }
```

remove源码

```java
    public V remove(Object key) {
        Node<K,V> e;
        return (e = removeNode(hash(key), key, null, false, true)) == null ?
            null : e.value;
    }
```

removeNode源码

```java
    final Node<K,V> removeNode(int hash, Object key, Object value,
                               boolean matchValue, boolean movable) {
        Node<K,V>[] tab; Node<K,V> p; int n, index;// 定义节点数组tab用于指向table、节点p、数组长度n、hash所映射的数组下标
        if ((tab = table) != null && (n = tab.length) > 0 &&
            (p = tab[index = (n - 1) & hash]) != null) {// 节点数组在hash位置处的节点不为空,若为空则直接返回null(不存在可删除元素)
            Node<K,V> node = null, e; K k; V v;// 定义局部节点变量node存储需要删除的元素、循环变量e、key、value
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))// 头结点即为需要删除的节点
                node = p;
            else if ((e = p.next) != null) {// 链表还存在其他元素,并将e指向头结点的后继元
                if (p instanceof TreeNode)// 该链表是一个红黑树结构
                    node = ((TreeNode<K,V>)p).getTreeNode(hash, key);// 在红黑树中查询指定hash、key的节点并返回
                else {// 链表是一个单项链表
                    do {
                        if (e.hash == hash &&
                            ((k = e.key) == key ||
                             (key != null && key.equals(k)))) {
                            node = e;// 节点e时需要移除的节点,结束循环
                            break;
                        }
                        p = e;// 循环结束时,节点p为目标节点的前驱元
                    } while ((e = e.next) != null);
                }
            }
            if (node != null && (!matchValue || (v = node.value) == value ||
                                 (value != null && value.equals(v)))) {// 存在需要移除的节点且值匹配删除为false或者不为false且值匹配
                if (node instanceof TreeNode)// node为树形节点,使用treeNode的移除方法
                    ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);
                else if (node == p)// 若node为头结点,直接将node 的后继元作为新的头结点
                    tab[index] = node.next;
                else
                    p.next = node.next;// 链表下移除节点且不为头结点,此时将目标节点的前驱元的后继元指向目标节点的后继元
                ++modCount;
                --size;
                afterNodeRemoval(node);
                return node;
            }
        }
        return null;
    }
```

下面是红黑树退成链表的源码，不解读了，在hashMap中的元素小于6的时候会从红黑树退成链表，选择6是为了防止在刚刚转化成红黑树后出现频繁地增加与删除操作导致查询效率低下，所以中间设置缓冲。

```java
        final void removeTreeNode(HashMap<K,V> map, Node<K,V>[] tab,
                                  boolean movable) {
            int n;
            if (tab == null || (n = tab.length) == 0)
                return;
            int index = (n - 1) & hash;
            TreeNode<K,V> first = (TreeNode<K,V>)tab[index], root = first, rl;
            TreeNode<K,V> succ = (TreeNode<K,V>)next, pred = prev;
            if (pred == null)
                tab[index] = first = succ;
            else
                pred.next = succ;
            if (succ != null)
                succ.prev = pred;
            if (first == null)
                return;
            if (root.parent != null)
                root = root.root();
            if (root == null
                || (movable
                    && (root.right == null
                        || (rl = root.left) == null
                        || rl.left == null))) {
                tab[index] = first.untreeify(map);  // too small
                return;
            }
            TreeNode<K,V> p = this, pl = left, pr = right, replacement;
            if (pl != null && pr != null) {
                TreeNode<K,V> s = pr, sl;
                while ((sl = s.left) != null) // find successor
                    s = sl;
                boolean c = s.red; s.red = p.red; p.red = c; // swap colors
                TreeNode<K,V> sr = s.right;
                TreeNode<K,V> pp = p.parent;
                if (s == pr) { // p was s's direct parent
                    p.parent = s;
                    s.right = p;
                }
                else {
                    TreeNode<K,V> sp = s.parent;
                    if ((p.parent = sp) != null) {
                        if (s == sp.left)
                            sp.left = p;
                        else
                            sp.right = p;
                    }
                    if ((s.right = pr) != null)
                        pr.parent = s;
                }
                p.left = null;
                if ((p.right = sr) != null)
                    sr.parent = p;
                if ((s.left = pl) != null)
                    pl.parent = s;
                if ((s.parent = pp) == null)
                    root = s;
                else if (p == pp.left)
                    pp.left = s;
                else
                    pp.right = s;
                if (sr != null)
                    replacement = sr;
                else
                    replacement = p;
            }
            else if (pl != null)
                replacement = pl;
            else if (pr != null)
                replacement = pr;
            else
                replacement = p;
            if (replacement != p) {
                TreeNode<K,V> pp = replacement.parent = p.parent;
                if (pp == null)
                    (root = replacement).red = false;
                else if (p == pp.left)
                    pp.left = replacement;
                else
                    pp.right = replacement;
                p.left = p.right = p.parent = null;
            }

            TreeNode<K,V> r = p.red ? root : balanceDeletion(root, replacement);

            if (replacement == p) {  // detach
                TreeNode<K,V> pp = p.parent;
                p.parent = null;
                if (pp != null) {
                    if (p == pp.left)
                        pp.left = null;
                    else if (p == pp.right)
                        pp.right = null;
                }
            }
            if (movable)
                moveRootToFront(tab, r);
        }
```



### 哪些场景可以应用红黑树？

map和set都是用红黑树实现的。它可以在O(log n)时间内做查找，插入和删除等操作。

著名的linux进程调度**Completely Fair Scheduler**,用红黑树管理**进程控制块。**

**epoll**在内核中的实现，用红黑树管理事件块

**nginx**中，用红黑树管理timer等

Java的**TreeMap**实现

### 你了解各种树的时间复杂度吗？

**二叉树**：

​		查找时间复杂度：最好：![O(lgn)](https://math.jianshu.com/math?formula=O(lgn)),最差![O(n)](https://math.jianshu.com/math?formula=O(n))。最差情况是所有的数据全部在一端时。

**二叉搜索树（二叉排序树、二叉查找树）：**

​		查找时间复杂度：最好：![O(lgn)](https://math.jianshu.com/math?formula=O(lgn)),最差![O(n)](https://math.jianshu.com/math?formula=O(n))。最差情况是所有的数据全部在一端时。

**平衡二叉树：**

​		查找时间复杂度：![O(lgn)](https://math.jianshu.com/math?formula=O(lgn))

**红黑树：**

​		查找删除插入时间复杂度：![O(lgn)](https://math.jianshu.com/math?formula=O(lgn))

**B-树、B+树**

​		查找时间复杂度：![O(lgn)](https://math.jianshu.com/math?formula=O(lgn))