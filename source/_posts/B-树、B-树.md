---
title: B-树、B+树
date: 2020-10-29 14:32:31
tags:
- 数据结构
categories:
- 数据结构
---

**B-树的“-”是不发音的！**

## 先看2-3树

本质上，2-3树是一颗最简单的B-树，其每个非叶节点都有两个或三个子女，而且所有叶都在统一层上。2-3树不是二叉树，其节点可拥有3个孩子。不过，2-3树与满二叉树相似。高为h的2-3树包含的节点数大于等于高度为h的满二叉树的节点数，即至少有2^h-1个节点。

说人话，2-3树就是比满二叉树的节点多。

先别看规则，向上个图，感受一下。

![2-3树](http://cdn.lehanbal.top/2-3%E6%A0%91.png)

2-3的节点规则：

1. 2-节点有两个孩子，必含一个数据项，其查找关键字大于左孩子的查 找关键字，而小于右孩子的查找关键字。
2. 3-节点有三个孩子 ，必含两个数据项，其查找关键字S和L满足下列关系：S大于左孩子的查找关键字，而小于中孩子的查找关键字；L大于中孩子的查找关键字，而小于右孩子的查找关键字。
3. 叶子可以包含一个或两个数据项。

对着图读一遍规则，这样就能更快一点理解这是个啥东西。

### 2-3树查找元素

在上面的定义中，我们可以知道2-3树是根据元素的大小来决定查找的方向的。要找到我们需要的元素，我们就需要将元素和当前的节点进行比较，其实和二叉搜索树的查找的方式很相似，只不过这里不是二叉树罢了。我直接上个案例来说明整个查找情况。

![2-3树查找1](https://gitee.com/lehanbal/blog-image/raw/master/img/2-3树查找1.png)

### 2-3树插入元素

插入元素就显得略为复杂，主要分为以下四种情况，当然如果是空树的话直接创建一个节点即可。

1. 向一颗2-节点插入元素

   如果未命中元素，并且是在2-节点结束的，那就把当前的2-节点变成3-节点，并且把插入的元素加进去即可。

   ![2-3树插入情况1](http://cdn.lehanbal.top/2-3%E6%A0%91%E6%8F%92%E5%85%A5%E6%83%85%E5%86%B51.png)

2. 向一个父节点是2-节点的3-节点插入元素

   将3-节点临时变成4-节点，然后将中间节点抽出分解成3个2-节点，将中间节点向上合并，完成插入操作。

   ![2-3树插入情况2](http://cdn.lehanbal.top/2-3%E6%A0%91%E6%8F%92%E5%85%A5%E6%83%85%E5%86%B52.png)

3. 向一个父节点是3-节点的3-节点插入元素

   插入元素的时候，先临时变成4-节点，然后把它分解了，将中间的元素向上合并，父节点继续变成4-节点，再分解，中间的元素再向上合并。知道遇到2-节点，把2-节点变成3-节点，此时便不再分解。**如果根节点分解了，那么树高+1**。

   ![2-3树插入情况3.1](http://cdn.lehanbal.top/2-3%E6%A0%91%E6%8F%92%E5%85%A5%E6%83%85%E5%86%B53.1.png)

![2-3树插入情况3.2](http://cdn.lehanbal.top/2-3%E6%A0%91%E6%8F%92%E5%85%A5%E6%83%85%E5%86%B53.2.png)

### 2-3树删除元素

删除元素的思路和二叉搜索树的删除情况类似，如果删除的是非叶子节点，都是通过将非叶子节点的后继节点代替它，然后转换成删除叶子节点的问题。

删除叶子节点有以下五种情况：

1. 删除的节点不是2-节点，这种情况可以直接删除，将3-节点删除其中一个元素使它转换成2-节点。

   ![2-3树删除情况1](http://cdn.lehanbal.top/2-3%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B51.png)

2. 删除的节点是2-节点，父节点是2-节点，兄弟节点是3-节点，这种时候删除节点后将父节点移动到被删除节点的位置然后将兄弟节点中最接近父节点的值移动到父节点的位置。（左旋）

   ![2-3树删除情况2](http://cdn.lehanbal.top/2-3%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B52.png)

3. 删除的节点是2-节点，兄弟节点也是2-节点，（不是满二叉树）这时候我们需要将父节点的父节点的直接后继拆分来顶替父节点的位置，然后父节点与兄弟节点结合从3-节点，进行左旋操作即可。

   ![2-3树删除情况3](http://cdn.lehanbal.top/2-3%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B53.png)

4. 删除的节点是2-节点，父节点是3-节点，那么我们需要将父节点拆成两个2-节点，然后将父节点中最接近的一个元素与孩子结合，合并成一个3-节点。

   ![2-3树删除情况4](http://cdn.lehanbal.top/2-3%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B54.png)

5. 删除的是一个满二叉树的叶子节点，这个时候，就开始降维打击了，将删除节点的兄弟节点与父节点结合成3-节点，父节点的所有兄弟节点合并到父节点的都节点中，如果生成4-节点，那就拆分4-节点即可。


## B-树

B-树全名 Balance Tree**读做B树(中间的-，只是分隔作用，不要读做B减树)。**

B树首先它也是属于树结构，除了树结构的节点有序、查找高效外，还有以下特性。以一个m阶的B树来举栗：

1. 根节点至少包含两个子节点；
2. 每个中间节点包括k-1个元素和k个子节点，其中m/2 <= k <= m
3. 每一个叶子节点包含k-1个元素，其中m/2 <= k <= m
4. 每个节点的元素从大到小有序，节点当中k-1个元素是k个子节点的值域的划分。

说人话，就是我们之前说的2-3树扩展，不过2-3树只不过是m=3的B-树罢了。

对应的，2-3-4树就是m=4的B-树。

查找、插入以及删除的概念在2-3树的时候已经完全介绍了，这里说明B-树有什么用，为什么数据库的索引会用到B-树。

### 二叉搜索树的查询速度都已经是logN了，B-树B+树会比这个效率还高吗？

答案是当然不会，它的查询方式就是基于二分查找，但是当磁盘的存储数据较大的时候，树的高度会变高。在进行索引的查询的时候，并不会把整个索引全部加载到内存，会逐一加载每个磁盘页面，当树变高的时候，会需要增加读取磁盘页的次数，相对的也就增加了查询时间。

所以我们需要一种数据结构，压缩这棵树的高度，这就是B-树，把树变得矮胖，在内存中比较数值的速度的性能和时间消耗远远小于磁盘IO的速度，所以通过压缩树的高度对于大批的数据检索来说，是优于二叉搜索树的。

### B-树主要作用在什么地方

B-树主要应用于文件系统以及部分数据库索引，非关系型数据库MongoDB的索引用的就是B-树结构。

## B+树

B+树是B-树的一种变形形式，B+树上的叶子结点存储关键字以及相应记录的地址，叶子结点以上各层作为索引使用。一棵m阶的B+树定义如下:

1. 中间元素不存数据，只是当索引用，所有数据都保存在叶子结点中。
2. 所有的中间节点在子节点中要么是最大的元素，要么是最小的元素 。
3. 叶子结点包含所有的数据，和指向这些元素的指针，而且叶子结点的元素形成了自小向大这样子的链表。

B+树的查找与B树不同，当索引部分某个结点的关键字与所查的关键字相等时，并不停止查找，应继续沿着这个关键字左边的指针向下，一直查到该关键字所在的叶子结点为止。

上个图，体会一下：

![B+树](http://cdn.lehanbal.top/B+%E6%A0%91.png)

因为B+树的非叶子节点并没有存储数据，所以一个磁盘页可以存储更多的数据，也就是说，B+树会比B-树更加矮胖，所以查询IO次数更少，查询速度也就更快。

B+树的叶子节点会形成一个链表，当我们需要查询下一个数据的时候，并不需要从头开始继续查找，而是顺着链表就能够摸到我们需要的数，更优的查询效率。

B+树的插入删除操作与B-树的操作大同小异，我不写了，感兴趣的自行百度。



### B+树的优势

1. 单一节点存储更多的元素，使得查询的IO次数更少。
2. 所有查询都要查找到叶子节点，查询性能稳定。
3. 所有叶子节点形成有序链表，便于范围查询。