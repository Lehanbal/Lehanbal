---
title: 计算机网络必杀题
date: 2020-10-29 14:21:32
tags:
- TCP
- UDP
- 计算机网络
categories: 
- 计算机网络
---

## 简单介绍一下TCP三次握手，为什么要三次握手

TCP报文中有两个重要的字段，一个是序号字段，一个是确认号字段，这两个字段在握手阶段以及整个信息传输过程中起到重要作用。

1、客户端TCP会向服务端TCP发送一个不带额外数据的特殊TCP报文段，该字段的SYN标志会被置1，所以把它称为SYN报文段。这时客户端会选取一个初始序列号（客户端的序列号），并将此编号放置到序号字段中。该报文会被封装在一个IP数据报中并发送给服务端。

2、服务端接收到SYN报文段后，会为该TCP连接分配缓存和变量，并发送允许连接的确认报文。在允许连接的确认报文中，SYN位依旧被置为1，序号字段中会存放服务端的序列号，确认号字段会填上客户端序列号+1的值。这个报文段被称为SYN/ACK报文段。

3、客户端在接收到SYN/ACK报文段后，客户端最后向服务端发送一个确认报文段，这个报文段的SYN标志位置0，在确认号上填上服务端序列号+1的值，并且这个报文段可以携带数据。

完成以上三步之后，服务端和客户端就可以互相发送数据了。

如果不是三次握手，而是两次的话，服务端就不知道客户端是否收到了自己的SYN/ACK报文段，从而无法确立连接，四次握手就会显得多余。

![三次握手](https://gitee.com/lehanbal/blog-image/raw/master/img/三次握手.png)

## SYN洪泛攻击和解决策略

什么是SYN洪泛攻击？在TCP三次握手机制的第一步中，客户端会向服务端发送SYN报文段。服务器接收到SYN报文段后为该TCP连接分配缓存和变量，如果攻击分子大量的往服务器发送SYN报文段，服务器就会不断地给这些TCP连接分配变量和缓存，最终服务器的资源会被耗尽，导致内存溢出而无法正常服务。

解决策略：SYN cookie：服务端在接收到客户端的SYN报文段时，不直接为该TCP分配资源，而是之打开一个半开的套接字。接着会使用SYN报文段的源id，目的id，端口号以及只有服务器自己知道的一个秘密函数生成一个cookie，并把cookie作为序列号相应给客户端。如果客户端是正常确认连接，就会返回一个确认字段为cookie + 1的报文段。接下来的服务器会根据确认报文的源id，目的id，端口号以及秘密函数计算出一个结果，如果这个结果的值+1等于确认字段的值，则证明是刚刚请求连接的客户端，这时才为该TCP分配资源。

当然也可以使用降低SYN timeout时间的策略，使得主机尽快释放半连接的占用。

## TCP四次挥手

当客户端要向服务端断开连接时，客户端TCP会向服务器发送一个特殊的报文段，该报文段的FIN位会被置1，接着服务器会向客户端发送一个确认报文（CLOSE_WAIT）。然后服务端也会像客户端发送一个FIN标志位为1的终止报文段，随后客户端回送一个确认报文段，服务器立即断开连接。客户端等待一段时间后（TIME_WAIT）也断开连接。

大致如上，接下来我一步一步讲：

1、TCP客户端向TCP服务端发送终止报文，FIN位和ACK位置1，（FIN等于1的报文段即使不携带数据也会消耗一个序号），seq的值是客户端之前已传送过的最后一个字节的序号+1，ack的值等于客户端之前已收到的最后一个字节的序号+1。（客户端告诉服务端，老子要断开连接了）

2、TCP服务端接收到该终止报文后，进入CLOSE_WAIT状态，会向客户端发送一个ACK确认报文，ACK位置1，ack为之前的终止报文的序列号+1，seq向客服端之前所发送的最后一个字节的序号+1，这与之前终止报文的ack的值一致。（服务端告诉客户端，老子晓得了）

3、TCP服务端再发送完ACK确认报文后，TCP服务器仍然可以继续发送服务端剩下的数据内容，直到没有数据要发送了，就会向客户端发送终止报文，FIN位、ACK位置1，seq为刚刚传输过去的最后一个字节的序列号+1，ack为对客户端的终止报文的序列号再一次确认。（服务端告诉客户端剩下没讲完的话，讲完剩下的话后就告诉客户端老子讲完话了，可以关了）

4、TCP客户端接收到这个终止报文后，会进入TIME_WAIT状态，会向服务端发送一个ACK确认报文，告诉服务器收到它的关闭报文。该报文ACK位置1，ack为服务端的终止报文序号+1，seq为客户端所发送的终止报文的seq+1（因为FIN报文会消耗一个序号）。当服务端收到这个ACK确认报文，服务端就会关闭连接，客户端会在TIME_WAIT这个状态等待2MSL的时长才会关闭连接。（客户端听到服务端的“可以关了”的话之后，告诉服务端，晓得了，然后服务端就关闭了连接，但是客户端需要等一段时间才能关闭，为了防止出现超时重传的情况）

![四次挥手](https://gitee.com/lehanbal/blog-image/raw/master/img/四次挥手.png)

### 为什么要有TIME_WAI状态

因为客户端需要确保服务端能够收到客户端最后发出去的ACK确认报文段，避免客户端过早进入关闭状态，服务端发送超时重传的状态，这个时候会占用服务器的资源。TIME_WAIT状态也能够确保本次TCP连接中全部的连接报文信息能够在本次连接中完全关闭，避免了新旧连接杂糅的问题。

### 大量CLOSE_WAIT状态是为什么

出现了大量的CLOSE_WAIT说明服务器一致向客户端发送终止报文而客户端并没有响应，说明客户端已经关闭了，但是客户端仍然在CLOSE_WAIT状态，也就是说资源没释放，那就需要检查那些资源释放的代码。

## 流量控制

TCP是全双工的，客户端和服务端都可以互相发送和接受数据，现在假设是单向的传输数据，接收方有一块接受缓存区，发送方发送数据过来的时候数据会缓存到接收缓存区中，上层应用会在缓存区中有数据的时候来取出数据使用。如果发送方一个劲的发送数据，而接收方的应用并没有及时的将缓存区中的数据取出，就会出现缓存溢出，造成数据丢失，为了解决这个问题，采用流量控制窗口。

假设程序独奏的最后的数据序号是lastByteRead，接收缓存区中接收到的最后一个数据序号是lastByteRcv，接收缓存区的大小为RcvSize，那么必须要满足有lastByteRcv - lastByteRead <= RcvSize才能保证不会出现缓存溢出的情况，所以我们的流量控制窗口就有Rcv = RcvSize - (lastByteRcv - lastByteRead)。因此只要在发送ACK确认报文的时候将流量控制窗口的大小（Rcv）发送给对方，对方就能直到接受方最多能接收多少数据，作为调整发送方的滑动窗口条件之一。

## 拥塞控制

拥塞控制则是考虑到网络环境的拥堵情况，动态的调整每次在网络中发包的数量，采用以下四种算法进行拥塞控制

- 慢开始
- 拥塞避免
- 快重传
- 快恢复

假设网络拥塞的阈值为x，慢开始则是将第一次发包的时候设置为1，若没出现拥塞状况，则将发包次数*2，直到一次发包的数量超过了阈值，就停止慢开始算法，使用拥塞避免算法，每次发包的数量+1，直到发生丢包。出现丢包后，认为发生了拥塞现象，那么就将拥塞阈值设置为丢包时的发包量/2，并且重新设置发包的数量为1。之后在开始慢开始算法。

上述的情况，出现丢包后，并不一定是网络拥塞情况，也有可能只是发送了一些网络状况导致对应的数据包丢失。接收方在接收到乱序的数据包后，会立即向发送方发送ACK报文，来告诉发送方并没有接受到指定顺序的数据报，这个ACK数据包会定时发送给发送方，当发送方接收到3个相同的ACK报文后，会立即重新传送一次接收方所缺失的数据报，避免因为超时重传而进入慢开始状态，造成网络吞吐量降低。在进入快重传后，会跟着进入快恢复状态，拥塞阈值变成当前发送的数据报的一半，并且发送数据包的数量变成拥塞阈值+3（因为前面3个ack报文在快重传后就离开了），继续进入拥塞避免状态。

拥塞窗口就是每次传送数据报的数量大小。

![拥塞控制窗口](https://gitee.com/lehanbal/blog-image/raw/master/img/拥塞控制窗口.png)

## TCP的滑动窗口

滑动窗口的图分为四部分，并不是说滑动窗口分为四部分，滑动窗口占其中的两个部分（2、3），第一部分是已经发送并且已经确认的数据，这一部分数据已经从滑动窗口中划出，第二部分是已经发送但是还不确定接收方是否收到数据，在等接收方的ACK报文来确认数据是否接收到，若收到了对应的ACK报文，会从对应的数据也会从滑动窗口中滑出，第三部分是即将发送的数据，这一部分数据在滑动窗口中在等待被发送出去，第四部分就是未被发送的数据且不在滑动窗口中，在等待进入滑动窗口。

滑动窗口起到一个限流的作用，滑动窗口的大小决定了当前TCP发包的速率。

滑动窗口的大小 = min(拥塞窗口，流量控制窗口)。

![滑动窗口](https://gitee.com/lehanbal/blog-image/raw/master/img/滑动窗口.png)

## HTTP与HTTPS

HTTP协议是运行在TCP之上，具有明文传输，服务端与客户端都无法验证对方身份的缺点。HTTPS则是身披SSL（Secure Socket Layer）外壳的HTTP，运行在SSL之上，让SSL与TCP进行通信，添加了加密和认证机制的HTTP。二者之间存在以下不同：

1. 端口不同，HTTP与HTTPS使用不同的连接，用得端口也不一样，一个是80端口一个是443端口。
2. 资源消耗不同，HTTPS通信需要进行加减密处理，消耗更多的CPU和内存资源
3. 资金开销：HTTPS通信需要证书，而证书一般需要向认证机构购买。

HTTPS的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。

## TCP与UDP

1. TCP是面向连接的，TCP需要经过三次握手，断开需要经过四次挥手。UDP是面向无连接的，随时可通信，只要设置了监听端口，就可随时监听UDP发送的数据包。
2. TCP对数据发送的速率是有限制的，通过滑动窗口控制网络发包速率，取决于拥塞控制窗口和流量控制窗口的大小。而UDP理论上可以无限地向网络发送数据包，它的发包速率取决于应用程序地设置。
3. TCP保证可靠的数据传输，根据速率控制，重传控制还有数据效验提供可靠的数据传输服务。而UDP只是尽力保证数据传输，并不保证数据的可靠性。
4. TCP头部报文有20字节，而UDP头部字节有8字节，消耗的资源更多。并且TCP建立连接的时候，存在握手机制，使得TCP的使用效率比UDP要低一些。

## 在地址栏键入 URL 后，网络世界发生了什么？

1. 浏览器输入URL之后，DNS会解析当前的域名获取对应的IP地址：具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存，读取本地的Host文件和先本地DNS服务器进行查询等。对于本地DNS服务器进行查询，如果要查询的域名包含在本机配置区域资源中，就将解析结果返回给客户机，完成域名解析；如果查询的域名不由本地的DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析；如果本地域名服务器未缓存该网址映射关系，那么将根据其设置发起递归查询。
2. 浏览器获取域名对应的IP地址后，浏览器向服务器请求连接，发起三次握手。
3. TCP/IP连接建立后，浏览器向服务器发送HTTP请求。
4. 服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器。
5. 浏览器解析并渲染视图，若遇到对js文件、css文件以及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源。
6. 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。

## HTTP的常见状态码有哪些，代表什么含义？

HTTP请求结构： 请求方式 + 请求URI + 协议及其版本
　　HTTP响应结构： 状态码 + 原因短语 + 协议及其版本

1xx：请求处理中，请求已被接受，正在处理

----

2xx：请求成功，请求被成功处理

200 OK

----

3xx：重定向，要完成请求必须进一步处理

301 永久性转移

302 暂时性转移

304 已缓存

----

4xx：客户端错误，请求不合法

400 Bad Request，请求有语法问题

401 认证失败

403 拒绝请求

404 所访问的页面不存在

----

5xx：服务器错误，服务器不能处理合法请求

500 服务器内部错误

503 服务器正忙，稍等

## GET 请求和 POST 请求的区别

1. 从功能上讲，GET是从服务器获取数据，POST是更新服务器上的资源。
2. 从REST服务角度上说，GET是幂等的，即读取同一个资源，获取到的是相等的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的，也就是说GET不会改变服务器上的资源，而POST会对服务器资源进行改变。
3. POST安全性比GET高一些，因为POST请求会把参数包装到请求体中，而GET会将参数以明文的方式放在URL中。
4. GET请求的长度受限于浏览器或服务器对URL的长度限制，允许发送的数据量比较小，而POST请求没有大小限制。

## 什么是 Cookie，Cookie 的使用过程是怎么样的？

因为HTTP协议是无状态协议，不能够保存用户的访问状态，也就不能够跟踪应用的操作。所以cookie是浏览器的一种缓存机制，它可用于维持客户端和服务端之间的会话。cookie会将会话内容保存在**客户端**。

使用过程：

1. 用户在客户端浏览器向服务器发起登录请求。
2. 登陆成功后，服务端会把登录的用户信息保存在cookie中，返回给客户端浏览器。
3. 客户端浏览器接收到cookie之后，一般会将cookie保存到本地。
4. 下次再访问该web应用的时候，客户端浏览器会带上本地的cookie，服务器就能根据cookie获得用户信息。

## 什么是 session，有哪些实现 session 的机制？

session也是一种维持客户端和服务端的会话机制。但是cookie是将信息内容保存在客户端，而session则是将信息内容保存在服务端。

使用过程如下：

1. 用户在客户端浏览器发起请求。
2. 登陆成功后，服务端会把用户信息保存在服务端，并返回一个唯一的session表示给客户端浏览器。
3. 客户端浏览器将这个唯一的session标识起来。
4. 下次再访问该web应用时，客户端浏览器会将这个唯一的sessionID带上，这样服务器就能根据这个sessionID获取到对应的用户信息。

session是一种会话机制，在许多的web应用中，session就是用过cookie实现的。它只是使用了cookie功能，并不是说它使用cookie完成会话。

## session 和 cookie 有什么区别

1. cookie是浏览器提供的一种缓存机制，它可以维持客户端和服务端的会话。
2. session指的是维持客户端客户端与服务端会话的一种机制，它可以通过cookie实现，也可以通过别的手段实现。
3. 如果使用cookie实现会话，那么用户信息会存储在客户端浏览器中。
4. 如果使用session实现会话，用户信息会存储在服务端。
5. session存储敏感信息会比cookie安全。

