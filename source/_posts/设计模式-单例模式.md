title: JAVA设计模式-单例模式
author: Lehanbal
tags:
  - JAVA
  - 设计模式
categories:
  - 设计模式
date: 2021-06-05 19:05:00
---
项目源码在我的github上：[Lehanbal/DesignPatternRecord (github.com)](https://github.com/Lehanbal/DesignPatternRecord),有需要的话可以去clone一份

单例模式大致上可以分为饿汉式和懒汉式。

饿汉式：上来先在单例中new一个对象，很直白，但是出现的问题就是如果整个流程下来哦度没有使用这个单例实例，就会造成资源的浪费。

懒汉式：等你需要的时候我再去new这个对象，这一操作可以避免出现饿汉式的缺点，但是需要额外去考虑线程同步问题。

## 饿汉式

饿汉式可以用，但是不推荐，都是为了避免造成资源浪费。

### 静态变量的方式

```java
/**
 * 静态变量的俄汉式
 * 优点：
 *  写法简单，在类进行加载的时候就已经完成了单例的创建，减少了线程同步问题
 * 缺点：
 *  也是因为在类加载的时候就已经完成了创建，没有达成lazy loading的效果，如果该类从头到尾没用过，就造成了内存浪费
 */
class Singleton {

    //私有构造器，不能通过new来创建该单例对象
    private Singleton(){

    }

    //既然不能通过new来创建这个对象，那么在该类进行加载的时候就创建一个该单例
    private static final Singleton instance = new Singleton();

    //创建了该对象，对外提供一个公共的获取该类对象的方法即可。
    public static Singleton getInstance(){
        return instance;
    }
}
```

### 静态代码块的方式

```java
/**
 * 优缺点与静态常量的方式一样，不过这种方法是将实例化过程放在了静态代码块之中
 */
class Singleton {
    private Singleton() {
    }

    private static Singleton instance;

    //使用静态代码块进行实例化，此处在类加载的时候就开始将该类装进内存了
    static {
        instance = new Singleton();
    }

    public static Singleton getInstance() {
        return instance;
    }
}
```

## 懒汉式

### 线程不安全的方式

没有考虑同步的话，很可能会导致产生很多个实例对象，为此需要考虑synchronized等同步情况。

```java
/**
 * 懒汉式，需要用到的时候才会去创建，但是线程不安全，当多个线程一起执行到if判断内时，就会产生多个实例，并不能保证单例
 */
class Singleton{
    private Singleton(){};

    private static Singleton instance;

    public static Singleton getInstance(){
        if(instance == null){
            instance = new Singleton();
        }
        return instance;
    }
}
```

### 线程安全的方式

考虑了线程同步，但是同步就会带来效率问题，getInstance()在程序中会经常使用到，所以这一种方式会导致效率较低。

```java
/**
 * 懒汉式，需要用到的时候才会去创建，但是线程安全，使用synchronize关键字保证线程同步，但是这带来了效率问题，
 * 每次去getInstance的时候都会进行一次线程同步，而且getInstance这件事情是经常发生的
 */
class Singleton {
    private Singleton() {
    }

    private static Singleton instance;

    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

### 双重检查方式（double check）

推荐使用的方案之一。只有一开始的单例对象实例化需要开始同步，之后的getInstance()都不需要进入同步流程。

```java
/**
 * double check单例。双重检查，挺好的，建议开发中使用
 */
class Singleton {
    private Singleton() {
    }
    //volatile防止指令重排
    private static volatile Singleton instance;

    public static Singleton getInstance(){
        //此处进行第一次判断，当拥有实例之后就不会再进行同步代码块的判定了，也就避免了效率问题
        if(instance == null){
            synchronized (Singleton.class){
                //同步代码之后再进行一次判断，如果为空就创建一个实例。
                if (instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

### 静态内部类

值得推荐的方式之一，利用jvm的类转载机制，内部静态类在外部类被装载的时候是不会被转载的，当使用到内部类的资源的时候，内部类才会被装载。

```java
/**
 * 使用静态内部类的方式进行的单例，该方法也值得推荐
 * jvm的类转载机制：
 *      当外部类被转载的时候，内部类并不会被转载
 *      当使用到内部类的内容的时候，内部类会被转载并且只会被装载1次，所以也解决的线程同步的问题
 */
class Singleton {
    private Singleton() {

    }

    private static class SingletonInstance{
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance(){
        return SingletonInstance.INSTANCE;
    }
}
```

## 枚举方式

值得被推荐的一种方式。比较特殊的一种单例实现，使用枚举的防止进行单例模式。

```java
/**
 * 简单粗暴的枚举单例，也是值得推荐使用
 * 能够解决线程问题
 * 能防止反序列化
 */
enum Singleton {
    INSTANCE;

    public void func1() {
        System.out.println("hello");
    }
}

/**
 * 使用的时候如下
 */
public class Enum_Singleton {
    public static void main(String[] args) {
        Singleton type1 = Singleton.INSTANCE;
        Singleton type2 = Singleton.INSTANCE;

        System.out.println(type1 == type2);
        System.out.println(type1.hashCode());
        System.out.println(type2.hashCode());

        type1.func1();
    }
}
```