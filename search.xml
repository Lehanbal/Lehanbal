<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Ubuntu环境搭建</title>
    <url>/2022/07/26/Ubuntu%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="ubuntu环境搭建"><a href="#ubuntu环境搭建" class="headerlink" title="ubuntu环境搭建"></a>ubuntu环境搭建</h1><ol>
<li>在<a href="https://releases.ubuntu.com/">Ubuntu Releases</a>中选择想要的版本，我选择了22.04的server版本，不需要图形界面。</li>
<li>刻录启动盘，推荐使用ventoy。</li>
<li>进入服务器引导启动安装系统</li>
</ol>
<h1 id="镜像源"><a href="#镜像源" class="headerlink" title="镜像源"></a>镜像源</h1><p>位置在</p>
<p><code> /etc/apt/sources.list</code> </p>
<p>更改好源之后需要执行命令更新源内容</p>
<p><code>sudo apt update</code></p>
<p><code>sudo apt upgrade</code></p>
<h2 id="aliyun"><a href="#aliyun" class="headerlink" title="aliyun"></a>aliyun</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"><span class="comment"># deb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Pre-released source, not recommended.</span></span><br><span class="line"><span class="comment"># deb http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure>

<h2 id="清华源"><a href="#清华源" class="headerlink" title="清华源"></a>清华源</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Pre-released source, not recommended.</span></span><br><span class="line"><span class="comment"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure>

<h2 id="中科大"><a href="#中科大" class="headerlink" title="中科大"></a>中科大</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ jammy main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"><span class="comment"># deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Pre-released source, not recommended.</span></span><br><span class="line"><span class="comment"># deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure>

<h2 id="网易163"><a href="#网易163" class="headerlink" title="网易163"></a>网易163</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.163.com/ubuntu/ jammy main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"><span class="comment"># deb-src http://mirrors.163.com/ubuntu/ jammy main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src http://mirrors.163.com/ubuntu/ jammy-security main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src http://mirrors.163.com/ubuntu/ jammy-updates main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src http://mirrors.163.com/ubuntu/ jammy-backports main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Pre-released source, not recommended.</span></span><br><span class="line"><span class="comment"># deb http://mirrors.163.com/ubuntu/ jammy-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src http://mirrors.163.com/ubuntu/ jammy-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure>

<h1 id="配置GIT"><a href="#配置GIT" class="headerlink" title="配置GIT"></a>配置GIT</h1><h2 id="基础配置信息"><a href="#基础配置信息" class="headerlink" title="基础配置信息"></a>基础配置信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name “username”</span><br><span class="line">$ git config --global user.email “useremail”</span><br></pre></td></tr></table></figure>

<h2 id="生成ssh-key"><a href="#生成ssh-key" class="headerlink" title="生成ssh key"></a>生成ssh key</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>一路回车</p>
<p>公钥生成路径在</p>
<p><code>~/.ssh/id_rsa.pub</code></p>
<p>把这串内容贴到github的key上</p>
<p>添加一下刚刚生成的ssh key</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>

<h1 id="常用软件配置"><a href="#常用软件配置" class="headerlink" title="常用软件配置"></a>常用软件配置</h1><h2 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h2><p>因为没有图形界面，所以vim的编辑成了首选。</p>
<ol>
<li><p>安装vim命令</p>
<p><code> sudo apt install vim</code></p>
</li>
<li><p>主题安装</p>
<p>vim ~/.vim/colors/monokai.vim</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot; Vim color file</span></span><br><span class="line"><span class="string">&quot;</span> Converted from Textmate theme Monokai using Coloration v0.3.2 (http://github.com/sickill/coloration)</span><br><span class="line"><span class="built_in">set</span> background=dark</span><br><span class="line">highlight clear</span><br><span class="line"><span class="keyword">if</span> exists(<span class="string">&quot;syntax_on&quot;</span>)</span><br><span class="line">  syntax reset</span><br><span class="line">endif</span><br><span class="line"><span class="built_in">set</span> t_Co=256</span><br><span class="line"><span class="built_in">let</span> g:colors_name = <span class="string">&quot;monokai&quot;</span></span><br><span class="line">hi Cursor ctermfg=235 ctermbg=231 cterm=NONE guifg=<span class="comment">#272822 guibg=#f8f8f0 gui=NONE</span></span><br><span class="line">hi Visual ctermfg=NONE ctermbg=59 cterm=NONE guifg=NONE guibg=<span class="comment">#49483e gui=NONE</span></span><br><span class="line">hi CursorLine ctermfg=NONE ctermbg=237 cterm=NONE guifg=NONE guibg=<span class="comment">#3c3d37 gui=NONE</span></span><br><span class="line">hi CursorColumn ctermfg=NONE ctermbg=237 cterm=NONE guifg=NONE guibg=<span class="comment">#3c3d37 gui=NONE</span></span><br><span class="line">hi ColorColumn ctermfg=NONE ctermbg=237 cterm=NONE guifg=NONE guibg=<span class="comment">#3c3d37 gui=NONE</span></span><br><span class="line">hi LineNr ctermfg=102 ctermbg=237 cterm=NONE guifg=<span class="comment">#90908a guibg=#3c3d37 gui=NONE</span></span><br><span class="line">hi VertSplit ctermfg=241 ctermbg=241 cterm=NONE guifg=<span class="comment">#64645e guibg=#64645e gui=NONE</span></span><br><span class="line">hi MatchParen ctermfg=197 ctermbg=NONE cterm=underline guifg=<span class="comment">#f92672 guibg=NONE gui=underline</span></span><br><span class="line">hi StatusLine ctermfg=231 ctermbg=241 cterm=bold guifg=<span class="comment">#f8f8f2 guibg=#64645e gui=bold</span></span><br><span class="line">hi StatusLineNC ctermfg=231 ctermbg=241 cterm=NONE guifg=<span class="comment">#f8f8f2 guibg=#64645e gui=NONE</span></span><br><span class="line">hi Pmenu ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE</span><br><span class="line">hi PmenuSel ctermfg=NONE ctermbg=59 cterm=NONE guifg=NONE guibg=<span class="comment">#49483e gui=NONE</span></span><br><span class="line">hi IncSearch term=reverse cterm=reverse ctermfg=193 ctermbg=16 gui=reverse guifg=<span class="comment">#C4BE89 guibg=#000000</span></span><br><span class="line">hi Search term=reverse cterm=NONE ctermfg=231 ctermbg=24 gui=NONE guifg=<span class="comment">#f8f8f2 guibg=#204a87</span></span><br><span class="line">hi Directory ctermfg=141 ctermbg=NONE cterm=NONE guifg=<span class="comment">#ae81ff guibg=NONE gui=NONE</span></span><br><span class="line">hi Folded ctermfg=242 ctermbg=235 cterm=NONE guifg=<span class="comment">#75715e guibg=#272822 gui=NONE</span></span><br><span class="line">hi SignColumn ctermfg=NONE ctermbg=237 cterm=NONE guifg=NONE guibg=<span class="comment">#3c3d37 gui=NONE</span></span><br><span class="line">hi Normal ctermfg=231 ctermbg=235 cterm=NONE guifg=<span class="comment">#f8f8f2 guibg=#272822 gui=NONE</span></span><br><span class="line">hi Boolean ctermfg=141 ctermbg=NONE cterm=NONE guifg=<span class="comment">#ae81ff guibg=NONE gui=NONE</span></span><br><span class="line">hi Character ctermfg=141 ctermbg=NONE cterm=NONE guifg=<span class="comment">#ae81ff guibg=NONE gui=NONE</span></span><br><span class="line">hi Comment ctermfg=242 ctermbg=NONE cterm=NONE guifg=<span class="comment">#75715e guibg=NONE gui=NONE</span></span><br><span class="line">hi Conditional ctermfg=197 ctermbg=NONE cterm=NONE guifg=<span class="comment">#f92672 guibg=NONE gui=NONE</span></span><br><span class="line">hi Constant ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE</span><br><span class="line">hi Define ctermfg=197 ctermbg=NONE cterm=NONE guifg=<span class="comment">#f92672 guibg=NONE gui=NONE</span></span><br><span class="line">hi DiffAdd ctermfg=231 ctermbg=64 cterm=bold guifg=<span class="comment">#f8f8f2 guibg=#46830c gui=bold</span></span><br><span class="line">hi DiffDelete ctermfg=88 ctermbg=NONE cterm=NONE guifg=<span class="comment">#8b0807 guibg=NONE gui=NONE</span></span><br><span class="line">hi DiffChange ctermfg=NONE ctermbg=NONE cterm=NONE guifg=<span class="comment">#f8f8f2 guibg=#243955 gui=NONE</span></span><br><span class="line">hi DiffText ctermfg=231 ctermbg=24 cterm=bold guifg=<span class="comment">#f8f8f2 guibg=#204a87 gui=bold</span></span><br><span class="line">hi ErrorMsg ctermfg=231 ctermbg=197 cterm=NONE guifg=<span class="comment">#f8f8f0 guibg=#f92672 gui=NONE</span></span><br><span class="line">hi WarningMsg ctermfg=231 ctermbg=197 cterm=NONE guifg=<span class="comment">#f8f8f0 guibg=#f92672 gui=NONE</span></span><br><span class="line">hi Float ctermfg=141 ctermbg=NONE cterm=NONE guifg=<span class="comment">#ae81ff guibg=NONE gui=NONE</span></span><br><span class="line">hi Function ctermfg=148 ctermbg=NONE cterm=NONE guifg=<span class="comment">#a6e22e guibg=NONE gui=NONE</span></span><br><span class="line">hi Identifier ctermfg=81 ctermbg=NONE cterm=NONE guifg=<span class="comment">#66d9ef guibg=NONE gui=italic</span></span><br><span class="line">hi Keyword ctermfg=197 ctermbg=NONE cterm=NONE guifg=<span class="comment">#f92672 guibg=NONE gui=NONE</span></span><br><span class="line">hi Label ctermfg=186 ctermbg=NONE cterm=NONE guifg=<span class="comment">#e6db74 guibg=NONE gui=NONE</span></span><br><span class="line">hi NonText ctermfg=59 ctermbg=236 cterm=NONE guifg=<span class="comment">#49483e guibg=#31322c gui=NONE</span></span><br><span class="line">hi Number ctermfg=141 ctermbg=NONE cterm=NONE guifg=<span class="comment">#ae81ff guibg=NONE gui=NONE</span></span><br><span class="line">hi Operator ctermfg=197 ctermbg=NONE cterm=NONE guifg=<span class="comment">#f92672 guibg=NONE gui=NONE</span></span><br><span class="line">hi PreProc ctermfg=197 ctermbg=NONE cterm=NONE guifg=<span class="comment">#f92672 guibg=NONE gui=NONE</span></span><br><span class="line">hi Special ctermfg=231 ctermbg=NONE cterm=NONE guifg=<span class="comment">#f8f8f2 guibg=NONE gui=NONE</span></span><br><span class="line">hi SpecialComment ctermfg=242 ctermbg=NONE cterm=NONE guifg=<span class="comment">#75715e guibg=NONE gui=NONE</span></span><br><span class="line">hi SpecialKey ctermfg=59 ctermbg=237 cterm=NONE guifg=<span class="comment">#49483e guibg=#3c3d37 gui=NONE</span></span><br><span class="line">hi Statement ctermfg=197 ctermbg=NONE cterm=NONE guifg=<span class="comment">#f92672 guibg=NONE gui=NONE</span></span><br><span class="line">hi StorageClass ctermfg=81 ctermbg=NONE cterm=NONE guifg=<span class="comment">#66d9ef guibg=NONE gui=italic</span></span><br><span class="line">hi String ctermfg=186 ctermbg=NONE cterm=NONE guifg=<span class="comment">#e6db74 guibg=NONE gui=NONE</span></span><br><span class="line">hi Tag ctermfg=197 ctermbg=NONE cterm=NONE guifg=<span class="comment">#f92672 guibg=NONE gui=NONE</span></span><br><span class="line">hi Title ctermfg=231 ctermbg=NONE cterm=bold guifg=<span class="comment">#f8f8f2 guibg=NONE gui=bold</span></span><br><span class="line">hi Todo ctermfg=95 ctermbg=NONE cterm=inverse,bold guifg=<span class="comment">#75715e guibg=NONE gui=inverse,bold</span></span><br><span class="line">hi Type ctermfg=197 ctermbg=NONE cterm=NONE guifg=<span class="comment">#f92672 guibg=NONE gui=NONE</span></span><br><span class="line">hi Underlined ctermfg=NONE ctermbg=NONE cterm=underline guifg=NONE guibg=NONE gui=underline</span><br><span class="line">hi rubyClass ctermfg=197 ctermbg=NONE cterm=NONE guifg=<span class="comment">#f92672 guibg=NONE gui=NONE</span></span><br><span class="line">hi rubyFunction ctermfg=148 ctermbg=NONE cterm=NONE guifg=<span class="comment">#a6e22e guibg=NONE gui=NONE</span></span><br><span class="line">hi rubyInterpolationDelimiter ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE</span><br><span class="line">hi rubySymbol ctermfg=141 ctermbg=NONE cterm=NONE guifg=<span class="comment">#ae81ff guibg=NONE gui=NONE</span></span><br><span class="line">hi rubyConstant ctermfg=81 ctermbg=NONE cterm=NONE guifg=<span class="comment">#66d9ef guibg=NONE gui=italic</span></span><br><span class="line">hi rubyStringDelimiter ctermfg=186 ctermbg=NONE cterm=NONE guifg=<span class="comment">#e6db74 guibg=NONE gui=NONE</span></span><br><span class="line">hi rubyBlockParameter ctermfg=208 ctermbg=NONE cterm=NONE guifg=<span class="comment">#fd971f guibg=NONE gui=italic</span></span><br><span class="line">hi rubyInstanceVariable ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE</span><br><span class="line">hi rubyInclude ctermfg=197 ctermbg=NONE cterm=NONE guifg=<span class="comment">#f92672 guibg=NONE gui=NONE</span></span><br><span class="line">hi rubyGlobalVariable ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE</span><br><span class="line">hi rubyRegexp ctermfg=186 ctermbg=NONE cterm=NONE guifg=<span class="comment">#e6db74 guibg=NONE gui=NONE</span></span><br><span class="line">hi rubyRegexpDelimiter ctermfg=186 ctermbg=NONE cterm=NONE guifg=<span class="comment">#e6db74 guibg=NONE gui=NONE</span></span><br><span class="line">hi rubyEscape ctermfg=141 ctermbg=NONE cterm=NONE guifg=<span class="comment">#ae81ff guibg=NONE gui=NONE</span></span><br><span class="line">hi rubyControl ctermfg=197 ctermbg=NONE cterm=NONE guifg=<span class="comment">#f92672 guibg=NONE gui=NONE</span></span><br><span class="line">hi rubyClassVariable ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE</span><br><span class="line">hi rubyOperator ctermfg=197 ctermbg=NONE cterm=NONE guifg=<span class="comment">#f92672 guibg=NONE gui=NONE</span></span><br><span class="line">hi rubyException ctermfg=197 ctermbg=NONE cterm=NONE guifg=<span class="comment">#f92672 guibg=NONE gui=NONE</span></span><br><span class="line">hi rubyPseudoVariable ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE</span><br><span class="line">hi rubyRailsUserClass ctermfg=81 ctermbg=NONE cterm=NONE guifg=<span class="comment">#66d9ef guibg=NONE gui=italic</span></span><br><span class="line">hi rubyRailsARAssociationMethod ctermfg=81 ctermbg=NONE cterm=NONE guifg=<span class="comment">#66d9ef guibg=NONE gui=NONE</span></span><br><span class="line">hi rubyRailsARMethod ctermfg=81 ctermbg=NONE cterm=NONE guifg=<span class="comment">#66d9ef guibg=NONE gui=NONE</span></span><br><span class="line">hi rubyRailsRenderMethod ctermfg=81 ctermbg=NONE cterm=NONE guifg=<span class="comment">#66d9ef guibg=NONE gui=NONE</span></span><br><span class="line">hi rubyRailsMethod ctermfg=81 ctermbg=NONE cterm=NONE guifg=<span class="comment">#66d9ef guibg=NONE gui=NONE</span></span><br><span class="line">hi erubyDelimiter ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE</span><br><span class="line">hi erubyComment ctermfg=95 ctermbg=NONE cterm=NONE guifg=<span class="comment">#75715e guibg=NONE gui=NONE</span></span><br><span class="line">hi erubyRailsMethod ctermfg=81 ctermbg=NONE cterm=NONE guifg=<span class="comment">#66d9ef guibg=NONE gui=NONE</span></span><br><span class="line">hi htmlTag ctermfg=148 ctermbg=NONE cterm=NONE guifg=<span class="comment">#a6e22e guibg=NONE gui=NONE</span></span><br><span class="line">hi htmlEndTag ctermfg=148 ctermbg=NONE cterm=NONE guifg=<span class="comment">#a6e22e guibg=NONE gui=NONE</span></span><br><span class="line">hi htmlTagName ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE</span><br><span class="line">hi htmlArg ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE</span><br><span class="line">hi htmlSpecialChar ctermfg=141 ctermbg=NONE cterm=NONE guifg=<span class="comment">#ae81ff guibg=NONE gui=NONE</span></span><br><span class="line">hi javaScriptFunction ctermfg=81 ctermbg=NONE cterm=NONE guifg=<span class="comment">#66d9ef guibg=NONE gui=italic</span></span><br><span class="line">hi javaScriptRailsFunction ctermfg=81 ctermbg=NONE cterm=NONE guifg=<span class="comment">#66d9ef guibg=NONE gui=NONE</span></span><br><span class="line">hi javaScriptBraces ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE</span><br><span class="line">hi yamlKey ctermfg=197 ctermbg=NONE cterm=NONE guifg=<span class="comment">#f92672 guibg=NONE gui=NONE</span></span><br><span class="line">hi yamlAnchor ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE</span><br><span class="line">hi yamlAlias ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE</span><br><span class="line">hi yamlDocumentHeader ctermfg=186 ctermbg=NONE cterm=NONE guifg=<span class="comment">#e6db74 guibg=NONE gui=NONE</span></span><br><span class="line">hi cssURL ctermfg=208 ctermbg=NONE cterm=NONE guifg=<span class="comment">#fd971f guibg=NONE gui=italic</span></span><br><span class="line">hi cssFunctionName ctermfg=81 ctermbg=NONE cterm=NONE guifg=<span class="comment">#66d9ef guibg=NONE gui=NONE</span></span><br><span class="line">hi cssColor ctermfg=141 ctermbg=NONE cterm=NONE guifg=<span class="comment">#ae81ff guibg=NONE gui=NONE</span></span><br><span class="line">hi cssPseudoClassId ctermfg=148 ctermbg=NONE cterm=NONE guifg=<span class="comment">#a6e22e guibg=NONE gui=NONE</span></span><br><span class="line">hi cssClassName ctermfg=148 ctermbg=NONE cterm=NONE guifg=<span class="comment">#a6e22e guibg=NONE gui=NONE</span></span><br><span class="line">hi cssValueLength ctermfg=141 ctermbg=NONE cterm=NONE guifg=<span class="comment">#ae81ff guibg=NONE gui=NONE</span></span><br><span class="line">hi cssCommonAttr ctermfg=81 ctermbg=NONE cterm=NONE guifg=<span class="comment">#66d9ef guibg=NONE gui=NONE</span></span><br><span class="line">hi cssBraces ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装插件管理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fLo ~/.vim/<span class="built_in">autoload</span>/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置vimrc</p>
<p>vim ~/.vimrc</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;显示行号</span></span><br><span class="line"><span class="string">set nu</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>tab键宽度</span><br><span class="line"><span class="built_in">set</span> tabstop=4</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span>语法高亮</span><br><span class="line">syntax <span class="built_in">enable</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;主题颜色</span></span><br><span class="line"><span class="string">colorscheme monokai</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>NERDTree快捷键</span><br><span class="line">map &lt;C-n&gt; :NERDTreeToggle&lt;CR&gt;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;NERDTree剩下一个窗口时自动关闭</span></span><br><span class="line"><span class="string">autocmd bufenter * if (winnr(&quot;</span>$<span class="string">&quot;) == 1 &amp;&amp; exists(&quot;</span>b:NERDTree<span class="string">&quot;) &amp;&amp; b:NERDTree.isTabTree()) | q | endif</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>ctrlp配置</span><br><span class="line"><span class="built_in">set</span> runtimepath^=~/.vim/plugged/ctrlp.vim</span><br><span class="line">call plug<span class="comment">#begin(&#x27;~/.vim/plugged&#x27;)</span></span><br><span class="line">Plug <span class="string">&#x27;itchyny/lightline.vim&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;preservim/nerdtree&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;kien/ctrlp.vim&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;vim-airline/vim-airline&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;jiangmiao/auto-pairs&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;powerline/powerline&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;preservim/nerdcommenter&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;vim-scripts/a.vim&#x27;</span></span><br><span class="line">call plug<span class="comment">#end()</span></span><br><span class="line"></span><br><span class="line">map &lt;leader&gt;r :NERDTreeFind&lt;cr&gt;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;控制vim窗口分界线位置</span></span><br><span class="line"><span class="string">map &lt;F2&gt; &lt;ESC&gt;&lt;C-W&gt;-</span></span><br><span class="line"><span class="string">map &lt;F3&gt; &lt;ESC&gt;&lt;C-W&gt;+</span></span><br><span class="line"><span class="string">map &lt;F4&gt; &lt;ESC&gt;&lt;C-W&gt;&lt;</span></span><br><span class="line"><span class="string">map &lt;F5&gt; &lt;ESC&gt;&lt;C-W&gt;&gt;  </span></span><br></pre></td></tr></table></figure>

<p>键入<code>source ~/.vimrc</code></p>
<p>进入vim，键入:Pluginstall，待插件安装完毕</p>
</li>
</ol>
<h2 id="z-lua"><a href="#z-lua" class="headerlink" title="z.lua"></a>z.lua</h2><p>性能很棒的目录跳转工具</p>
<p><a href="https://github.com/skywind3000/z.lua">GitHub - skywind3000/z.lua: A new cd command that helps you navigate faster by learning your habits.</a></p>
<p>先安装lua</p>
<p><code>apt install lua5.3</code></p>
<p>之后再zshrc中配置该命令</p>
<p><code>eval &quot;$(lua /home/lehanbal/z.lua/z.lua  --init zsh once enhanced fzf)&quot;</code></p>
<p>相关的alias封装命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> zc=<span class="string">&#x27;z -c&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> zf=<span class="string">&#x27;z -I&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> zb=<span class="string">&#x27;z -b&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> zz=<span class="string">&#x27;z -i&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> zh=<span class="string">&#x27;z -I -t .&#x27;</span> </span><br></pre></td></tr></table></figure>

<p>具体请看zsh内容</p>
<h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><p>终端管理工具</p>
<p><code>apt install tmux</code></p>
<p>相关的alias命令封装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> tns=<span class="string">&#x27;tmux new-session -s &#x27;</span> <span class="comment">#创建一个session</span></span><br><span class="line"><span class="built_in">alias</span> tkss=<span class="string">&#x27;tmux kill-session -t &#x27;</span> <span class="comment">#杀掉一个session</span></span><br><span class="line"><span class="built_in">alias</span> ta=<span class="string">&#x27;tmux a -t &#x27;</span> <span class="comment">#进入一个session</span></span><br></pre></td></tr></table></figure>

<h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><p>配置ssh key，用密码连接不太安全</p>
<p>复制公钥到<code>~/.ssh/authorized_keys</code></p>
<p>赋权authorized_keys文件 <code>chmod 644 authorized_keys</code></p>
<p>也可以在已有sshkey的client上执行以下</p>
<p><code>ssh-copy-id -i ~/.ssh/id_rsa.pub user@ip</code>(-i 参数表示指定sshkey的位置)</p>
<p>修改sshd配置<code>vim /etc/ssh/sshd_config</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启密钥登入的认证方式</span></span><br><span class="line">PubkeyAuthentication yes </span><br><span class="line"><span class="comment"># 允许密码登录选项 yes为不禁用</span></span><br><span class="line">PasswordAuthentication yes</span><br></pre></td></tr></table></figure>

<p>修改完成后重启sshd服务</p>
<p><code>systemctl restart sshd</code></p>
<h2 id="ZSH"><a href="#ZSH" class="headerlink" title="ZSH"></a>ZSH</h2><ol>
<li><p>安装zsh和ohmyzsh</p>
<p><code>sudo apt install zsh</code></p>
<p><code>sh -c &quot;$(curl -fsSL https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh)&quot; </code></p>
</li>
<li><p>修改主题是能显示目录绝对路径</p>
<p><code>vim ~/.oh-my-zsh/themes/对应主题</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在PROMPT最后的地方加上</span><br><span class="line">PROMPT&#x3D;$&#123;PROMPT&#x2F;\%c&#x2F;\%~&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装插件</p>
<ol>
<li><p>zsh-autosuggestions</p>
<p><code>git clone https://gitee.com/phpxxo/zsh-autosuggestions.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</code></p>
</li>
<li><p>zsh-syntax-highlighting</p>
<p><code>git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</code></p>
</li>
<li><p>extract</p>
<p>自带，无需安装，加上即可</p>
</li>
<li><p>zsh-completions</p>
<p><code>  git clone https://github.com/zsh-users/zsh-completions $&#123;ZSH_CUSTOM:-$&#123;ZSH:-~/.oh-my-zsh&#125;/custom&#125;/plugins/zsh-completions</code></p>
</li>
</ol>
</li>
</ol>
<p>最后都需要在zshrc中的plugins=配置上对应的插件名字，请参考下文的zshrc配置文件</p>
<p>一切都修改完成后，请重新source配置文件</p>
<p><code>source ~/.zshrc</code></p>
<h3 id="zshrc"><a href="#zshrc" class="headerlink" title="zshrc"></a>zshrc</h3><p>以下为个人的zshrc文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># If you come from bash you might have to change your $PATH.</span></span><br><span class="line"><span class="comment"># export PATH=$HOME/bin:/usr/local/bin:$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Path to your oh-my-zsh installation.</span></span><br><span class="line"><span class="built_in">export</span> ZSH=<span class="string">&quot;<span class="variable">$HOME</span>/.oh-my-zsh&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set name of the theme to load --- if set to &quot;random&quot;, it will</span></span><br><span class="line"><span class="comment"># load a random theme each time oh-my-zsh is loaded, in which case,</span></span><br><span class="line"><span class="comment"># to know which specific one was loaded, run: echo $RANDOM_THEME</span></span><br><span class="line"><span class="comment"># See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes</span></span><br><span class="line">ZSH_THEME=<span class="string">&quot;af-magic&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set list of themes to pick from when loading at random</span></span><br><span class="line"><span class="comment"># Setting this variable when ZSH_THEME=random will cause zsh to load</span></span><br><span class="line"><span class="comment"># a theme from this variable instead of looking in $ZSH/themes/</span></span><br><span class="line"><span class="comment"># If set to an empty array, this variable will have no effect.</span></span><br><span class="line"><span class="comment"># ZSH_THEME_RANDOM_CANDIDATES=( &quot;robbyrussell&quot; &quot;agnoster&quot; )</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to use case-sensitive completion.</span></span><br><span class="line"><span class="comment"># CASE_SENSITIVE=&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to use hyphen-insensitive completion.</span></span><br><span class="line"><span class="comment"># Case-sensitive completion must be off. _ and - will be interchangeable.</span></span><br><span class="line"><span class="comment"># HYPHEN_INSENSITIVE=&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment one of the following lines to change the auto-update behavior</span></span><br><span class="line"><span class="comment"># zstyle &#x27;:omz:update&#x27; mode disabled  # disable automatic updates</span></span><br><span class="line"><span class="comment"># zstyle &#x27;:omz:update&#x27; mode auto      # update automatically without asking</span></span><br><span class="line"><span class="comment"># zstyle &#x27;:omz:update&#x27; mode reminder  # just remind me to update when it&#x27;s time</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to change how often to auto-update (in days).</span></span><br><span class="line"><span class="comment"># zstyle &#x27;:omz:update&#x27; frequency 13</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line if pasting URLs and other text is messed up.</span></span><br><span class="line"><span class="comment"># DISABLE_MAGIC_FUNCTIONS=&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to disable colors in ls.</span></span><br><span class="line"><span class="comment"># DISABLE_LS_COLORS=&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to disable auto-setting terminal title.</span></span><br><span class="line"><span class="comment"># DISABLE_AUTO_TITLE=&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to enable command auto-correction.</span></span><br><span class="line"><span class="comment"># ENABLE_CORRECTION=&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to display red dots whilst waiting for completion.</span></span><br><span class="line"><span class="comment"># You can also set it to another string to have that shown instead of the default red dots.</span></span><br><span class="line"><span class="comment"># e.g. COMPLETION_WAITING_DOTS=&quot;%F&#123;yellow&#125;waiting...%f&quot;</span></span><br><span class="line"><span class="comment"># Caution: this setting can cause issues with multiline prompts in zsh &lt; 5.7.1 (see #5765)</span></span><br><span class="line"><span class="comment"># COMPLETION_WAITING_DOTS=&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line if you want to disable marking untracked files</span></span><br><span class="line"><span class="comment"># under VCS as dirty. This makes repository status check for large repositories</span></span><br><span class="line"><span class="comment"># much, much faster.</span></span><br><span class="line"><span class="comment"># DISABLE_UNTRACKED_FILES_DIRTY=&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line if you want to change the command execution time</span></span><br><span class="line"><span class="comment"># stamp shown in the history command output.</span></span><br><span class="line"><span class="comment"># You can set one of the optional three formats:</span></span><br><span class="line"><span class="comment"># &quot;mm/dd/yyyy&quot;|&quot;dd.mm.yyyy&quot;|&quot;yyyy-mm-dd&quot;</span></span><br><span class="line"><span class="comment"># or set a custom format using the strftime function format specifications,</span></span><br><span class="line"><span class="comment"># see &#x27;man strftime&#x27; for details.</span></span><br><span class="line"><span class="comment"># HIST_STAMPS=&quot;mm/dd/yyyy&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Would you like to use another custom folder than $ZSH/custom?</span></span><br><span class="line"><span class="comment"># ZSH_CUSTOM=/path/to/new-custom-folder</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Which plugins would you like to load?</span></span><br><span class="line"><span class="comment"># Standard plugins can be found in $ZSH/plugins/</span></span><br><span class="line"><span class="comment"># Custom plugins may be added to $ZSH_CUSTOM/plugins/</span></span><br><span class="line"><span class="comment"># Example format: plugins=(rails git textmate ruby lighthouse)</span></span><br><span class="line"><span class="comment"># Add wisely, as too many plugins slow down shell startup.</span></span><br><span class="line">plugins=(</span><br><span class="line">	git</span><br><span class="line">	zsh-autosuggestions	</span><br><span class="line">	zsh-syntax-highlighting</span><br><span class="line">	extract</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(lua /home/lehanbal/z.lua/z.lua  --init zsh once enhanced fzf)</span>&quot;</span>    <span class="comment"># ZSH 初始化</span></span><br><span class="line"></span><br><span class="line">fpath+=<span class="variable">$&#123;ZSH_CUSTOM:-<span class="variable">$&#123;ZSH:-~/.oh-my-zsh&#125;</span>/custom&#125;</span>/plugins/zsh-completions/src</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH</span>/oh-my-zsh.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># User configuration</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># export MANPATH=&quot;/usr/local/man:$MANPATH&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You may need to manually set your language environment</span></span><br><span class="line"><span class="comment"># export LANG=en_US.UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Preferred editor for local and remote sessions</span></span><br><span class="line"><span class="comment"># if [[ -n $SSH_CONNECTION ]]; then</span></span><br><span class="line"><span class="comment">#   export EDITOR=&#x27;vim&#x27;</span></span><br><span class="line"><span class="comment"># else</span></span><br><span class="line"><span class="comment">#   export EDITOR=&#x27;mvim&#x27;</span></span><br><span class="line"><span class="comment"># fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Compilation flags</span></span><br><span class="line"><span class="comment"># export ARCHFLAGS=&quot;-arch x86_64&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set personal aliases, overriding those provided by oh-my-zsh libs,</span></span><br><span class="line"><span class="comment"># plugins, and themes. Aliases can be placed here, though oh-my-zsh</span></span><br><span class="line"><span class="comment"># users are encouraged to define aliases within the ZSH_CUSTOM folder.</span></span><br><span class="line"><span class="comment"># For a full list of active aliases, run `alias`.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Example aliases</span></span><br><span class="line"><span class="comment"># alias zshconfig=&quot;mate ~/.zshrc&quot;</span></span><br><span class="line"><span class="comment"># alias ohmyzsh=&quot;mate ~/.oh-my-zsh&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> zc=<span class="string">&#x27;z -c&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> zf=<span class="string">&#x27;z -I&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> zb=<span class="string">&#x27;z -b&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> zz=<span class="string">&#x27;z -i&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> zh=<span class="string">&#x27;z -I -t .&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> tns=<span class="string">&#x27;tmux new-session -s &#x27;</span></span><br><span class="line"><span class="built_in">alias</span> tkss=<span class="string">&#x27;tmux kill-session -t &#x27;</span></span><br><span class="line"><span class="built_in">alias</span> ta=<span class="string">&#x27;tmux a -t &#x27;</span></span><br></pre></td></tr></table></figure>



<h1 id="DDNS配置"><a href="#DDNS配置" class="headerlink" title="DDNS配置"></a>DDNS配置</h1><p>非管理员不需要配置</p>
<p><strong>该操作不支持IPV6</strong></p>
<p>该操作所需要准备</p>
<ol>
<li>TokenID</li>
<li>Token</li>
<li>域名ID</li>
<li>记录ID</li>
<li>子域名</li>
</ol>
<h2 id="Token与TokenID"><a href="#Token与TokenID" class="headerlink" title="Token与TokenID"></a>Token与TokenID</h2><p>登录<a href="https://console.dnspod.cn/account/token/token">阿里云API 密钥 </a>创建DNSPod Token密钥，即可拿到tokenID与token</p>
<p><img src="http://cdn.lehanbal.top/image-20220725232619036.png" alt="image-20220725232619036"></p>
<h2 id="域名ID"><a href="#域名ID" class="headerlink" title="域名ID"></a>域名ID</h2><p>登录<a href="https://console.dnspod.cn/dns/list">控制台</a>，点击域名设置后可以看到域名信息，其中的DomainID即是域名ID</p>
<p><img src="http://cdn.lehanbal.top/image-20220725232829788.png" alt="image-20220725232829788"></p>
<h2 id="记录ID"><a href="#记录ID" class="headerlink" title="记录ID"></a>记录ID</h2><p>通过<a href="https://console.dnspod.cn/dns/list">控制台</a>获取 在管理页面找到操作日志，“值”后面括号内数字为记录ID</p>
<p><img src="http://cdn.lehanbal.top/image-20220725233133580.png" alt="image-20220725233133580"></p>
<h2 id="子域名"><a href="#子域名" class="headerlink" title="子域名"></a>子域名</h2><p>子域名为你要修改的A记录的子域名，自己设定</p>
<p><img src="http://cdn.lehanbal.top/image-20220725233251748.png" alt="image-20220725233251748"></p>
<p>拿到以上信息后，就可以拼接出ddns的参数信息了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X POST https://dnsapi.cn/Record.Ddns -d <span class="string">&#x27;login_token=TokenID,Token&amp;domain_id=域名ID&amp;record_id=记录ID&amp;record_line=默认&amp;sub_domain=子域名&amp;lang=en&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="脚本定时操作"><a href="#脚本定时操作" class="headerlink" title="脚本定时操作"></a>脚本定时操作</h2><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><ol>
<li>将当前的ip记录在一个文件中</li>
<li>每隔一分钟检查一次当前ip与文件中的ip是否一直，若不一致则进行ddns操作</li>
</ol>
<h3 id="安装cron"><a href="#安装cron" class="headerlink" title="安装cron"></a>安装cron</h3><p><code>sudo apt install cron</code></p>
<p>开启cron服务</p>
<p><code>systemctl start cron</code></p>
<p>允许自启服务</p>
<p><code>systemctl enable cron</code></p>
<h3 id="脚本内容"><a href="#脚本内容" class="headerlink" title="脚本内容"></a>脚本内容</h3><p>首先创建/etc/shell/tmpddns文件，并赋予可读权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc</span><br><span class="line">sudo mkdir shell</span><br><span class="line">sudo touch tmpddns</span><br><span class="line">sudo chmod 777 tmpddns</span><br><span class="line"><span class="built_in">echo</span> -1 &gt; tmpddns</span><br></pre></td></tr></table></figure>

<p>创建脚本</p>
<p><code>touch ddns</code></p>
<p><code>sudo chmod +x ddns</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line">IP_PREV=$(cat /etc/shell/tmpddns)</span><br><span class="line">IP_NOW=$(curl -s ip.sb)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$IP_PREV</span> != <span class="variable">$IP_NOW</span> ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$IP_NOW</span> &gt; /etc/shell/tmpddns</span><br><span class="line">        curl -X POST https://dnsapi.cn/Record.Ddns -d <span class="string">&#x27;login_token=TokenID,Token&amp;domain_id=域名ID&amp;record_id=记录ID&amp;record_line=默认&amp;sub_domain=子域名&amp;lang=en&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h3 id="设定定时任务"><a href="#设定定时任务" class="headerlink" title="设定定时任务"></a>设定定时任务</h3><p><code>vim /etc/crontab</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*/1 * * * * root /etc/shell/ddns</span><br></pre></td></tr></table></figure>

<p>表示每一分钟都会使用root用户去执行/etc/shell/ddns脚本</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL-绘制第一个窗口</title>
    <url>/2022/04/13/OpenGL-%E7%BB%98%E5%88%B6%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<p>GLFW：配合 OpenGL 使用的轻量级工具程序库，缩写自 Graphics Library Framework（图形库框架）。</p>
<p>GLAD：对底层OpenGL接口的封装。</p>
<p>使用GLFW配合GLAD绘制的第一个窗口程序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEIGHT 800</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDTH 600</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processinput</span><span class="params">(GLFWwindow* window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">glfwInit</span>();</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);	<span class="comment">//主要版本号设置为3</span></span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);	<span class="comment">//次版本号设置为3</span></span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);	<span class="comment">//使用核心模式（core profile）</span></span><br><span class="line"></span><br><span class="line">	GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(HEIGHT, WIDTH, <span class="string">&quot;learnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">glfwTerminate</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将当前窗口的上下文切换为当前线程的上下文</span></span><br><span class="line">	<span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过GLAD初始化OpenGL的函数指针 注：调用OpenGL的函数前都需要初始化GLAD</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc) glfwGetProcAddress))</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//告诉opengl渲染窗口大小  glViewport函数前两个参数控制窗口左下角的位置。第三个和第四个参数控制渲染窗口的宽度和高度</span></span><br><span class="line">	<span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, WIDTH, HEIGHT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对窗口注册一个回调函数，在窗口大小被改变的时候调用</span></span><br><span class="line">	<span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//渲染循环，让这个图一直循环下去</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *  glfwWindowShouldClose函数在我们每次循环的开始前检查一次GLFW是否被要求退出，如果是的话该函数返回true然后渲染循环便结束了，之后为我们就可以关闭应用程序了。</span></span><br><span class="line"><span class="comment">	 *	glfwPollEvents函数检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数（可以通过回调方法手动设置）。</span></span><br><span class="line"><span class="comment">	 *	glfwSwapBuffers函数会交换颜色缓冲（它是一个储存着GLFW窗口每一个像素颜色值的大缓冲），它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">processinput</span>(window);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//中间插入渲染指令</span></span><br><span class="line">		<span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//下述两行代码可以理解为，设置清空颜色缓冲位后，使用glClearColor设置的rgba颜色填充颜色缓冲位</span></span><br><span class="line">		<span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">		<span class="comment">//清空颜色的缓冲位</span></span><br><span class="line">		<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">		<span class="built_in">glfwPollEvents</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放资源</span></span><br><span class="line">	<span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态调整viewport大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监控键盘输入，若是esc被摁下则通过glfwSetWindowShouldClose函数关闭窗口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processinput</span><span class="params">(GLFWwindow* window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>C++数据结构用法笔记</title>
    <url>/2022/03/26/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%94%A8%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组类型：</p>
<ol>
<li>数组</li>
<li>vector <a href="https://blog.csdn.net/qq_38289815/article/details/105896622">C++ vector 使用详解_Tyler_Zx的博客-CSDN博客_c++ vector</a></li>
</ol>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ol>
<li>数组</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//变量类型 变量名[数组大小]</span></span><br><span class="line"><span class="keyword">int</span> a[n];</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以直接进行初始化赋值，未进行赋值的都会使用0作为初始化</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;<span class="comment">//a[3] = 0</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>vector</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要引入头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;vector&quot;</span></span></span><br><span class="line"><span class="comment">//- vector():创建一个空vector</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; arr1;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, arr1.<span class="built_in">size</span>());</span><br><span class="line"><span class="comment">//- vector(int nSize):创建一个vector,元素个数为nSize</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">arr2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="comment">//- vector(int nSize,const t&amp; t):创建一个vector，元素个数为nSize,且值均为t</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">arr3</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="comment">//- vector(const vector&amp;):复制构造函数</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">arr4</span><span class="params">(<span class="number">5</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">arr5</span><span class="params">(arr4)</span></span>;</span><br><span class="line"><span class="comment">//- vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中</span></span><br><span class="line"><span class="keyword">int</span> tmpArr[<span class="number">5</span>] &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">arr6</span><span class="params">(tmpArr + <span class="number">2</span>, tmpArr + <span class="number">4</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ol>
<li>数组</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//auto</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : tmp) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//for sizeof函数计算地址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i  = <span class="number">0</span>; i &lt; <span class="built_in"><span class="keyword">sizeof</span></span> (tmp) / <span class="built_in"><span class="keyword">sizeof</span></span> (tmp[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp[i]);</span><br><span class="line">	   &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//库函数strlen 但是只适用字符串数组</span></span><br><span class="line">    <span class="comment">//for (int i  = 0; i &lt; strlen(tmp); i++) &#123;</span></span><br><span class="line">    <span class="comment">//    printf(&quot;%d\n&quot;, tmp[i]);</span></span><br><span class="line">	   <span class="comment">//&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>vector</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下标访问</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; list;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, list[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器访问</span></span><br><span class="line">vector&lt;string&gt; tmp = &#123; <span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (vector&lt;string&gt;::iterator iter = tmp.<span class="built_in">begin</span>(); iter != tmp.<span class="built_in">end</span>(); iter++)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//下面两种方法都都可以检查迭代器是否为空</span></span><br><span class="line">	cout &lt;&lt; (*iter).<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; iter-&gt;<span class="built_in">empty</span>() &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器逆序访问</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;string&gt;::reverse_iterator iter = tmp.<span class="built_in">rbegin</span>(); iter != tmp.<span class="built_in">rend</span>(); iter++)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ol>
<li>删除最后一个元素pop_back()</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;demo&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    demo.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="comment">//输出 dmeo 容器新的size</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size is :&quot;</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出 demo 容器新的容量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;capacity is :&quot;</span> &lt;&lt; demo.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; demo[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 结果</span></span><br><span class="line"><span class="comment">size is :4</span></span><br><span class="line"><span class="comment">capacity is :5</span></span><br><span class="line"><span class="comment">1 2 3 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>指定删除一个元素erase(position)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;demo&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> iter = demo.<span class="built_in">erase</span>(demo.<span class="built_in">begin</span>() + <span class="number">1</span>);<span class="comment">//删除元素 2</span></span><br><span class="line">    <span class="comment">//输出 dmeo 容器新的size</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size is :&quot;</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出 demo 容器新的容量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;capacity is :&quot;</span> &lt;&lt; demo.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; demo[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//iter迭代器指向元素 3</span></span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 结果</span></span><br><span class="line"><span class="comment">size is :4</span></span><br><span class="line"><span class="comment">capacity is :5</span></span><br><span class="line"><span class="comment">1 3 4 5</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">最终容器大小减1，且从被删除的位置后面的元素向前挪一个位置</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="MAP"><a href="#MAP" class="headerlink" title="MAP"></a>MAP</h2><p>我们可以使用map存储这类一对一的数据：</p>
<p>第一个可以称为关键字(key)，每个关键字只能在map中出现一次；</p>
<p>第二个可能称为该关键字的值(value)；</p>
<p>另外需要注意的是，使用 map 容器存储的各个键-值对，键的值既不能重复也不能被修改。换句话说，map 容器中存储的各个键值对不仅键的值独一无二，键的类型也会用 const 修饰，这意味着只要键值对被存储到 map 容器中，其键的值将不能再做任何修改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">　　	 begin()          <span class="comment">#返回指向map头部的迭代器</span></span><br><span class="line">　	　clear()          <span class="comment">#删除所有元素</span></span><br><span class="line">count()          <span class="comment">#返回指定元素出现的次数</span></span><br><span class="line">empty()          <span class="comment">#如果map为空则返回true</span></span><br><span class="line">end()            <span class="comment">#返回指向map末尾的迭代器</span></span><br><span class="line">equal_range()    <span class="comment">#返回特殊条目的迭代器对</span></span><br><span class="line">erase()          <span class="comment">#删除一个元素</span></span><br><span class="line">find()           <span class="comment">#查找一个元素</span></span><br><span class="line">get_allocator()  <span class="comment">#返回map的配置器</span></span><br><span class="line">insert()         <span class="comment">#插入元素</span></span><br><span class="line">key_comp()       <span class="comment">#返回比较元素key的函数</span></span><br><span class="line">lower_bound()    <span class="comment">#返回键值&gt;=给定元素的第一个位置</span></span><br><span class="line">max_size()       <span class="comment">#返回可以容纳的最大元素个数</span></span><br><span class="line">rbegin()         <span class="comment">#返回一个指向map尾部的逆向迭代器</span></span><br><span class="line">rend()           <span class="comment">#返回一个指向map头部的逆向迭代器</span></span><br><span class="line">size()           <span class="comment">#返回map中元素的个数</span></span><br><span class="line">swap()           <span class="comment">#交换两个map</span></span><br><span class="line">upper_bound()    <span class="comment">#返回键值&gt;给定元素的第一个位置</span></span><br><span class="line">value_comp()     <span class="comment">#返回比较元素value的函数</span></span><br></pre></td></tr></table></figure>



<h3 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h3><ol>
<li><p>引入头文件</p>
<p><code>#include &lt;map&gt;</code> </p>
</li>
<li><p>声明与赋值</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化一</span></span><br><span class="line">	map&lt;string, <span class="keyword">int</span>&gt;myMap&#123; &#123;<span class="string">&quot;a&quot;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&quot;b&quot;</span>,<span class="number">2</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//初始化二</span></span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; _map;</span><br><span class="line">    _map[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    _map[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    _map[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//若是map&lt;string, string&gt; _map，赋值方式也一样</span></span><br><span class="line">    <span class="comment">//_map[&quot;123&quot;] = &quot;324&quot;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; _map;</span><br><span class="line">    _map[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    _map[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    _map[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">    iter = _map.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (iter != _map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d : %d\n&quot;</span>, iter-&gt;first, iter-&gt;second);</span><br><span class="line">        iter++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (iter = _map.<span class="built_in">begin</span>(); iter != _map.<span class="built_in">end</span>(); iter++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d : %d\n&quot;</span>, iter-&gt;first, iter-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//访问一个值</span></span><br><span class="line">    <span class="keyword">int</span> val = _map[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//如果访问不存在的值,如果是基本数据类型则为0，如果是string类型，则为&quot;&quot;空字符串</span></span><br><span class="line">    <span class="keyword">int</span> val1 = _map[<span class="number">4</span>];</span><br><span class="line">    <span class="comment">//val1 = 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入元素很简单，可以直接使用<code>[]</code>来完成元素的插入</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如初始化上    </span></span><br><span class="line"><span class="comment">//初始化一</span></span><br><span class="line">map&lt;string, <span class="keyword">int</span>&gt;myMap&#123; &#123;<span class="string">&quot;a&quot;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&quot;b&quot;</span>,<span class="number">2</span>&#125; &#125;;</span><br><span class="line">   <span class="comment">//初始化二</span></span><br><span class="line">   map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; _map;</span><br><span class="line">   _map[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">   _map[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">   _map[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//若是map&lt;string, string&gt; _map，赋值方式也一样</span></span><br><span class="line">   <span class="comment">//_map[&quot;123&quot;] = &quot;324&quot;;</span></span><br></pre></td></tr></table></figure>

<h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除键为bfff指向的元素</span></span><br><span class="line">cmap.<span class="built_in">erase</span>(<span class="string">&quot;bfff&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除迭代器 key所指向的元素</span></span><br><span class="line"><span class="comment">//find(key)返回的是迭代器</span></span><br><span class="line">map&lt;string,<span class="keyword">int</span>&gt;::iterator key = cmap.<span class="built_in">find</span>(<span class="string">&quot;mykey&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(key!=cmap.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    cmap.<span class="built_in">erase</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//删除所有元素</span></span><br><span class="line">cmap.<span class="built_in">erase</span>(cmap.<span class="built_in">begin</span>(),cmap.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<h2 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h2><p>所有元素都会在插入时自动被排序<br>set/multiset属于关联式容器，底层结构是用二叉树实现。<br><strong>set和multiset区别:</strong><br>●set不允许容器中有重复的元素<br>●multiset允许容器中有 重复的元素</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#交换两个set集合</span></span><br><span class="line">swap(<span class="built_in">set</span>)</span><br><span class="line"><span class="comment">#判断set是否为空</span></span><br><span class="line">empty()</span><br><span class="line"><span class="comment">#集合大小</span></span><br><span class="line">size()</span><br></pre></td></tr></table></figure>

<h3 id="声明-2"><a href="#声明-2" class="headerlink" title="声明"></a>声明</h3><ol>
<li><p>引入头文件 </p>
<p><code> #include &lt;set&gt;</code></p>
</li>
<li><p>构造</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">set&lt;<span class="keyword">int</span>&gt; tmp&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="遍历-2"><a href="#遍历-2" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; tmp&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = tmp.<span class="built_in">begin</span>(); i != tmp.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><p>关键函数：insert(elem);</p>
<p>int count(elem);可以判断是否有相关元素，返回0或1；</p>
<p>find(elem);返回该元素位置的迭代器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt;s1;</span><br><span class="line"><span class="comment">//插入数据,插入队尾</span></span><br><span class="line"> 	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line"> 	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"><span class="comment">//同样可以给定迭代器位置，插入到对应元素的后面(set会自己排序，所以这个插到对应位置没意义)</span></span><br><span class="line">s1.<span class="built_in">insert</span>(s1.<span class="built_in">find</span>(<span class="number">10</span>),<span class="number">15</span>);</span><br></pre></td></tr></table></figure>

<h3 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h3><p>关键函数：earse();</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除30这个元素</span></span><br><span class="line">s1.<span class="built_in">erase</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空set</span></span><br><span class="line"><span class="comment">//等价s1.earse(s1.begin(),s1.end())</span></span><br><span class="line">s1.<span class="built_in">clear</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>将重写了operator 方法的类传入构造中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逆序排列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">compare1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span><span class="keyword">const</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 &lt; v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="keyword">int</span>,compare1&gt;s1</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA设计模式-单例模式</title>
    <url>/2021/06/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>项目源码在我的github上：<a href="https://github.com/Lehanbal/DesignPatternRecord">Lehanbal/DesignPatternRecord (github.com)</a>,有需要的话可以去clone一份</p>
<p>单例模式大致上可以分为饿汉式和懒汉式。</p>
<p>饿汉式：上来先在单例中new一个对象，很直白，但是出现的问题就是如果整个流程下来哦度没有使用这个单例实例，就会造成资源的浪费。</p>
<p>懒汉式：等你需要的时候我再去new这个对象，这一操作可以避免出现饿汉式的缺点，但是需要额外去考虑线程同步问题。</p>
<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>饿汉式可以用，但是不推荐，都是为了避免造成资源浪费。</p>
<h3 id="静态变量的方式"><a href="#静态变量的方式" class="headerlink" title="静态变量的方式"></a>静态变量的方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态变量的俄汉式</span></span><br><span class="line"><span class="comment"> * 优点：</span></span><br><span class="line"><span class="comment"> *  写法简单，在类进行加载的时候就已经完成了单例的创建，减少了线程同步问题</span></span><br><span class="line"><span class="comment"> * 缺点：</span></span><br><span class="line"><span class="comment"> *  也是因为在类加载的时候就已经完成了创建，没有达成lazy loading的效果，如果该类从头到尾没用过，就造成了内存浪费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造器，不能通过new来创建该单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//既然不能通过new来创建这个对象，那么在该类进行加载的时候就创建一个该单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建了该对象，对外提供一个公共的获取该类对象的方法即可。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态代码块的方式"><a href="#静态代码块的方式" class="headerlink" title="静态代码块的方式"></a>静态代码块的方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 优缺点与静态常量的方式一样，不过这种方法是将实例化过程放在了静态代码块之中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用静态代码块进行实例化，此处在类加载的时候就开始将该类装进内存了</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><h3 id="线程不安全的方式"><a href="#线程不安全的方式" class="headerlink" title="线程不安全的方式"></a>线程不安全的方式</h3><p>没有考虑同步的话，很可能会导致产生很多个实例对象，为此需要考虑synchronized等同步情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式，需要用到的时候才会去创建，但是线程不安全，当多个线程一起执行到if判断内时，就会产生多个实例，并不能保证单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程安全的方式"><a href="#线程安全的方式" class="headerlink" title="线程安全的方式"></a>线程安全的方式</h3><p>考虑了线程同步，但是同步就会带来效率问题，getInstance()在程序中会经常使用到，所以这一种方式会导致效率较低。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式，需要用到的时候才会去创建，但是线程安全，使用synchronize关键字保证线程同步，但是这带来了效率问题，</span></span><br><span class="line"><span class="comment"> * 每次去getInstance的时候都会进行一次线程同步，而且getInstance这件事情是经常发生的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双重检查方式（double-check）"><a href="#双重检查方式（double-check）" class="headerlink" title="双重检查方式（double check）"></a>双重检查方式（double check）</h3><p>推荐使用的方案之一。只有一开始的单例对象实例化需要开始同步，之后的getInstance()都不需要进入同步流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * double check单例。双重检查，挺好的，建议开发中使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//volatile防止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//此处进行第一次判断，当拥有实例之后就不会再进行同步代码块的判定了，也就避免了效率问题</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="comment">//同步代码之后再进行一次判断，如果为空就创建一个实例。</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>值得推荐的方式之一，利用jvm的类转载机制，内部静态类在外部类被装载的时候是不会被转载的，当使用到内部类的资源的时候，内部类才会被装载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用静态内部类的方式进行的单例，该方法也值得推荐</span></span><br><span class="line"><span class="comment"> * jvm的类转载机制：</span></span><br><span class="line"><span class="comment"> *      当外部类被转载的时候，内部类并不会被转载</span></span><br><span class="line"><span class="comment"> *      当使用到内部类的内容的时候，内部类会被转载并且只会被装载1次，所以也解决的线程同步的问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚举方式"><a href="#枚举方式" class="headerlink" title="枚举方式"></a>枚举方式</h2><p>值得被推荐的一种方式。比较特殊的一种单例实现，使用枚举的防止进行单例模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单粗暴的枚举单例，也是值得推荐使用</span></span><br><span class="line"><span class="comment"> * 能够解决线程问题</span></span><br><span class="line"><span class="comment"> * 能防止反序列化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用的时候如下</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum_Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton type1 = Singleton.INSTANCE;</span><br><span class="line">        Singleton type2 = Singleton.INSTANCE;</span><br><span class="line"></span><br><span class="line">        System.out.println(type1 == type2);</span><br><span class="line">        System.out.println(type1.hashCode());</span><br><span class="line">        System.out.println(type2.hashCode());</span><br><span class="line"></span><br><span class="line">        type1.func1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized与ReentrantLock的区别</title>
    <url>/2020/11/20/synchronized%E4%B8%8EReentrantLock%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/zxd8080666/article/details/83214089">原文章</a>，本来想自己总结以下的，但是这文章我觉得写得太好了，自己总结的内容完全没有这个文章写得好，直接搬过来了。</p>
<h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p><code>synchronized</code>与<code>ReentrankLock</code>都是通过加锁实现同步，并且都是阻塞式同步，也就是锁如果一个线程获得了对象锁，在该线程进行访问该同步代码块的时候，其他线程必须阻塞等待该线程访问完毕。</p>
<p>进行线程阻塞和唤醒的代价是比较高的，操作系统需要在用户态和内核态之间来回切换。</p>
<h2 id="功能区别"><a href="#功能区别" class="headerlink" title="功能区别"></a>功能区别</h2><p><code>synchronized</code>是Java的关键字，原生语法，通过JVM实现。</p>
<p><code>ReentrantLock</code>是JDK 1.5之后提供的API层面的互斥锁，需要<code>lock()</code>和<code>unlock()</code>方法配合<code>try..finally</code>语句块实现。</p>
<p>便利性：<code>synchronized</code>的使用很便捷，我们并不需要手动去释放锁，这一切都交给编译器去操作，并且在wait的过程中，会解锁。<code>ReentrantLock</code>则需要手动进行加锁和解锁，若忽略解锁步骤就会造成死锁，如果对<code>ReentrantLock</code>进行wait()方法的调用，该锁依旧不会被释放，抱着锁睡觉。</p>
<p>锁的细粒度和灵活度：<code>ReentrantLock</code>锁的细粒度和灵活度都优于<code>synchronized</code>。</p>
<h2 id="性能区别"><a href="#性能区别" class="headerlink" title="性能区别"></a>性能区别</h2><p>在<code>synchronized</code>优化之前，两者的性能差很多。</p>
<p>但是<code>synchronized</code>引入了偏向锁，自旋锁之后，两者性能差不多持平，在两者方法都可用的情况下，官方推荐使用<code>synchronized</code>。</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a><code>synchronized</code></h3><p><code>synchronized</code>经过编译，会在同步代码块的前后分别形成<code>monitorenter</code>和<code>monitorexit</code>两个字节码指令。在执行<code>monitorenter</code>指令的时候，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有该对象锁，就把锁的计算器加一，相应的，在执行<code>monitorexit</code>的时候计算器减一。当计算器为零的时候，锁就被释放了。如果获取当前对象锁失败，那么当前线程就要阻塞，直到对象锁被另一个线程释放为止。</p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><code>ReentrantLock</code></h3><p>由于<code>ReentrantLock</code>是<code>java.util.concurrent</code>包下提供的一套互斥锁，相比<code>Synchronized</code>，<code>ReentrantLock</code>类提供了一些高级功能，主要有以下3项：</p>
<ol>
<li>等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized来说可以避免出现死锁的情况。通过<code>lock.lockInterruptibly()</code>来实现这个机制。</li>
<li>公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，<code>Synchronized</code>锁非公平锁，<code>ReentrantLock</code>默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。</li>
<li>锁绑定多个条件，一个<code>ReentrantLock</code>对象可以同时绑定对个对象。<code>ReenTrantLock</code>提供了一个<code>Condition</code>类，用来实现分组唤醒需要唤醒的线程们，而不是像<code>synchronized</code>要么随机唤醒一个线程要么唤醒全部线程。</li>
</ol>
<p><code>ReenTrantLock</code>的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>生产者与消费者问题</title>
    <url>/2020/11/20/%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="synchronized实现"><a href="#synchronized实现" class="headerlink" title="synchronized实现"></a><code>synchronized</code>实现</h2><p>资源类：使用了一个List队列来当作锁的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.ProducerAndConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> max_size = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> List&lt;Object&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">production</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">while</span> (list.size() + <span class="number">1</span> &gt; max_size) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;仓库满了，生产者暂停&quot;</span>);</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(<span class="keyword">new</span> Object());</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者生产了一个产品，当前产品剩余数量为&quot;</span> + list.size());</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">while</span> (list.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;仓库空了，消费者暂停&quot;</span>);</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者消费了一个产品，当前产品剩余数量为&quot;</span> + list.size());</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产者类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.ProducerAndConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producter</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Resource resource = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producter</span><span class="params">(Resource resource)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resource = resource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            resource.production();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.ProducerAndConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Resource resource = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Resource resource)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resource = resource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            resource.consume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.ProducerAndConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Resource resource = <span class="keyword">new</span> Resource();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producter(resource)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producter(resource)).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(resource)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(resource)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">仓库空了，消费者暂停</span><br><span class="line">生产者生产了一个产品，当前产品剩余数量为1</span><br><span class="line">消费者消费了一个产品，当前产品剩余数量为0</span><br><span class="line">仓库空了，消费者暂停</span><br><span class="line">生产者生产了一个产品，当前产品剩余数量为1</span><br><span class="line">消费者消费了一个产品，当前产品剩余数量为0</span><br><span class="line">生产者生产了一个产品，当前产品剩余数量为1</span><br><span class="line">消费者消费了一个产品，当前产品剩余数量为0</span><br><span class="line">生产者生产了一个产品，当前产品剩余数量为1</span><br><span class="line">消费者消费了一个产品，当前产品剩余数量为0</span><br><span class="line">仓库空了，消费者暂停</span><br><span class="line">生产者生产了一个产品，当前产品剩余数量为1</span><br><span class="line">消费者消费了一个产品，当前产品剩余数量为0</span><br><span class="line">仓库空了，消费者暂停</span><br><span class="line">生产者生产了一个产品，当前产品剩余数量为1</span><br><span class="line">消费者消费了一个产品，当前产品剩余数量为0</span><br><span class="line">仓库空了，消费者暂停</span><br><span class="line">生产者生产了一个产品，当前产品剩余数量为1</span><br><span class="line">消费者消费了一个产品，当前产品剩余数量为0</span><br><span class="line">仓库空了，消费者暂停</span><br><span class="line">生产者生产了一个产品，当前产品剩余数量为1</span><br><span class="line">消费者消费了一个产品，当前产品剩余数量为0</span><br><span class="line">仓库空了，消费者暂停</span><br><span class="line">生产者生产了一个产品，当前产品剩余数量为1</span><br><span class="line">消费者消费了一个产品，当前产品剩余数量为0</span><br><span class="line">仓库空了，消费者暂停</span><br><span class="line">生产者生产了一个产品，当前产品剩余数量为1</span><br><span class="line">消费者消费了一个产品，当前产品剩余数量为0</span><br></pre></td></tr></table></figure>

<h2 id="ReentrankLock实现"><a href="#ReentrankLock实现" class="headerlink" title="ReentrankLock实现"></a><code>ReentrankLock</code>实现</h2><p>与synchronized实现的方式很像，不过是将synchronized代码块包裹的地方换成使用lock包裹罢了。</p>
<p>资源类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.ProducerAndConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> max_size = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> List&lt;Object&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition empty = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition full = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">production</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (list.size() + <span class="number">1</span> &gt; max_size) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;仓库满了，生产者暂停&quot;</span>);</span><br><span class="line">                    full.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(<span class="keyword">new</span> Object());</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者生产了一个产品，当前产品剩余数量为&quot;</span> + list.size());</span><br><span class="line">            empty.signalAll();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (list.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;仓库空了，消费者暂停&quot;</span>);</span><br><span class="line">                    empty.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者消费了一个产品，当前产品剩余数量为&quot;</span> + list.size());</span><br><span class="line">            full.signalAll();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产者类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.ProducerAndConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producter</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Resource resource = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producter</span><span class="params">(Resource resource)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resource = resource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            resource.production();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.ProducerAndConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Resource resource = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Resource resource)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resource = resource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            resource.consume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.ProducerAndConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Resource resource = <span class="keyword">new</span> Resource();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producter(resource)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producter(resource)).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(resource)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(resource)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">生产者生产了一个产品，当前产品剩余数量为1</span><br><span class="line">消费者消费了一个产品，当前产品剩余数量为0</span><br><span class="line">生产者生产了一个产品，当前产品剩余数量为1</span><br><span class="line">消费者消费了一个产品，当前产品剩余数量为0</span><br><span class="line">仓库空了，消费者暂停</span><br><span class="line">生产者生产了一个产品，当前产品剩余数量为1</span><br><span class="line">生产者生产了一个产品，当前产品剩余数量为2</span><br><span class="line">消费者消费了一个产品，当前产品剩余数量为1</span><br><span class="line">消费者消费了一个产品，当前产品剩余数量为0</span><br><span class="line">生产者生产了一个产品，当前产品剩余数量为1</span><br><span class="line">生产者生产了一个产品，当前产品剩余数量为2</span><br><span class="line">消费者消费了一个产品，当前产品剩余数量为1</span><br><span class="line">消费者消费了一个产品，当前产品剩余数量为0</span><br><span class="line">生产者生产了一个产品，当前产品剩余数量为1</span><br><span class="line">生产者生产了一个产品，当前产品剩余数量为2</span><br><span class="line">消费者消费了一个产品，当前产品剩余数量为1</span><br><span class="line">消费者消费了一个产品，当前产品剩余数量为0</span><br><span class="line">生产者生产了一个产品，当前产品剩余数量为1</span><br><span class="line">生产者生产了一个产品，当前产品剩余数量为2</span><br><span class="line">消费者消费了一个产品，当前产品剩余数量为1</span><br><span class="line">消费者消费了一个产品，当前产品剩余数量为0</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>Lock锁与Condition初解</title>
    <url>/2020/11/20/Lock%E9%94%81%E4%B8%8ECondition%E5%88%9D%E8%A7%A3/</url>
    <content><![CDATA[<p><code>synchronized</code>可以实现线程之间的同步互斥，在jdk1.5之后新增加了一个<code>ReentrantLock</code>类也能够实现线程的同步问题， 并且粒度比<code>synchronized</code>要小。</p>
<p>Lock实现提供比使用<code>synchronized</code>方法和语句可以获得的更广泛的锁定操作。  它们允许更灵活的结构化，可能具有完全不同的属性，并且可以支持多个相关联的对象<code>Condition</code></p>
<p><code>ReentrantLock</code>实现了<code>Lock</code>接口，该接口有具体的三个实现类，分别是</p>
<ol>
<li><code>ReentrantLock</code>:可重入锁。</li>
<li><code>ReentrantReadWriteLock.WriteLock</code>：写锁，只能有一个进程访问。</li>
<li><code>ReentrantReadWriteLock.ReadLock</code>：读锁，可以允许多个线程同时访问。</li>
</ol>
<p>这里对<code>ReentrantLock</code>进行进一步的说明。</p>
<h2 id="使用ReentrankLock实现线程同步"><a href="#使用ReentrankLock实现线程同步" class="headerlink" title="使用ReentrankLock实现线程同步"></a>使用<code>ReentrankLock</code>实现线程同步</h2><p><code>ReentrankLock</code>的方法中<code>lock</code>和<code>unlock</code>，分别表示上锁和解锁，我们一般将<code>unlock</code>放在try..catch..finally..的finally中，为了能够确保锁能够正确释放，避免造成死锁。</p>
<p>另外有一点需要注意的是，<code>synchronized</code>在线程进入阻塞状态的时候，是会将锁释放的，而<code>ReentrankLock</code>不一样，即使是线程进入阻塞也不会将锁释放。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;卖出了第&quot;</span> + (ticket--) + <span class="string">&quot;张票，还剩下&quot;</span>+ ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Resource resource = <span class="keyword">new</span> Resource();</span><br><span class="line">        <span class="keyword">new</span> Thread(resource :: sale, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(resource :: sale, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(resource :: sale, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">线程A卖出了第10张票，还剩下9张票</span><br><span class="line">线程A卖出了第9张票，还剩下8张票</span><br><span class="line">线程A卖出了第8张票，还剩下7张票</span><br><span class="line">线程A卖出了第7张票，还剩下6张票</span><br><span class="line">线程A卖出了第6张票，还剩下5张票</span><br><span class="line">线程A卖出了第5张票，还剩下4张票</span><br><span class="line">线程A卖出了第4张票，还剩下3张票</span><br><span class="line">线程A卖出了第3张票，还剩下2张票</span><br><span class="line">线程A卖出了第2张票，还剩下1张票</span><br><span class="line">线程A卖出了第1张票，还剩下0张票</span><br></pre></td></tr></table></figure>

<p>可以看到全都是线程A卖出去的票，线程B与C都在等待A释放锁才能执行。</p>
<p>一个线程在卖力的干事，另外两个线程摸鱼，这种情况能叫多线程吗，我说不能。</p>
<p>为了防止线程摸鱼，在Condition中的await()方法就是在线程进入休眠的时候把锁让出来，方便其他线程进行作业。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition condition1 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;卖出了第&quot;</span> + (ticket--) + <span class="string">&quot;张票，还剩下&quot;</span>+ ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                condition1.await(<span class="number">50</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Resource resource = <span class="keyword">new</span> Resource();</span><br><span class="line">        <span class="keyword">new</span> Thread(resource :: sale, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(resource :: sale, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(resource :: sale, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">线程A卖出了第10张票，还剩下9张票</span><br><span class="line">线程B卖出了第9张票，还剩下8张票</span><br><span class="line">线程C卖出了第8张票，还剩下7张票</span><br><span class="line">线程B卖出了第7张票，还剩下6张票</span><br><span class="line">线程A卖出了第6张票，还剩下5张票</span><br><span class="line">线程C卖出了第5张票，还剩下4张票</span><br><span class="line">线程A卖出了第4张票，还剩下3张票</span><br><span class="line">线程C卖出了第3张票，还剩下2张票</span><br><span class="line">线程B卖出了第2张票，还剩下1张票</span><br><span class="line">线程A卖出了第1张票，还剩下0张票</span><br></pre></td></tr></table></figure>



<h2 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h2><p>公平锁：表示线程获取锁的顺序是按照线程加锁的顺序来进行分配的，即先到先得，先进先出的顺序。</p>
<p>非公平锁：一种获取锁的抢占机制，是随即拿到锁的，和公平锁不一样的是想来的不一定先拿到锁，这个方式可能造成某些线程一直拿不到锁，结果是不公平的。</p>
<p>源码如下，根据传递的Boolean值来区分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Condition解析"><a href="#Condition解析" class="headerlink" title="Condition解析"></a>Condition解析</h2><p>synchronized关键字可以配合Object的wait()、notify()等方法实现等待/通知模式。Condition接口提供了类似的Object的监视器方法，与Lock配合实现等待通知模式。</p>
<p>Object监视方法与Condition方法的区别：</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>Object Monitor Methods</th>
<th>Condition</th>
</tr>
</thead>
<tbody><tr>
<td>前置条件</td>
<td>获取对象的锁</td>
<td>调用<code>Lock.lock()</code>获得锁，调用<code>lock.newCondition()</code>获取Condition对象</td>
</tr>
<tr>
<td>调用方式</td>
<td>直接调用：<code>Object.wait()</code></td>
<td>直接调用：<code>condition.await()</code></td>
</tr>
<tr>
<td>等待队列个数</td>
<td>一个</td>
<td>多个</td>
</tr>
<tr>
<td>当前线程释放锁并进入等待状态</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>当前线程释放锁并进入等待状态，在等待状态中不响应中断</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>当前线程释放锁并进入超时等待状态</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>当前线程释放锁并进入等待状态到将来的某个时间</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>唤醒等待队列中的一个线程</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>唤醒等待队列中的全部线程</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<h3 id="Condition接口方法"><a href="#Condition接口方法" class="headerlink" title="Condition接口方法"></a>Condition接口方法</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>方法内容</th>
</tr>
</thead>
<tbody><tr>
<td><code>await()</code></td>
<td>造成当前线程在接到信号或被中断之前一直处于等待状态</td>
</tr>
<tr>
<td><code>await(long time, TimeUnit unit)</code></td>
<td>造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态</td>
</tr>
<tr>
<td><code>awaitNanos(long nanosTimeout)</code></td>
<td>造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。返回值表示剩余时间，如果在<code>nanosTimesout</code>之前被唤醒，返回值 = <code>nanosTimeout</code> - 消耗时间，如果返回值小于等于0则可以认定它已经超时了。</td>
</tr>
<tr>
<td><code>awaitUninterruptibly()</code></td>
<td>造成当前信号在接到信号之前一直处于等待状态。（该方法对中断不敏感）</td>
</tr>
<tr>
<td><code>awaitUntil(Date deadline)</code></td>
<td>造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。如果没有到指定时间就被通知，则返回true，否则表示到了指定时间，返回false</td>
</tr>
<tr>
<td><code>signal()</code></td>
<td>唤醒一个等待线程。该线程从等待方法返回前必须获得与Condition相关的锁</td>
</tr>
<tr>
<td><code>signalAll()</code></td>
<td>唤醒所有等待线程。能够从等待方法返回的线程必须获得与Condition相关的锁</td>
</tr>
</tbody></table>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p><code>ReentrankLock</code>具有完全互斥排他的效果，同一时间只能够有一个线程执行lock锁后面的代码，虽然能够保证线程的安全性，但是效率不高。读写锁就是为了在特定条件提高效率而出现的。</p>
<p>读写锁表示两个锁：</p>
<p>读操作相关的锁，也叫共享锁。</p>
<p>写操作相关的锁，也叫排他锁。</p>
<p>多个读锁之间不互斥，读锁与写锁互斥，多个写锁互斥。</p>
<h3 id="ReentrantReadWriteLock-ReadLock读锁"><a href="#ReentrantReadWriteLock-ReadLock读锁" class="headerlink" title="ReentrantReadWriteLock.ReadLock读锁"></a><code>ReentrantReadWriteLock.ReadLock</code>读锁</h3><p>多个读锁同时访问资源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadResource</span> </span>&#123;</span><br><span class="line">    ReentrantReadWriteLock.ReadLock readLock = <span class="keyword">new</span> ReentrantReadWriteLock().readLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;访问了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;运行了&quot;</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获得锁,是否有锁等待&quot;</span> + lock.hasQueuedThreads());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;释放锁,是否有锁等待&quot;</span> + lock.hasQueuedThreads() + <span class="string">&quot;等待数量为&quot;</span> + lock.getQueueLength());</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下，几乎是在同一时间进行访问的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1605876055602</span><br><span class="line">1605876055602</span><br><span class="line">1605876055602</span><br><span class="line">A访问了</span><br><span class="line">C访问了</span><br><span class="line">B访问了</span><br></pre></td></tr></table></figure>

<h3 id="ReentrantReadWriteLock-WriteLock写锁"><a href="#ReentrantReadWriteLock-WriteLock写锁" class="headerlink" title="ReentrantReadWriteLock.WriteLock写锁"></a><code>ReentrantReadWriteLock.WriteLock</code>写锁</h3><p>多个写锁互斥：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteResource</span> </span>&#123;</span><br><span class="line">    ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取写锁，获取时间为：&quot;</span> + System.currentTimeMillis());</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WriteResource writeResource = <span class="keyword">new</span> WriteResource();</span><br><span class="line">        <span class="keyword">new</span> Thread(writeResource :: writeMethod, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(writeResource :: writeMethod, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(writeResource :: writeMethod, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(writeResource :: writeMethod, <span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>停顿了500ms，防止cpu执行太快了从结果看不出来。可以看出写锁都是分别获取的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">A获取写锁，获取时间为：1605876558509</span><br><span class="line">B获取写锁，获取时间为：1605876559020</span><br><span class="line">C获取写锁，获取时间为：1605876559520</span><br><span class="line">D获取写锁，获取时间为：1605876560021</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JUC</tag>
        <tag>LOCK</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized初解</title>
    <url>/2020/11/19/synchronized%E5%88%9D%E8%A7%A3/</url>
    <content><![CDATA[<p>synchronized是java中的一个实现同步的关键字。</p>
<p>在并发编程中存在线程安全问题，多个线程共同操作共享数据就会造成数据紊乱的情况。</p>
<p>关键字synchronized可以保证同一时刻只能由一个线程可以执行某个方法或者某个代码块，同时synchronized可以保证一个线程的可见性（与volatile一样）。</p>
<p>synchronized可以修饰的对象有以下四种：</p>
<ol>
<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用范围为大括号包括起来的代码，作用的对象是调用这个代码块的对象。</li>
<li>修饰一个方法，被修饰的方法称为同步方法，其作用范围是整个方法，作用的对象是调用这个方法的对象。</li>
<li>修饰一个静态的方法，起作用的范围是整个静态方法，其作用的对象是这个类的所有对象。</li>
<li>修饰一个类，其作用范围是synchronized后面括号包括的部分，作用的对象是这个类的所有对象。</li>
</ol>
<p>为什么要同步代码块呢？在某些情况下，我们编写的方法体可能比较大，同时存在一些比较耗时的操作，而需要同步的代码又只有一小部分，如果直接对整个方法进行同步操作，可能会得不偿失，此时我们可以使用同步代码块的方式对需要同步的代码进行包裹，这样就无需对整个方法进行同步操作了。</p>
<h2 id="多个线程同时访问synchronized修饰的方法"><a href="#多个线程同时访问synchronized修饰的方法" class="headerlink" title="多个线程同时访问synchronized修饰的方法"></a>多个线程同时访问synchronized修饰的方法</h2><p>资源类（降低耦合度，使用了函数式接口）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.synchronizedStudy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">ticket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在卖出第&quot;</span> + (num--) + <span class="string">&quot;张票，剩余&quot;</span> + num + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Resource resource = <span class="keyword">new</span> Resource();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) resource.ticket(); &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) resource.ticket(); &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) resource.ticket(); &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">A正在卖出第10张票，剩余9张票</span><br><span class="line">A正在卖出第9张票，剩余8张票</span><br><span class="line">A正在卖出第8张票，剩余7张票</span><br><span class="line">A正在卖出第7张票，剩余6张票</span><br><span class="line">A正在卖出第6张票，剩余5张票</span><br><span class="line">C正在卖出第5张票，剩余4张票</span><br><span class="line">C正在卖出第4张票，剩余3张票</span><br><span class="line">C正在卖出第3张票，剩余2张票</span><br><span class="line">B正在卖出第2张票，剩余1张票</span><br><span class="line">B正在卖出第1张票，剩余0张票</span><br></pre></td></tr></table></figure>

<p>保证了同一时刻只能有一个线程访问资源类。</p>
<h2 id="synchronized锁的对象分析"><a href="#synchronized锁的对象分析" class="headerlink" title="synchronized锁的对象分析"></a>synchronized锁的对象分析</h2><h3 id="锁住对象的情况"><a href="#锁住对象的情况" class="headerlink" title="锁住对象的情况"></a>锁住对象的情况</h3><p>在开头的修饰对象中点名到修饰一个方法的时候，作用的对象是调用这个方法的对象。</p>
<p>换句简单点的话来说，就是我需要访问同一个对象的其他同步方法的时候，是需要等待synchronized将锁释放掉才能够访问。</p>
<p>同样是资源类，两个线程访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.synchronizedStudy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">5000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;This is A test&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is B test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Resource resource = <span class="keyword">new</span> Resource();</span><br><span class="line">        <span class="keyword">new</span> Thread(resource :: testA).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(resource :: testB).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果永远如下，无论测试多少遍：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">This is A <span class="built_in">test</span></span><br><span class="line">This is B <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>原因是synchronized会给调用的对象加锁，当线程所调用的对象是同一个对象的时候，就需要去等待上一个线程释放锁。</p>
<h3 id="锁住类的情况"><a href="#锁住类的情况" class="headerlink" title="锁住类的情况"></a>锁住类的情况</h3><p>对于开头说的第三第四点，当synchronized修饰静态方法或者类的时候，锁的对象就会变成整个类。</p>
<p>直接上代码。</p>
<p>修饰静态代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.synchronizedStudy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">5000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;This is A test&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is B test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(Resource :: testA).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(Resource :: testB).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于使用synchronized修饰类的情况如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lehanbal.synchronizedStudy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Resource.class)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&gt; A&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Resource.class)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&gt; B&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Resource resource1 = <span class="keyword">new</span> Resource();</span><br><span class="line">        Resource resource2 = <span class="keyword">new</span> Resource();</span><br><span class="line">        <span class="keyword">new</span> Thread(resource1 :: testA).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(resource2 :: testB).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>锁住的是整个类，所以需要等类的锁释放掉了才能够让下一个线程执行对应的代码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Thread-0-&gt; A</span><br><span class="line">Thread-1-&gt; B</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JUC</tag>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis发布订阅</title>
    <url>/2020/11/18/Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/</url>
    <content><![CDATA[<p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>
<p>Redis客户端可以订阅任意数量的频道。</p>
<p>订阅频道：</p>
<p><img src="http://cdn.lehanbal.top/image-20201118183513237.png" alt="image-20201118183513237"></p>
<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时：</p>
<p><img src="http://cdn.lehanbal.top/image-20201118183529589.png" alt="image-20201118183529589"></p>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><p>客户端一订阅 lehanbal 频道：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE lehanbal</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<p>客户端二向 lehanbal 频段推送内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; publish lehanbal hello,world</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<p>客户端一收到内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1) <span class="string">&quot;message&quot;</span></span><br><span class="line">2) <span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello,world&quot;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>序号</th>
<th>命令以及描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>PSUBSCRIBE pattern 订阅一个或多个符合给定模式的频道。</td>
</tr>
<tr>
<td>2</td>
<td>PUBSUB subcommand [argument [argument …]] 查看订阅与发布系统状态。</td>
</tr>
<tr>
<td>3</td>
<td>PUBLISH channel message将信息发送到指定的频道。</td>
</tr>
<tr>
<td>4</td>
<td>PUNSUBSCRIBE [pattern [pattern …]] 退订所有给定模式的频道。</td>
</tr>
<tr>
<td>5</td>
<td>SUBSCRIBE channel [channel …] 订阅给定的一个或多个频道的信息。</td>
</tr>
<tr>
<td>6</td>
<td>UNSUBSCRIBE [channel [channel …]] 指退订给定的频道。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Jedis工具类</title>
    <url>/2020/11/18/Jedis%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="Jedis连接池工具类"><a href="#Jedis连接池工具类" class="headerlink" title="Jedis连接池工具类"></a>Jedis连接池工具类</h2><p>每次连接Jedis很烦，而且反复连接和断开很影响性能，Jedis本身就由JedisPool和JedisConfig类供我们搭建自己的JedisPool工具类来让我们在开发的过程中更为方便。</p>
<p>首先创建我们的jedis.properties配置文件，配置文件放在resources文件夹下。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#地址</span></span><br><span class="line"><span class="attr">host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment">#端口</span></span><br><span class="line"><span class="attr">port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment">#总连接的最大数量</span></span><br><span class="line"><span class="attr">maxTotal</span>=<span class="string">50</span></span><br><span class="line"><span class="comment">#空闲连接的最大数量，至少会保持10个活连接</span></span><br><span class="line"><span class="attr">maxIdle</span>=<span class="string">10</span></span><br></pre></td></tr></table></figure>

<p>JedisPool工具类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        InputStream is = JedisPoolUtil.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jedis.properties&quot;</span>);</span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pro.load(is);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        config.setMaxIdle(Integer.parseInt(pro.getProperty(<span class="string">&quot;maxIdle&quot;</span>)));</span><br><span class="line">        config.setMaxTotal(Integer.parseInt(pro.getProperty(<span class="string">&quot;maxTotal&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        jedisPool = <span class="keyword">new</span> JedisPool(config, pro.getProperty(<span class="string">&quot;host&quot;</span>), Integer.parseInt(pro.getProperty(<span class="string">&quot;port&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Jedis操作工具类"><a href="#Jedis操作工具类" class="headerlink" title="Jedis操作工具类"></a>Jedis操作工具类</h2><p>每次操作Jedis都需要去释放连接，如果觉得觉得很烦的话，可以试着使用Jedis操作工具类，这里封装了String方法和Hash方法，需要什么功能就可以封装什么功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取hash表中的全部key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 全部key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;String&gt; <span class="title">getHashAllKey</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            jedis = JedisPoolUtil.getJedis();</span><br><span class="line">            <span class="keyword">return</span> jedis.hkeys(name);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            JedisPoolUtil.returnJedis(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取hash表中对应key的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hashName hash名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getHashKV</span><span class="params">(String hashName, String key)</span></span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            jedis = JedisPoolUtil.getJedis();</span><br><span class="line">            <span class="keyword">return</span> jedis.hget(hashName, key);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            JedisPoolUtil.returnJedis(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除hash表中的键值对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hashName hash名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">delHashKV</span><span class="params">(String hashName, String key)</span></span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            jedis = JedisPoolUtil.getJedis();</span><br><span class="line">            <span class="keyword">return</span> jedis.hdel(hashName, key);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            JedisPoolUtil.returnJedis(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放hash键值对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hashName hash名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 存放的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">setHashKV</span><span class="params">(String hashName, String key, String value)</span></span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            jedis = JedisPoolUtil.getJedis();</span><br><span class="line">            <span class="keyword">return</span> jedis.hset(hashName, key, value);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            JedisPoolUtil.returnJedis(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储键值对，永久</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">setKV</span><span class="params">(String k, String v)</span></span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            jedis = JedisPoolUtil.getJedis();</span><br><span class="line">            <span class="keyword">return</span> jedis.set(k, v);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            JedisPoolUtil.returnJedis(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放键值对，有时限</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 存活时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">setKV</span><span class="params">(String k, <span class="keyword">int</span> s, String v)</span></span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            jedis = JedisPoolUtil.getJedis();</span><br><span class="line">            <span class="keyword">return</span> jedis.setex(k, s, v);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            JedisPoolUtil.returnJedis(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取键值对的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getKV</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            jedis = JedisPoolUtil.getJedis();</span><br><span class="line">            <span class="keyword">return</span> jedis.get(key);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            JedisPoolUtil.returnJedis(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除对应的键值对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">delKV</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            jedis = JedisPoolUtil.getJedis();</span><br><span class="line">            <span class="keyword">return</span> jedis.del(key);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            JedisPoolUtil.returnJedis(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据备份与恢复</title>
    <url>/2020/11/18/Redis%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<h2 id="备份模式"><a href="#备份模式" class="headerlink" title="备份模式"></a>备份模式</h2><p>在Redis中，有两种数据备份的方式：</p>
<ol>
<li><p>RDB</p>
<p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘中，fork一个子进程，先将数据集写入临时文件，写入成功后再替换之前的文件，用二进制压缩存储。它的特点是粒度较大，如果在触发存储机制之前crash，那么会丢失最后一次备份之后的数据内容。在Redis中使用“save”命令或者等待配置文件中的指定时间内的数据修改量符合进行RDB存储。</p>
</li>
<li><p>AOF</p>
<p>AOF持久化以日志的形式记录服务器所处理的每一个写、删操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。也可以在后台对AOF进行重写，使得AOF文件的体积不会超出保存数据集状态所需的实际大小。它的特点是粒度较小，能够实时保存数据。</p>
</li>
</ol>
<p>默认使用的是RDB方式。</p>
<p>它们在配置文件中的描述为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############################## APPEND ONLY MODE ###############################</span></span><br><span class="line"><span class="comment"># AOF截取</span></span><br><span class="line">appendonly no <span class="comment">## 是否开启AOF模式，默认关闭</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span> <span class="comment">## 产生出来的备份文件默认名</span></span><br><span class="line">appendfsync everysec <span class="comment">## AOF执行频率</span></span><br><span class="line"><span class="comment"># save &quot;&quot; 关闭注释</span></span><br><span class="line"><span class="comment">################################ SNAPSHOTTING  ################################</span></span><br><span class="line"><span class="comment"># RDB截取</span></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000 <span class="comment">## save 时间间隔 被修改的数据量（若达到对应的被修改的数据量，在对应的时间间隔就会被备份）</span></span><br><span class="line"><span class="comment"># save &quot;&quot; #关闭注释可以关闭RDB</span></span><br><span class="line">dbfilename dump.rdb</span><br></pre></td></tr></table></figure>

<p>Redis可以同时开启AOF和RDB，这种情况下，当Redis重启的时候，会优先使用AOF文件来还原数据集，因为AOF文件保存的数据集通常比RDB文件所保存的数据集更为完整。也可以两个都关闭。</p>
<h2 id="选择标准"><a href="#选择标准" class="headerlink" title="选择标准"></a>选择标准</h2><p>如果牺牲一部分系统的性能，换取更高的的缓存一致性，那就选择AOF。</p>
<p>如果写操作频繁，使用RDB可以换取更高的系统性能。</p>
<h2 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h2><p>优点：</p>
<ol>
<li>RDB是一个非常紧凑的文件，它保存了Redis在某个时间点上的数据集。这种文件非常适用于备份，可以回退到保存的时间点上的数据集。适用于灾难恢复。</li>
<li>性能更高，父进程在保存RDB文件时唯一要做的就是fork出一个子进程，然后这个子进程会处理接下来的保存工作，父进程无须执行任何磁盘I/O操作。</li>
<li>RDB在回复大数据集时比AOF恢复得要快。</li>
</ol>
<p>缺点：</p>
<ol>
<li>如果服务端突然crash，会丢失最后一次保存之后的数据集。这也就不能够保证数据的缓存一致性。</li>
<li>每次保存数据的时候，Redis都会fork出一个子进程，让子进程自己进行实际的持久化操作。当数据集较为庞大的时候，fork可能会非常耗时，造成服务器停止处理客户端数据的情况。</li>
</ol>
<h2 id="AOF优缺点"><a href="#AOF优缺点" class="headerlink" title="AOF优缺点"></a>AOF优缺点</h2><p>优点：</p>
<ol>
<li>使用AOF可以设置不同的fsync策略，AOF默认策略为everysec（每秒执行一次），其他的策略还有Always（每写入一条指令就执行一次）、NO（由操作系统决定什么时候执行）。</li>
<li>会自动调整备份文件大小，当AOF文件大小达到一定程度的时候，后台会自动去执行AOF重写，此过程不会影响主进程，重写完成后，新的写入会写到新的AOF中，旧的会被删除。</li>
</ol>
<p>缺点：</p>
<ol>
<li>性能相对较差，它的操作模式决定了它会对Redis的性能有所损耗。</li>
<li>体积相对更大，尽管是将aof文件重写了，但是毕竟是操作过程和操作结果仍然由较大的差别，所以体积会更大。</li>
<li>恢复舒服略慢。</li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis事务</title>
    <url>/2020/11/13/Redis%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>我们所学过的事务是遵循一个ACID原则，也就是保证原子性、一致性、隔离性和持久性。</p>
<p>但是对于Redis来说，它的事务并不会保证原子性，和隔离性。</p>
<p>当出现运行时异常的错误语句时，其他语句依旧会成功执行。也就是说，Redis的单条语句具有原子性，但是它的事务却没有原子性。</p>
<p>Redis事务所具备的三个阶段：</p>
<ul>
<li>开始事务（multi）</li>
<li>输入命令，如果任意命令执行失败，其他命令依旧会被执行。</li>
<li>执行事务（exec）</li>
</ul>
<p>Redis事务具有以下命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>discard</td>
<td>取消事务，放弃执行事务块内的全部命令</td>
</tr>
<tr>
<td>exec</td>
<td>执行所有事务块内的命令</td>
</tr>
<tr>
<td>multi</td>
<td>被标记一个事务块的开始</td>
</tr>
<tr>
<td>unwatch</td>
<td>取消watch命令对所有key的监视</td>
</tr>
<tr>
<td>watch key…</td>
<td>监视一个或多个key，如果在事务执行前这个key被其他命令改动，那么就会打断事务</td>
</tr>
</tbody></table>
<h2 id="事务实例"><a href="#事务实例" class="headerlink" title="事务实例"></a>事务实例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br><span class="line">4) &quot;v3&quot;</span><br></pre></td></tr></table></figure>

<h3 id="Redis事务没有原子性的实例"><a href="#Redis事务没有原子性的实例" class="headerlink" title="Redis事务没有原子性的实例"></a>Redis事务没有原子性的实例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incr k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exce</span><br><span class="line">1) OK</span><br><span class="line">2) (error) ERR value is not an <span class="built_in">integer</span> or out of range</span><br><span class="line">3) <span class="string">&quot;v2&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="乐观锁实例"><a href="#乐观锁实例" class="headerlink" title="乐观锁实例"></a>乐观锁实例</h2><p>先说一下乐观锁与悲观锁的区别：</p>
<p>悲观锁：无论做什么都会先去加锁，只有加锁了才继续下一步操作。比较影响性能，一般用在重写数据量会造成较大损失的场景，保证数据不需要重写。</p>
<p>乐观锁：直接不加锁，记录下原来数据的值，当需要执行数据的时候就将原数据的值与记录下的数据的值进行比对，如果一致就说明没被修改过，接着正常执行语句。但是如果不一致说明有其他进程对数据进行了修改，不一致的情况就会抛弃掉之前所需要执行的操作。乐观锁性能很好，因为它不会对数据进行加锁操作造成阻塞状态。一般用在重写操作步骤能够接受的场景下。</p>
<p>在Redis中实现乐观锁就是通过<strong>watch</strong>命令进行操作的。watch和mysql中的vesion关键字一样，都是实现乐观锁的关键字。</p>
<p>演示一个乐观锁场景：</p>
<h3 id="正常执行"><a href="#正常执行" class="headerlink" title="正常执行"></a>正常执行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 1000</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> consume 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; decrby money 200</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incrby consume 200</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 800</span><br><span class="line">2) (<span class="built_in">integer</span>) 200</span><br></pre></td></tr></table></figure>

<h3 id="乐观锁触发场景"><a href="#乐观锁触发场景" class="headerlink" title="乐观锁触发场景"></a>乐观锁触发场景</h3><p>在执行一条事务的过程中，有其他的进程对被监视的数据进行了修改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 1000</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> consume 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; decrby money 200</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incrby consume 200</span><br><span class="line">QUEUED</span><br></pre></td></tr></table></figure>

<p>此时事务并没有执行完，出现另一个进程对数据进行了修改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get money</span><br><span class="line"><span class="string">&quot;1000&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incrby money 200</span><br><span class="line">(<span class="built_in">integer</span>) 1200</span><br></pre></td></tr></table></figure>

<p>数据被修改了之后再执行原来的事务，触发乐观锁。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 1000</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> consume 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; decrby money 200</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incrby consume 200</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的三种特殊类型</title>
    <url>/2020/11/13/Redis%E7%9A%84%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h2><p>Redis GEO 主要用于存储地理位置信息，并对存储的信息进行操作，该功能在 Redis 3.2 版本新增。</p>
<p>Zset命令同样适用。</p>
<p>Redis GEO 操作方法有六个，分别是：</p>
<ul>
<li>geoadd：添加地理位置的坐标。</li>
<li>geopos：获取地理位置的坐标。</li>
<li>geodist：计算两个位置之间的距离。</li>
<li>georadius：根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。</li>
<li>georadiusbymember：根据储存在位置集合里面的某个地点获取指定范围内的地理位置集合。</li>
<li>geohash：返回一个或多个位置对象的 geohash 值。</li>
</ul>
<h3 id="geoadd"><a href="#geoadd" class="headerlink" title="geoadd"></a>geoadd</h3><p>添加地理位置的坐标。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># geoadd key longitude latitude member...</span></span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 116.408 39.904 beijing</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 104.071 30.67 chengdu 121.445 31.213 shanghai</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 113.265 23.108 guangzhou 114.109 22.544 shenzhen</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>

<h3 id="geopos"><a href="#geopos" class="headerlink" title="geopos"></a>geopos</h3><p>获取地理位置的坐标，显示经度纬度。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># geopos key member...</span></span><br><span class="line">127.0.0.1:6379&gt; zrange china:city 0 -1</span><br><span class="line">1) <span class="string">&quot;chengdu&quot;</span></span><br><span class="line">2) <span class="string">&quot;shenzhen&quot;</span></span><br><span class="line">3) <span class="string">&quot;guangzhou&quot;</span></span><br><span class="line">4) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">5) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; geopos china:city chengdu shenzhen guangzhou</span><br><span class="line">1) 1) <span class="string">&quot;104.07099992036819458&quot;</span></span><br><span class="line">   2) <span class="string">&quot;30.67000055930392222&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;114.10900086164474487&quot;</span></span><br><span class="line">   2) <span class="string">&quot;22.54399882788700182&quot;</span></span><br><span class="line">3) 1) <span class="string">&quot;113.26500087976455688&quot;</span></span><br><span class="line">   2) <span class="string">&quot;23.10799963305151294&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="geodist"><a href="#geodist" class="headerlink" title="geodist"></a>geodist</h3><p>计算两个位置之间的距离。unit的单位可选取为m、km、mi、ft。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># geodist key member1 member2 unit</span></span><br><span class="line">127.0.0.1:6379&gt; geopos china:city chengdu beijing</span><br><span class="line">1) 1) <span class="string">&quot;104.07099992036819458&quot;</span></span><br><span class="line">   2) <span class="string">&quot;30.67000055930392222&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;116.40800267457962036&quot;</span></span><br><span class="line">   2) <span class="string">&quot;39.90399988166036138&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; geodist china:city chengdu beijing km</span><br><span class="line"><span class="string">&quot;1516.9099&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="georadius"><a href="#georadius" class="headerlink" title="georadius"></a>georadius</h3><p>georadius 以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。</p>
<p>一般用于实现功能：查找周围的人。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># georadius key longitude latitude radius unit [withcoord] [withdist] [count(num)]</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 100 30 500 km</span><br><span class="line">1) <span class="string">&quot;chengdu&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 100 30 500 km withcoord withdist count 2</span><br><span class="line">1) 1) <span class="string">&quot;chengdu&quot;</span></span><br><span class="line">   2) <span class="string">&quot;397.8245&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;104.07099992036819458&quot;</span></span><br><span class="line">      2) <span class="string">&quot;30.67000055930392222&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="georadiusbymember"><a href="#georadiusbymember" class="headerlink" title="georadiusbymember"></a>georadiusbymember</h3><p>georadiusbymember 和 GEORADIUS 命令一样， 都可以找出位于指定范围内的元素， 但是 georadiusbymember 的中心点是由给定的位置元素决定的， 而不是使用经度和纬度来决定中心点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># georadiusbymember key member radius unit [withcoord] [withdist] [count(num)]</span></span><br><span class="line">127.0.0.1:6379&gt; georadiusbymember china:city beijing 1500 km</span><br><span class="line">1) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">2) <span class="string">&quot;beijing&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="geohash"><a href="#geohash" class="headerlink" title="geohash"></a>geohash</h3><p>获取地址的hash值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># geohash</span></span><br><span class="line">127.0.0.1:6379&gt; geohash china:city shanghai beijing</span><br><span class="line">1) <span class="string">&quot;wtw3ed1sct0&quot;</span></span><br><span class="line">2) <span class="string">&quot;wx4g0bm9xh0&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><p> HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<ol>
<li>PFADD key element [element …]：添加指定元素到 HyperLogLog 中。</li>
<li>PFCOUNT key [key …]：返回给定 HyperLogLog 的基数估算值。</li>
<li>PFMERGE destkey sourcekey [sourcekey …]：将多个 HyperLogLog 合并为一个 HyperLogLog。</li>
</ol>
<h3 id="PFADD"><a href="#PFADD" class="headerlink" title="PFADD"></a>PFADD</h3><p>添加指定元素到 HyperLogLog 中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># PFADD key element [element ...\]</span></span><br><span class="line">127.0.0.1:6379&gt; PFADD name lehanbal hambaga ainstan lehanbal</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT name</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>

<h3 id="PFCOUNT"><a href="#PFCOUNT" class="headerlink" title="PFCOUNT"></a>PFCOUNT</h3><p>返回给定 HyperLogLog 的基数估算值。</p>
<p>同上。</p>
<h3 id="PFMERGE"><a href="#PFMERGE" class="headerlink" title="PFMERGE"></a>PFMERGE</h3><p>将多个 HyperLogLog 合并为一个 HyperLogLog。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PFADD name lehanbal hambaga ainstan lehanbal</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT name</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; PFADD othername lehanbal mother father</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT othername</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; PFMERGE name othername</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT name</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT othername</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>

<h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><p>位图数据结构。可用来做打卡统计。</p>
<p>具有3个指令：</p>
<ol>
<li>setbit：设置位图中的某一位。</li>
<li>getbit：获取位图中的某一位。</li>
<li>bitcount：统计位图中被设置的位数。</li>
</ol>
<h3 id="setbit"><a href="#setbit" class="headerlink" title="setbit"></a>setbit</h3><p>设置位图中的某一位。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># setbit key offset value</span></span><br><span class="line">127.0.0.1:6379&gt; setbit week 0 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit week 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit week 2 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit week 3 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit week 4 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit week 5 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit week 6 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<h3 id="getbit"><a href="#getbit" class="headerlink" title="getbit"></a>getbit</h3><p>获取位图中的某一位。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># getbit key offset</span></span><br><span class="line">127.0.0.1:6379&gt; getbit week 1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit week 4</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<h3 id="bitcount"><a href="#bitcount" class="headerlink" title="bitcount"></a>bitcount</h3><p>统计位图中被设置的位数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bitcount key [start] [end]</span></span><br><span class="line">127.0.0.1:6379&gt; bitcount week</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis五大数据类型</title>
    <url>/2020/11/11/Redis%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="SET-GET"><a href="#SET-GET" class="headerlink" title="SET GET"></a>SET GET</h3><p>set是通过设置一个key值来对应它的value值，这是最基本的操作指令了。</p>
<p>get这是通过key来获取它所对应的value值。</p>
<p>命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># set ‘set key value’</span></span><br><span class="line">127.0.0.1:6379&gt; SET name lehanbal</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># get ‘get key’</span></span><br><span class="line">127.0.0.1:6379&gt; GET name</span><br><span class="line"><span class="string">&quot;lehanbal&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="MSET-MGET"><a href="#MSET-MGET" class="headerlink" title="MSET MGET"></a>MSET MGET</h3><p>MSET是批量设置key，MGET是批量获取值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MGET name1 name2 name3 name4</span><br><span class="line">1) <span class="string">&quot;le&quot;</span></span><br><span class="line">2) <span class="string">&quot;leh&quot;</span></span><br><span class="line">3) <span class="string">&quot;leha&quot;</span></span><br><span class="line">4) <span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; MSET name5 1 name6 2 name 7</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MGET name1 name2 name3 name4 name5 name6 name7</span><br><span class="line">1) <span class="string">&quot;le&quot;</span></span><br><span class="line">2) <span class="string">&quot;leh&quot;</span></span><br><span class="line">3) <span class="string">&quot;leha&quot;</span></span><br><span class="line">4) <span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">5) <span class="string">&quot;1&quot;</span></span><br><span class="line">6) <span class="string">&quot;2&quot;</span></span><br><span class="line">7) (nil)</span><br></pre></td></tr></table></figure>

<p>注意这里面是保证原子性的，当其中某一项失败的时候，都是一起失败，具备原子性。</p>
<h3 id="APPEND"><a href="#APPEND" class="headerlink" title="APPEND"></a>APPEND</h3><p>通过key来找到对应的value内容，并将新的value值拼接在后面，会返回拼接好的字符串长度。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># APPEND key value</span></span><br><span class="line">127.0.0.1:6379&gt; APPEND name ,Yes!</span><br><span class="line">(<span class="built_in">integer</span>) 13</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;lehanbal,Yes!&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="STRLEN"><a href="#STRLEN" class="headerlink" title="STRLEN"></a>STRLEN</h3><p>通过key获取到value的长度。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># STRLEN key</span></span><br><span class="line">127.0.0.1:6379&gt; STRLEN name</span><br><span class="line">(<span class="built_in">integer</span>) 13</span><br></pre></td></tr></table></figure>

<h3 id="INCR-DECR"><a href="#INCR-DECR" class="headerlink" title="INCR DECR"></a>INCR DECR</h3><p>INCR命令能够对一个只有数值的字符串进行+1操作，若没有事先声明key的值，那么这个key会被赋值0然后进行增加操作。</p>
<p>DECR命令则反过来。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> num 2000</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get num</span><br><span class="line"><span class="string">&quot;2000&quot;</span></span><br><span class="line"><span class="comment"># INCR/DECR key</span></span><br><span class="line">127.0.0.1:6379&gt; incr num</span><br><span class="line">(<span class="built_in">integer</span>) 2001</span><br><span class="line">127.0.0.1:6379&gt; decr num</span><br><span class="line">(<span class="built_in">integer</span>) 2000</span><br></pre></td></tr></table></figure>

<h3 id="INCRBY-DECRBY"><a href="#INCRBY-DECRBY" class="headerlink" title="INCRBY DECRBY"></a>INCRBY DECRBY</h3><p>INCR和DECR的能够按步长进行增加或者减少的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># INCRBY/DECRBY key increment/decrement</span></span><br><span class="line">127.0.0.1:6379&gt; INCRBY num 5</span><br><span class="line">(<span class="built_in">integer</span>) 2005</span><br><span class="line">127.0.0.1:6379&gt; INCRBY num 5</span><br><span class="line">(<span class="built_in">integer</span>) 2010</span><br><span class="line">127.0.0.1:6379&gt; DECRBY num 4</span><br><span class="line">(<span class="built_in">integer</span>) 2006</span><br><span class="line">127.0.0.1:6379&gt; DECRBY num 4</span><br><span class="line">(<span class="built_in">integer</span>) 2002</span><br></pre></td></tr></table></figure>

<h3 id="GETRANGE"><a href="#GETRANGE" class="headerlink" title="GETRANGE"></a>GETRANGE</h3><p>获取一个字符串的区间内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># GETRANGE key start end</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name lehanbal,yes!</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; GETRANGE name 0 5</span><br><span class="line"><span class="string">&quot;lehanb&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="SETRANGE"><a href="#SETRANGE" class="headerlink" title="SETRANGE"></a>SETRANGE</h3><p>从字符串的偏移位置开始，替换后面的字符串内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SETRANGE key offest value</span></span><br><span class="line">127.0.0.1:6379&gt; SETRANGE name 7 ,NO!</span><br><span class="line">(<span class="built_in">integer</span>) 13</span><br><span class="line">127.0.0.1:6379&gt; GET name</span><br><span class="line"><span class="string">&quot;lehanba,NO!s!&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="SETEX-set-with-expire"><a href="#SETEX-set-with-expire" class="headerlink" title="SETEX(set with expire)"></a>SETEX(set with expire)</h3><p>设置一个key的同时自带过期时间。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SETEX key times value</span></span><br><span class="line">127.0.0.1:6379&gt; SETEX name 10 lehanbal</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<h3 id="SETNX-set-if-not-exist"><a href="#SETNX-set-if-not-exist" class="headerlink" title="SETNX(set if not exist)"></a>SETNX(set if not exist)</h3><p>如果没有当前key就设置当前key，返回1，否则失败，返回0.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SETNX key value</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name1 le</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name2 leh</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name3 leha</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name3&quot;</span></span><br><span class="line">2) <span class="string">&quot;name2&quot;</span></span><br><span class="line">3) <span class="string">&quot;name1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SETNX name1 lehanbal</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; SETNX name4 lehanbal</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get name1</span><br><span class="line"><span class="string">&quot;le&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get name4</span><br><span class="line"><span class="string">&quot;lehanbal&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="MSETNX"><a href="#MSETNX" class="headerlink" title="MSETNX"></a>MSETNX</h3><p>SETNX的批量赋值版本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MSETNX key1 value1 key2 value2 ...</span></span><br><span class="line">127.0.0.1:6379&gt; MSETNX n1 1 n2 2 n3 3 n4 4</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line"> 1) <span class="string">&quot;name5&quot;</span></span><br><span class="line"> 2) <span class="string">&quot;name1&quot;</span></span><br><span class="line"> 3) <span class="string">&quot;n2&quot;</span></span><br><span class="line"> 4) <span class="string">&quot;n4&quot;</span></span><br><span class="line"> 5) <span class="string">&quot;n1&quot;</span></span><br><span class="line"> 6) <span class="string">&quot;name6&quot;</span></span><br><span class="line"> 7) <span class="string">&quot;name4&quot;</span></span><br><span class="line"> 8) <span class="string">&quot;name&quot;</span></span><br><span class="line"> 9) <span class="string">&quot;name2&quot;</span></span><br><span class="line">10) <span class="string">&quot;name3&quot;</span></span><br><span class="line">11) <span class="string">&quot;n3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; MSETNX name 1 asdkjna jnaskjdn</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<p>原子操作，其中一个失败，全部都会失败。</p>
<p>更高阶一点的用法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过对:来区分用户的信息使用mget就能很方便的获取数据而不需要去解析json格式的文件</span></span><br><span class="line">127.0.0.1:6379&gt; mset user:1:name lehanbal user:1:age 24</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget user:1:name user:1:age</span><br><span class="line">1) <span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">2) <span class="string">&quot;24&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="GETSET"><a href="#GETSET" class="headerlink" title="GETSET"></a>GETSET</h3><p>先GET后SET，返回值是GET的值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET name lehanba</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; GETSET name lehanbal</span><br><span class="line"><span class="string">&quot;lehanba&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; GET name</span><br><span class="line"><span class="string">&quot;lehanbal&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>通过双向链表实现的存储。如果key不存在的话，就会创造新的链表，如果key存在，就会新增内容。</p>
<h3 id="LPUSH-RPUSH和LRANGE"><a href="#LPUSH-RPUSH和LRANGE" class="headerlink" title="LPUSH/RPUSH和LRANGE"></a>LPUSH/RPUSH和LRANGE</h3><p>向list集合中加入元素，LPUSH是从左边增加元素，而RPUSH则是向右边增加元素。</p>
<p>LRANGE则是按照相应的下标进行集合的遍历</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># LPUSH/RPUSH key value</span></span><br><span class="line">127.0.0.1:6379&gt; LPUSH list one</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list two</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; RPUSH list zero</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">4) <span class="string">&quot;zero&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="LPOP-RPOP"><a href="#LPOP-RPOP" class="headerlink" title="LPOP/RPOP"></a>LPOP/RPOP</h3><p>POP为弹出元素操作，返回值为弹出的元素，L和R分别表示从左边或从右边弹出。（操作接上）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># LPOP/RPOP key</span></span><br><span class="line">127.0.0.1:6379&gt; LPOP list</span><br><span class="line"><span class="string">&quot;three&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">3) <span class="string">&quot;zero&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; RPOP list</span><br><span class="line"><span class="string">&quot;zero&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="LINDEX"><a href="#LINDEX" class="headerlink" title="LINDEX"></a>LINDEX</h3><p>获取列表指定下标的元素，下标从0开始，和数组一样。（操作接上）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># LINDEX key index</span></span><br><span class="line">127.0.0.1:6379&gt; LINDEX list 0</span><br><span class="line"><span class="string">&quot;two&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LINDEX list 1</span><br><span class="line"><span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LINDEX list 2</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<h3 id="LLEN"><a href="#LLEN" class="headerlink" title="LLEN"></a>LLEN</h3><p>获取当前列表的长度。（操作接上）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># LLEN key</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LLEN list</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>

<h3 id="LREM"><a href="#LREM" class="headerlink" title="LREM"></a>LREM</h3><p>从左边开始删除列表中指定数量的指定值元素。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># LREM key start end</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">4) <span class="string">&quot;one&quot;</span></span><br><span class="line">5) <span class="string">&quot;two&quot;</span></span><br><span class="line">6) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LREM list 2 one</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">3) <span class="string">&quot;two&quot;</span></span><br><span class="line">4) <span class="string">&quot;one&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="LTRIM"><a href="#LTRIM" class="headerlink" title="LTRIM"></a>LTRIM</h3><p>分割当前列表，保留下从开始下标到结束下标的元素。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># LTRIM key start end</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">3) <span class="string">&quot;two&quot;</span></span><br><span class="line">4) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LTRIM list 0 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">3) <span class="string">&quot;two&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="RPOPLPUSH"><a href="#RPOPLPUSH" class="headerlink" title="RPOPLPUSH"></a>RPOPLPUSH</h3><p>组合操作，先弹出元素，将弹出的元素压入对应的列表中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RPOPLPUSH source destination</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">3) <span class="string">&quot;two&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list1 0 -1</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">127.0.0.1:6379&gt; RPOPLPUSH list list1</span><br><span class="line"><span class="string">&quot;two&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list1 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="LSET"><a href="#LSET" class="headerlink" title="LSET"></a>LSET</h3><p>替换掉指定位置的元素。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># LRANGE key index value</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LSET list 0 three</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="LINSERT"><a href="#LINSERT" class="headerlink" title="LINSERT"></a>LINSERT</h3><p>将元素插入到列表中，可以根据before或after将元素插入在指定元素的前面或后面。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># LINSERT key AFTER/BEFORE start end</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LINSERT list BEFORE three four</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;four&quot;</span></span><br><span class="line">2) <span class="string">&quot;three&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LINSERT list AFTER three two</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;four&quot;</span></span><br><span class="line">2) <span class="string">&quot;three&quot;</span></span><br><span class="line">3) <span class="string">&quot;two&quot;</span></span><br><span class="line">4) <span class="string">&quot;one&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set也是一个集合，和java的set一样，不能够存储重复元素。</p>
<h3 id="SADD"><a href="#SADD" class="headerlink" title="SADD"></a>SADD</h3><p>向Set集合中添加一个元素。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SADD key members...</span></span><br><span class="line">127.0.0.1:6379&gt; SADD <span class="built_in">set</span> lehanbal</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SADD <span class="built_in">set</span> hello</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SADD <span class="built_in">set</span> man</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<h3 id="SMEMBERS"><a href="#SMEMBERS" class="headerlink" title="SMEMBERS"></a>SMEMBERS</h3><p>查看当前Set集合的所有元素。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SMEMBERS key</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS <span class="built_in">set</span></span><br><span class="line">1) <span class="string">&quot;man&quot;</span></span><br><span class="line">2) <span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="SISMEMBER"><a href="#SISMEMBER" class="headerlink" title="SISMEMBER"></a>SISMEMBER</h3><p>查看当前元素是否在改集合中。存在则返回1，不存在则返回0。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SISMENBER key value</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS <span class="built_in">set</span></span><br><span class="line">1) <span class="string">&quot;man&quot;</span></span><br><span class="line">2) <span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER <span class="built_in">set</span> lehanbal</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER <span class="built_in">set</span> lehanbal??</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<h3 id="SCARD"><a href="#SCARD" class="headerlink" title="SCARD"></a>SCARD</h3><p>获取Set集合中的元素个数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SCARD key</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS <span class="built_in">set</span></span><br><span class="line">1) <span class="string">&quot;man&quot;</span></span><br><span class="line">2) <span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SCARD <span class="built_in">set</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>

<h3 id="SREM"><a href="#SREM" class="headerlink" title="SREM"></a>SREM</h3><p>移除集合中的指定元素。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SREM key value...</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS <span class="built_in">set</span></span><br><span class="line">1) <span class="string">&quot;man&quot;</span></span><br><span class="line">2) <span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SREM <span class="built_in">set</span> man</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS <span class="built_in">set</span></span><br><span class="line">1) <span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="SRANDMEMBER"><a href="#SRANDMEMBER" class="headerlink" title="SRANDMEMBER"></a>SRANDMEMBER</h3><p>随机抽选出指定个数的元素。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SRANDMEMBER key [num]</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS <span class="built_in">set</span></span><br><span class="line">1) <span class="string">&quot;hambaga&quot;</span></span><br><span class="line">2) <span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">3) <span class="string">&quot;le&quot;</span></span><br><span class="line">4) <span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER <span class="built_in">set</span></span><br><span class="line"><span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER <span class="built_in">set</span></span><br><span class="line"><span class="string">&quot;hambaga&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER <span class="built_in">set</span> 2</span><br><span class="line">1) <span class="string">&quot;hambaga&quot;</span></span><br><span class="line">2) <span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER <span class="built_in">set</span> 2</span><br><span class="line">1) <span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="SPOP"><a href="#SPOP" class="headerlink" title="SPOP"></a>SPOP</h3><p>随机弹出指定个数元素。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SPOP key [num]</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS <span class="built_in">set</span></span><br><span class="line">1) <span class="string">&quot;hambaga&quot;</span></span><br><span class="line">2) <span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">3) <span class="string">&quot;le&quot;</span></span><br><span class="line">4) <span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SPOP <span class="built_in">set</span></span><br><span class="line"><span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SPOP <span class="built_in">set</span></span><br><span class="line"><span class="string">&quot;hambaga&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS <span class="built_in">set</span></span><br><span class="line">1) <span class="string">&quot;le&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="SMOVE"><a href="#SMOVE" class="headerlink" title="SMOVE"></a>SMOVE</h3><p>将一个指定的元素移动到另外一个Set集合中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SMOVE source destination member</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS <span class="built_in">set</span></span><br><span class="line">1) <span class="string">&quot;le&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SMOVE <span class="built_in">set</span> set1 le</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS <span class="built_in">set</span></span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS set1</span><br><span class="line">1) <span class="string">&quot;le&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="SDIFF-SINTER-SUNION"><a href="#SDIFF-SINTER-SUNION" class="headerlink" title="SDIFF SINTER SUNION"></a>SDIFF SINTER SUNION</h3><p>SDIFF：求若干个Set集合的差集，以第一个Set集合为基准。</p>
<p>SINTER：求若干个Set集合的交集。</p>
<p>SUNION：求若干个Set集合的并集。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SDIFF key1 key2...</span></span><br><span class="line"><span class="comment"># SINTER key1 key2...</span></span><br><span class="line"><span class="comment"># SUNION key1 key2...</span></span><br><span class="line">127.0.0.1:6379&gt; SADD set1 a b c d</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; SADD set2 c d e f g</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; SDIFF set1 set2</span><br><span class="line">1) <span class="string">&quot;b&quot;</span></span><br><span class="line">2) <span class="string">&quot;a&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SINTER set1 set2</span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">2) <span class="string">&quot;d&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SUNION set1 set2</span><br><span class="line">1) <span class="string">&quot;b&quot;</span></span><br><span class="line">2) <span class="string">&quot;a&quot;</span></span><br><span class="line">3) <span class="string">&quot;e&quot;</span></span><br><span class="line">4) <span class="string">&quot;g&quot;</span></span><br><span class="line">5) <span class="string">&quot;c&quot;</span></span><br><span class="line">6) <span class="string">&quot;f&quot;</span></span><br><span class="line">7) <span class="string">&quot;d&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>redis中的map集合，和java中的map集合一样。也就是说相当于key-key-value形式存储。</p>
<h3 id="HSET-HGET-HMSET-HMGET-HGETALL"><a href="#HSET-HGET-HMSET-HMGET-HGETALL" class="headerlink" title="HSET HGET HMSET HMGET HGETALL"></a>HSET HGET HMSET HMGET HGETALL</h3><p>HSET：设置一个hash值。</p>
<p>HGET：获取一个hash值。</p>
<p>HMSET：批量设置hash值。</p>
<p>HMGET：批量获取hash值。</p>
<p>HGETALL：获取全部的hash值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># HSET key field value</span></span><br><span class="line"><span class="comment"># HGET key field</span></span><br><span class="line"><span class="comment"># HMSET key field value...</span></span><br><span class="line"><span class="comment"># HMGET key field ...</span></span><br><span class="line"><span class="comment"># HGETALL key</span></span><br><span class="line">127.0.0.1:6379&gt; HSET key1 name lehanbal</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HSET key1 age 24</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HSET key1 porfession student</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HGET key1 name</span><br><span class="line"><span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HGET key1 age</span><br><span class="line"><span class="string">&quot;24&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HGET key1 porfession</span><br><span class="line"><span class="string">&quot;student&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HGETALL key1</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">3) <span class="string">&quot;age&quot;</span></span><br><span class="line">4) <span class="string">&quot;24&quot;</span></span><br><span class="line">5) <span class="string">&quot;porfession&quot;</span></span><br><span class="line">6) <span class="string">&quot;student&quot;</span></span><br></pre></td></tr></table></figure>

<p>HMSET、HMGET、HMSETNX就不演示了，与String一致。</p>
<h3 id="HDEL"><a href="#HDEL" class="headerlink" title="HDEL"></a>HDEL</h3><p>删除hash元素里面的一个字段。字段被删除了，对应的value也会被删除。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># HDEL key field</span></span><br><span class="line">127.0.0.1:6379&gt; HDEL key1 porfession</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HGETALL key1</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">3) <span class="string">&quot;age&quot;</span></span><br><span class="line">4) <span class="string">&quot;24&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="HLEN"><a href="#HLEN" class="headerlink" title="HLEN"></a>HLEN</h3><p>获取当前hash元素的键值长度。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># HLEN key</span></span><br><span class="line">127.0.0.1:6379&gt; HGETALL key1</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">3) <span class="string">&quot;age&quot;</span></span><br><span class="line">4) <span class="string">&quot;24&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HLEN key1</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>

<h3 id="HEXISTS"><a href="#HEXISTS" class="headerlink" title="HEXISTS"></a>HEXISTS</h3><p>判断hash中指定的字段是否存在。存在返回1，不存在返回0。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># HEXISTS key field</span></span><br><span class="line">127.0.0.1:6379&gt; HGETALL key1</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">3) <span class="string">&quot;age&quot;</span></span><br><span class="line">4) <span class="string">&quot;24&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HEXISTS key1 name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS key1 nnnn</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<h3 id="HKEYS-HVALS"><a href="#HKEYS-HVALS" class="headerlink" title="HKEYS HVALS"></a>HKEYS HVALS</h3><p>获取hash的全部字段。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># HKEYS key</span></span><br><span class="line"><span class="comment"># HVALS key</span></span><br><span class="line">127.0.0.1:6379&gt; HGETALL key1</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">3) <span class="string">&quot;age&quot;</span></span><br><span class="line">4) <span class="string">&quot;24&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HKEYS key1</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HVALS key1</span><br><span class="line">1) <span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">2) <span class="string">&quot;24&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h2><p>一个有序集合，在set的基础上增加了一个值。作为权重值来进行排序。</p>
<h3 id="ZADD"><a href="#ZADD" class="headerlink" title="ZADD"></a>ZADD</h3><p>Zset添加元素操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ZADD key score member</span></span><br><span class="line">127.0.0.1:6379&gt; ZADD key 500 lehanbal</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ZADD key 1000 LE</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<h3 id="ZRANGE"><a href="#ZRANGE" class="headerlink" title="ZRANGE"></a>ZRANGE</h3><p>Zset的遍历操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ZRANGE key start end</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE key 0 -1</span><br><span class="line">1) <span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">2) <span class="string">&quot;LE&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="ZRANGEBYSCORE"><a href="#ZRANGEBYSCORE" class="headerlink" title="ZRANGEBYSCORE"></a>ZRANGEBYSCORE</h3><p>将元素按照权重从小到大排序。可以通过min与max排序显示这个区间的元素。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ZRANGEBYSCORE key min max [withscores]</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE key -inf +inf withscores</span><br><span class="line">1) <span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">2) <span class="string">&quot;500&quot;</span></span><br><span class="line">3) <span class="string">&quot;LE&quot;</span></span><br><span class="line">4) <span class="string">&quot;1000&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="ZREVRANGEBYSCORE"><a href="#ZREVRANGEBYSCORE" class="headerlink" title="ZREVRANGEBYSCORE"></a>ZREVRANGEBYSCORE</h3><p>将元素按权重从大到小排序。同上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ZREVRANGE</span></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE key 0 -1 withscores</span><br><span class="line">1) <span class="string">&quot;LE&quot;</span></span><br><span class="line">2) <span class="string">&quot;1000&quot;</span></span><br><span class="line">3) <span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">4) <span class="string">&quot;500&quot;</span></span><br><span class="line"><span class="comment"># ZREVRANGEBYSCORE key max min [score]</span></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGEBYSCORE key +inf -inf withscores</span><br><span class="line">1) <span class="string">&quot;LE&quot;</span></span><br><span class="line">2) <span class="string">&quot;1000&quot;</span></span><br><span class="line">3) <span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">4) <span class="string">&quot;500&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="ZREM"><a href="#ZREM" class="headerlink" title="ZREM"></a>ZREM</h3><p>移除Zset的元素。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ZREM key value</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE key 0 -1</span><br><span class="line">1) <span class="string">&quot;hambaga&quot;</span></span><br><span class="line">2) <span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">3) <span class="string">&quot;LE&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZREM key hambaga</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE key 0 -1</span><br><span class="line">1) <span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">2) <span class="string">&quot;LE&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="ZCOUNT"><a href="#ZCOUNT" class="headerlink" title="ZCOUNT"></a>ZCOUNT</h3><p>统计区间内的数量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ZCOUNT </span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE key 0 -1</span><br><span class="line">1) <span class="string">&quot;lehanbal&quot;</span></span><br><span class="line">2) <span class="string">&quot;LE&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT key 0 999</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT key 0 1000</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>GC过程</title>
    <url>/2020/11/03/GC%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="jvm内存回收算法"><a href="#jvm内存回收算法" class="headerlink" title="jvm内存回收算法"></a>jvm内存回收算法</h2><ol>
<li>引用计数法：如果有地方引用该对象，那么该对象的引用计数+1。引用失效就-1。为0的对象不可以被使用。</li>
<li>可达性分析：如果我们将一些GCRoots对象作为起点，从这些节点向下搜索，搜索的路径为引用链，如果有一些对象没有任何引用链相连，那么就说明这个对象对于GCRoots是不可达的。所以将其判定为可回收对象。</li>
</ol>
<p>如果两个对象互相引用，引用计数法无法判定其死亡，所以JVM使用的是可达性分析算法。</p>
<h2 id="什么可以作为GCRoots"><a href="#什么可以作为GCRoots" class="headerlink" title="什么可以作为GCRoots"></a>什么可以作为GCRoots</h2><ul>
<li>java虚拟机栈中的引用对象。</li>
<li>方法区中的类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI引用的对象。</li>
</ul>
<h2 id="处理的GC算法"><a href="#处理的GC算法" class="headerlink" title="处理的GC算法"></a>处理的GC算法</h2><ul>
<li><strong>标记-清理法</strong>：通过GCRoots的可达性分析，将能够达到的节点都加上一个标记，进行遍历过后，会将没有标记的节点进行资源回收。缺点是会产生内存碎片，不能够更好的利用内存空间，</li>
<li><strong>标记-整理法</strong>：如果下一个内存是空的，就移动后面的数据，占据空内存的位置，压缩空间，减少内存碎片。缺点是性能开销过大，因为需要移动全部的内存。</li>
<li><strong>复制算法</strong>：将内存一分为二（假设a内存和b内存），a内存中被标记了的元素，紧凑的复制到b内存中，避免了产生过多的内存碎片和性能开销过大的问题，但是缺点是需要两倍的内存空间。（拿空间换时间的意思）</li>
</ul>
<h2 id="实际的GC过程"><a href="#实际的GC过程" class="headerlink" title="实际的GC过程"></a>实际的GC过程</h2><p><img src="http://cdn.lehanbal.top/image-20201103211825342.png" alt="image-20201103211825342"></p>
<ol>
<li><p>将内存进行了划分，划分为新生代（young）和老年代（old）。</p>
</li>
<li><p>将新生代继续划分，划分成Eden区（伊甸园区）和2个Survivor区（s0和s1）；老年代则是一整块区域。</p>
</li>
<li><p>new对象产生在伊甸园区，当伊甸园区快慢的时候会触发GC，这个GC是发生在Young区的，所以也叫YoungGC，YoungGC使用的是复制算法，在伊甸园区需要复制的节点做上一个标记，标记了的节点会被复制到Survivor区（s0或s1均可，内存大小为 s0:s1:Eden = 1:1:8）。</p>
<p>至于为什么需要两块Survivor区？因为这两块区域是交替工作的，在E区标记完后，活下来的元素被放到s0，然后将s1和Eden区的节点一起GC了，等到下一次GC的时候，将s0和Eden区进行一次标记，然后再将活下来的元素复制到s1，然后将s0和Eden区的元素删除，如此反复。（针对一些朝生夕死的特点设计的）。</p>
</li>
<li><p>每次触发YoungGC，活下来的元素年龄都会加1，直到年龄到了15（这个界限可调整），他就不在Survivor区复制了，直接将不需要删除的对象放到Old区里，因为他活了很久，说明很可能是重要的引用对象，需要很久才会被做掉；老年代除了存放年龄大于15岁的对象，还会存放大的对象，当Old区满的时候也会触发GC，这个叫OldGC，一般会触发YoungGC，所以也叫FullGC，此时会发生Stop-The-World，整个Java程序暂停，全力协助GC。</p>
</li>
<li><p>标记-清理算法、标记-整理算法主要发生在old区；复制算法主要发生在Young区。</p>
</li>
</ol>
<h2 id="比较著名的垃圾收集器"><a href="#比较著名的垃圾收集器" class="headerlink" title="比较著名的垃圾收集器"></a>比较著名的垃圾收集器</h2><ul>
<li><p>新生代：Serial、ParNew（Serial的多线程版本）、Parallel Scavenge（关注吞吐率）</p>
</li>
<li><p>老年代：serial Old、CMS、Parallel Old</p>
</li>
</ul>
<p><strong>一般</strong>新生代和老年代的垃圾收集器是按照Serial与Serial Old做组合、ParNew和CMS做组合、Parallel Scavenge和Parallel Old做组合。</p>
<p>最新的垃圾收集器G1（Garbege First）。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>GC</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存模型</title>
    <url>/2020/11/03/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>推荐视频：<a href="https://www.bilibili.com/video/BV12t411u726">【java】jvm内存模型全面解析</a></p>
<h2 id="区域划分"><a href="#区域划分" class="headerlink" title="区域划分"></a>区域划分</h2><p>JVM内存模型分为5个区：</p>
<ol>
<li>Java虚拟机栈</li>
<li>本地方法栈</li>
<li>程序计数器</li>
<li>堆</li>
<li>方法区（元空间）</li>
</ol>
<p><img src="http://cdn.lehanbal.top/image-20201103174600198.png" alt="image-20201103174600198"></p>
<h2 id="各区域的作用"><a href="#各区域的作用" class="headerlink" title="各区域的作用"></a>各区域的作用</h2><ol>
<li><p>Java虚拟机栈:</p>
<p>用于存储变量表、操作数栈、动态链接和方法出口等信息。（栈内存储的引用信息是地址，实际指向的是堆里面的对象）</p>
</li>
<li><p>本地方法栈：</p>
<p>用于管理本地方法的调用，由native修饰，调用C和C++的相关内容。</p>
</li>
<li><p>程序计数器：</p>
<p>它是一块很小的内存空间，主要记录各个线程执行的字节码地址，例如分支、循环、线程恢复都依赖于计数器。</p>
</li>
<li><p>堆：</p>
<p>Java虚拟机中内存最大的一块，被所有线程共享，几乎所有对象实例都会在堆里面分配内存，堆当中还有常量池，用于存储堆当中的常量。</p>
</li>
<li><p>方法区（元空间）：</p>
<p>用于存放已经被虚拟机加载的类信息、常量和<strong>静态变量</strong>等数据。（静态的内容存放的地方）</p>
</li>
</ol>
<h2 id="线程私有与公有"><a href="#线程私有与公有" class="headerlink" title="线程私有与公有"></a>线程私有与公有</h2><ul>
<li>私有：每个线程在开辟、运行的过程中都会单独创建这样的一份内存。java虚拟机栈、本地方法栈、程序计数器。</li>
<li>公有：线程全局共享。堆和方法区。</li>
</ul>
<h2 id="关于垃圾回收"><a href="#关于垃圾回收" class="headerlink" title="关于垃圾回收"></a>关于垃圾回收</h2><p>栈在方法运行完毕后会被清空，但是堆上的内容不会被清空，所以就引出了GC回收，不能马上删除，因为不清楚是否还有其他对象的指向引用。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU的JAVA的双向链表实现</title>
    <url>/2020/10/30/LRU%E7%9A%84JAVA%E7%9A%84%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>LRU（Least Recently Used）最近最久未使用，一种页面置换算法。</p>
<p>这里使用了双向链表实现，head表示队尾当中最后的进程，而tail则表示刚刚被使用的进程。通过移动节点的位置模拟被使用的过程。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Lehanbal.Algorithms.Base;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Node pre;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = k;</span><br><span class="line">            <span class="keyword">this</span>.val = v;</span><br><span class="line">            <span class="keyword">this</span>.pre = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;key=&quot;</span> + key +</span><br><span class="line">                    <span class="string">&quot;, val=&quot;</span> + val +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 手写双端队列，队头是不常使用的元素，队尾是刚刚使用的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DequeList</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Node head;</span><br><span class="line">        <span class="keyword">public</span> Node tail;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DequeList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.tail = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将元素移动到尾部（刚刚使用过）</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveToTail</span><span class="params">(Node n)</span></span>&#123;</span><br><span class="line">            <span class="comment">//如果元素为空或者已经在尾巴了，就不要动了</span></span><br><span class="line">            <span class="keyword">if</span>(n == <span class="keyword">null</span> || n == tail) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//如果元素在头的地方，那就让头节点往后面移动一位，并且将头节点前面的元素置空</span></span><br><span class="line">            <span class="keyword">if</span>(head == n)&#123;</span><br><span class="line">                head = n.next;</span><br><span class="line">                head.pre = <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果在中间的位置，那就让元素的前驱结点直接指向后继节点（这里是为了让n节点的前驱后继都越过n，把n空出来）</span></span><br><span class="line">                n.pre.next = n.next;</span><br><span class="line">                n.next.pre = n.pre;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把n放到tail后面，再移动tail到n的位置，注意写法，防止内存泄漏</span></span><br><span class="line">            tail.next = n;</span><br><span class="line">            n.pre = tail;</span><br><span class="line">            n.next = <span class="keyword">null</span>;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 添加新节点</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToTail</span><span class="params">(Node n)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">                head = n;</span><br><span class="line">                tail = n;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tail.next = n;</span><br><span class="line">                n.pre = tail;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 删除最近最久未使用节点</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 返回删除的节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Node <span class="title">removeHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            Node n = head;</span><br><span class="line">            <span class="keyword">if</span>(head == tail)&#123;</span><br><span class="line">                head = <span class="keyword">null</span>;</span><br><span class="line">                tail = <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">                head.pre = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Node&gt; <span class="title">trave</span><span class="params">()</span></span>&#123;</span><br><span class="line">            List&lt;Node&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            Node iter = tail;</span><br><span class="line">            <span class="keyword">while</span>(iter != <span class="keyword">null</span>)&#123;</span><br><span class="line">                res.add(iter);</span><br><span class="line">                iter = iter.pre;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DequeList list;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.list = <span class="keyword">new</span> DequeList();</span><br><span class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        Node n = map.get(key);</span><br><span class="line">        list.moveToTail(n);</span><br><span class="line">        <span class="keyword">return</span> n.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(key))&#123;</span><br><span class="line">            Node n = <span class="keyword">new</span> Node(key, val);</span><br><span class="line">            map.put(key, n);</span><br><span class="line">            list.addToTail(n);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(map.size() &gt; capacity)&#123;</span><br><span class="line">                Node rm = list.removeHead();</span><br><span class="line">                map.remove(rm.key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Node n = map.get(key);</span><br><span class="line">            n.val = val;</span><br><span class="line">            list.moveToTail(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traveList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Node&gt; trave = list.trave();</span><br><span class="line">        System.out.println(trave);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test07</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LRUCache LRU = <span class="keyword">new</span> LRUCache(<span class="number">5</span>);</span><br><span class="line">    LRU.put(<span class="number">1</span>,<span class="number">1001</span>);</span><br><span class="line">    LRU.put(<span class="number">2</span>,<span class="number">1002</span>);</span><br><span class="line">    LRU.put(<span class="number">3</span>,<span class="number">1003</span>);</span><br><span class="line">    LRU.put(<span class="number">4</span>,<span class="number">1004</span>);</span><br><span class="line">    LRU.put(<span class="number">5</span>,<span class="number">1005</span>);</span><br><span class="line">    LRU.put(<span class="number">1</span>,<span class="number">1002</span>);</span><br><span class="line">    LRU.put(<span class="number">7</span>,<span class="number">1007</span>);</span><br><span class="line">    LRU.traveList();</span><br><span class="line">    LRU.get(<span class="number">3</span>);</span><br><span class="line">    LRU.traveList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://cdn.lehanbal.top/image-20201030234723878.png" alt="image-20201030234723878"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>JAVA</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>IO多路复用解析</title>
    <url>/2020/10/29/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>目前I/O多路复用的系统调用有select、poll和epoll，I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读写），就能够通知程序进行相应的读写操作。但是刚刚提到的这些个系统调用本质上都是同步I/O，因为它们都需要在读写时间就绪后自己负责读写，因此这个读写过程是阻塞的，而异步I/O是不需要自己负责读写，异步I/O的思想会负责把数据从内核态拷贝到用户态。（但是频繁的切换上下文会导致系统性能开销）</p>
<p>与多线程、多进程技术相比。I/O多路复用的最大优势就是系统开销小，系统不需要创建进程/线程，也不必维护它们，这样能减少很多系统开销。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>I/O多路复用是指内核一旦发现进程指定的一个或多个I/O条件准备进行读写操作，就会通知进程。I/O多路复用适用如下场景。</p>
<ol>
<li>但客户处理多个描述符（多个Socket和交互式输入）。</li>
<li>服务器同时处理TCP和UDP。</li>
<li>服务器同时处理多个服务和多个协议。</li>
<li>TCP服务器既需要继续监听，有需要处理已连接的套接字。</li>
</ol>
<h2 id="select、poll和epoll"><a href="#select、poll和epoll" class="headerlink" title="select、poll和epoll"></a>select、poll和epoll</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>基本上所有的操作系统都支持select方法，这个方法是阻塞的。select维护一个数组存储监听的进程的数组，每个数组元素代表单个进程，但是select监听文件描述符的数量是有最大限制的，Linux上一般是1024，虽然可以修改但是仍然使它的一个致命缺点。</p>
<p>之后维持一个新的数组fd_set（实际上是bitmap）来代表每个描述符是否被更改。select会将修改的描述符通过对fd_set置零置一来实现。程序运行select的时候是在用户态进行操作，但是判断每个程序是否有数据的时候是将fd_set拷贝到了内核态，交给内核进行判定，有一次内核态和用户态的切换。</p>
<p>总结一下：</p>
<ol>
<li>select方法设定的fd_set（bitmap）有大小限制。</li>
<li>fd_set不可重用，有新的数据进来就需要重新创建一次。</li>
<li>因为需要重新创建fd_set，所以有一个O(N)时间复杂度的轮询。</li>
<li>其中有一次用户态到内核态的切换，会造成内系统开销。</li>
</ol>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll和select的区别并不是很大，但是poll方法使用了一个结构体存储fd</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">short</span> events;</span><br><span class="line">	<span class="keyword">short</span> revents; <span class="comment">//可重用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这也就解决了select这个中的1问题（因为结构体比bitmap大多了）。events是监听所要做的事件（一般是读和写），而revents则是通知进程数据来了的一个标识量。</p>
<p>但revents 和 events一致时候就说明监听的接口要读/写，进行读写操作的同时将revents复位即可实现重复监听，不需要继续去遍历进程来重新设定标识位。也就解决了2的问题。</p>
<p>但是它依旧执行了一次从用户态切换到内核态的过程，并且在进行数据处理的时候依旧是进行了一次遍历，仍是O(N)时间复杂度。</p>
<p>它没有最大连接数的限制，<code>原因是它是基于链表来存储的</code>，但是同样有一个缺点：</p>
<ol>
<li>大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。</li>
<li>poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</li>
</ol>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>最新的一种I/O多路复用函数。是select和poll的增强版本。epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>
<p>epoll在进行判断描述符状态的时候，用户态和内核态共享一片内存空间，没有进行用户态到内核态的切换，解决了4的问题，并且在内核进行描述符判断的时候，会讲被修改的描述符进行一个排序，使他们有序的排列在前，这样一来就不需要轮询便能够实现对描述符的确认。将时间复杂度降到了O(1)。</p>
<p>总结：</p>
<ol>
<li><p>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。</p>
</li>
<li><p>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。</p>
<p>只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</p>
</li>
<li><p>内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</p>
</li>
</ol>
<p>epoll对文件描述符的操作有两种模式：<code>LT（level trigger）和ET（edge trigger）</code>。LT模式是默认模式，LT模式与ET模式的区别如下：</p>
<p>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序可以不立即处理该事件</code>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</p>
<p>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序必须立即处理该事件</code>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>
<p><strong>1、LT模式</strong></p>
<p><code>　　LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket</code>。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。<code>如果你不作任何操作，内核还是会继续通知你的</code>。</p>
<p><strong>2、ET模式</strong></p>
<p>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)。</p>
<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<p>在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。(此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是epoll的魅力所在。)</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈PriorityQueue</title>
    <url>/2020/10/29/%E8%B0%88%E8%B0%88PriorityQueue/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>我们需要清楚的一个概念，<strong>什么是队列</strong></p>
<p>百度百科：</p>
<p>队列是一种特殊的<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A1%A8/3228081">线性表</a>，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</p>
<p>换成一句话就是，是一个能够元素先进先出的数据结构。</p>
<p>一般的队列并不会对存储的元素下手，只会按照他们的先后入队顺序存储他们的位置。</p>
<p>清楚了这个，我们再来说一下PriorityQueue这个队列。</p>
<p>标准定义：</p>
<p>PriorityQueue类在Java1.5中引入。PriorityQueue是基于优先堆的一个无界队列，这个优先队列中的元素可以默认自然排序或者通过提供的Comparator（比较器）在队列实例化的时排序。要求使用Java Comparable和Comparator接口给对象排序，并且在排序时会按照优先级处理其中的元素。</p>
<p>PriorityQueue是一个优先级队列，也就是说他会按照一定的规律将内部存储的数据进行排序，我们可以提供Comparator来定义我们的排序形式。</p>
<p>举个例子：</p>
<p>现在该队列里有1 3 5，现在往里面插入 2，该队列的元素顺序会变成1 2 3 5。</p>
<p><strong>会自动排序的队列！</strong></p>
<h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><p>底层就是一颗二叉堆。</p>
<p><strong>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</strong>  </p>
<p><strong>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</strong>  </p>
<p>二叉堆具备以下特点：</p>
<ol>
<li>二叉堆是一个完全二叉树。</li>
<li>根节点总是大于左右节点（大顶堆），或者小于左右节点（小顶堆）。</li>
</ol>
<p>我们向堆内插入数据是自低向上插入</p>
<p>我来模拟一下排序过程：</p>
<p>先是随便整个完全二叉树</p>
<p><img src="http://cdn.lehanbal.top/%E5%A4%A7%E9%A1%B6%E5%A0%86.png" alt="大顶堆"></p>
<p>好！他很乱！</p>
<p>从底部开始！</p>
<p><img src="http://cdn.lehanbal.top/%E5%A4%A7%E9%A1%B6%E5%A0%86%E7%9A%84%E5%AD%90%E8%8A%82%E7%82%B9.png" alt="大顶堆的子节点"></p>
<p>给他按照相关规则排序！</p>
<p><img src="http://cdn.lehanbal.top/%E5%A4%A7%E9%A1%B6%E5%A0%86%E6%8E%92%E5%BA%8F1.png" alt="大顶堆排序1"></p>
<p>好！该节点完事，下一个节点！</p>
<p><img src="http://cdn.lehanbal.top/%E5%A4%A7%E9%A1%B6%E5%A0%86%E7%9A%84%E5%AD%90%E8%8A%82%E7%82%B91.png" alt="大顶堆的子节点1"></p>
<p>继续排序！</p>
<p><img src="http://cdn.lehanbal.top/%E5%A4%A7%E9%A1%B6%E5%A0%86%E6%8E%92%E5%BA%8F2.png" alt="大顶堆排序2"></p>
<p>排序完毕。</p>
<p>但是这只是一个比较凑巧的情况，如果顶部的68被换到左子树上，并且比左子树上的左右子树还要小的话怎么办呢？</p>
<p><del>因为例子没有出现所以不讨论</del></p>
<p>这时候就需要对这个子堆再进行一次堆排序，也就是说，如果我们对堆顶的元素位置改变了，那么我们就需要递归的去对他的子堆再来一次排序。后续我会专门说一次堆排序，这里就大致提一下。</p>
<p>我刚刚模拟了一边堆排序的过程，在PriorityQueue队列中，每加入一个元素就相当于在刚刚那样的完全二叉树底部插入一个元素并且再进行一次刚刚的堆排序模拟。</p>
<p>底层数据结构看了，我们看看源码。</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><strong>属性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认初始容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"><span class="comment">//创建的一个队列，队列内的元素下标满足 queue[i]的子节点为queue[2*i+1]和queue[2*i+2]</span></span><br><span class="line"><span class="keyword">transient</span> Object[] queue;</span><br><span class="line"><span class="comment">//队列内的元素个数</span></span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//比较器，用于升序或者降序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"><span class="comment">//队列修改次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure>

<p><strong>构造方法</strong></p>
<p><code>PriorityQueue()</code>  ：创建一个PriorityQueue ，具有默认的初始容量（11），根据它们的自然顺序对其元素进行排序 。 </p>
<p><code>PriorityQueue(Collection&lt;? extends E&gt; c)</code>  ：创建一个collection集合中的元素的PriorityQueue。 </p>
<p><code>PriorityQueue(Comparator&lt;? super E&gt; comparator)</code>  ：创建具有默认初始容量的PriorityQueue，并根据指定的比较器对其元素进行排序。 </p>
<p><code>PriorityQueue(int initialCapacity)</code> ：使用指定的初始容量创建一个 PriorityQueue，并根据其自然顺序对元素进行排序。</p>
<p><code>PriorityQueue(PriorityQueue&lt;? extends E&gt; c)</code>：  创建包含 <code>PriorityQueue</code>优先级队列中的元素的PriorityQueue。 </p>
<p><code>PriorityQueue(SortedSet&lt;? extends E&gt; c)</code>  ：创建一个包含指定排序set集中的元素的PriorityQueue。 </p>
<p><strong>方法</strong></p>
<p><strong>（1）add：插入一个元素，不成功会抛出异常</strong></p>
<p>调用的offer方法。</p>
<p><strong>（2）offer：插入一个元素，不能被立即执行的情况下会返回一个特殊的值（true 或者 false）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    modCount++;<span class="comment">//修改次数加一</span></span><br><span class="line">    <span class="keyword">int</span> i = size;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        grow(i + <span class="number">1</span>);</span><br><span class="line">    siftUp(i, e);</span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入空元素是会报空指针异常的。会先判断队列容量够不够，不够就调用grow来进行队列的扩容，然后插入操作就进入了siftUp()函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        siftUpUsingComparator(k, x, queue, comparator);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUpComparable(k, x, queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里判断我们是否传入了比较器，之后便是插入操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] es)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;) x;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = es[parent];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((T) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        es[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    es[k] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）remove：删除一个元素，如果不成功会返回false。</strong></p>
<p>调用的其实是removeAt()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = indexOf(o);</span><br><span class="line">    <span class="keyword">if</span> (i == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        removeAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">E <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert i &gt;= 0 &amp;&amp; i &lt; size;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] es = queue;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    <span class="keyword">if</span> (s == i) <span class="comment">// removed last element</span></span><br><span class="line">        es[i] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        E moved = (E) es[s];</span><br><span class="line">        es[s] = <span class="keyword">null</span>;</span><br><span class="line">        siftDown(i, moved);</span><br><span class="line">        <span class="keyword">if</span> (es[i] == moved) &#123;</span><br><span class="line">            siftUp(i, moved);</span><br><span class="line">            <span class="keyword">if</span> (es[i] != moved)</span><br><span class="line">                <span class="keyword">return</span> moved;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>堆排序的上浮与下沉。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        siftDownUsingComparator(k, x, queue, size, comparator);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftDownComparable(k, x, queue, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断比较器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] es, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert n &gt; 0;</span></span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;)x;</span><br><span class="line">    <span class="keyword">int</span> half = n &gt;&gt;&gt; <span class="number">1</span>;           <span class="comment">// loop while a non-leaf</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line">        Object c = es[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; n &amp;&amp;</span><br><span class="line">            ((Comparable&lt;? <span class="keyword">super</span> T&gt;) c).compareTo((T) es[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = es[child = right];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((T) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        es[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    es[k] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（4）poll：删除一个元素，并返回删除的元素</strong></p>
<p>调用的siftDown()函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] es;</span><br><span class="line">    <span class="keyword">final</span> E result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((result = (E) ((es = queue)[<span class="number">0</span>])) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">final</span> E x = (E) es[(n = --size)];</span><br><span class="line">        es[n] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; cmp;</span><br><span class="line">            <span class="keyword">if</span> ((cmp = comparator) == <span class="keyword">null</span>)</span><br><span class="line">                siftDownComparable(<span class="number">0</span>, x, es, n);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                siftDownUsingComparator(<span class="number">0</span>, x, es, n, cmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（5）peek：查询队顶元素</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) queue[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（6）indexOf(Object o)：查询对象o的索引</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> Object[] es = queue;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = size; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(es[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（7）contains(Object o)：判断是否容纳了元素</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈Deque</title>
    <url>/2020/10/29/%E8%B0%88%E8%B0%88Deque/</url>
    <content><![CDATA[<p><code>ArrayDeque</code>是<code>Deque</code>接口的一个实现，使用了可变数组，所以没有容量上的限制。同时，<code>ArrayDeque</code>是线程不安全的，在没有外部同步的情况下，不能再多线程环境下使用。<code>ArrayDeque</code>是<code>Deque</code>的实现类，可以作为栈来使用，效率高于<code>Stack</code>；也可以作为队列来使用，效率高于<code>LinkedList</code>。需要注意的是，<code>ArrayDeque</code>不支持<code>null</code>值。</p>
<p>说人话，就是一个比Stack栈效率高，比LinkedList队列效率高的又能当栈又能当队列用的万金油集合，但是不支持多线程，我们来详细看看这到底是个啥，为什么说他性能比Stack和LinkedList要高。</p>
<h2 id="Deque接口"><a href="#Deque接口" class="headerlink" title="Deque接口"></a>Deque接口</h2><p>继承关系如下图：</p>
<p><img src="http://cdn.lehanbal.top/%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="继承关系"></p>
<p>学习一个类，就从它的父类进行学习，所以我们从它的继承关系来看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDeque</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p>继承了Deque接口，Deque这个接口啊，提供了插入，移除和检查元素的方法。deque是“双端队列”的缩写，也就是说，只要是集成了Deque这个接口，都能够实现双端操作。</p>
<p>与List不同，这个接口不支持索引访问元素。</p>
<p>Queue、Stack以及Deque各个接口的方法对比</p>
<table>
<thead>
<tr>
<th align="center">Queue Method</th>
<th align="center">Stack Method</th>
<th align="center">Deque Method</th>
<th align="center"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">add(e)</td>
<td align="center">push(e)</td>
<td align="center">addLast(e)</td>
<td align="center">向队尾\栈顶插入元素，失败则抛出异常</td>
</tr>
<tr>
<td align="center">offer(e)</td>
<td align="center">无</td>
<td align="center">offerLast(e)</td>
<td align="center">向队尾\栈顶插入元素，失败则返回false</td>
</tr>
<tr>
<td align="center">remove()</td>
<td align="center">pop()</td>
<td align="center">removeFirst()</td>
<td align="center">获取并删除队首\栈顶元素，失败则抛出异常</td>
</tr>
<tr>
<td align="center">poll()</td>
<td align="center">无</td>
<td align="center">pollFirst()</td>
<td align="center">获取并删除队首\栈顶元素，失败则返回null</td>
</tr>
<tr>
<td align="center">element()</td>
<td align="center">peek()</td>
<td align="center">getFirst()</td>
<td align="center">获取但不删除队首\栈顶元素，失败则抛出异常</td>
</tr>
<tr>
<td align="center">peek()</td>
<td align="center">无</td>
<td align="center">peekFirst()</td>
<td align="center">获取但不删除队\栈顶首元素，失败则返回null</td>
</tr>
</tbody></table>
<p>这个类给我们分别定义了两套获取元素和插入元素的方法，一套会抛出异常，而另一套只会返回对应的状态值。</p>
<p><strong>Stack不被支持继续使用，它继承自Vector类，Vector因为性能问题已经忌用，所以它的子类也会有类似的问题</strong></p>
<h2 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h2><p><em>ArrayDeque</em>是Deque的一个实现类，底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即<strong>循环数组（circular array）</strong>，也就是说数组的任何一点都可能被看作起点或者终点。</p>
<p><em>ArrayDeque</em>是非线程安全的（not thread-safe），当多个线程同时使用的时候，需要程序员手动同步；另外，<strong>该容器不允许放入null元素</strong>，<strong>该容器不允许放入null元素</strong>，<strong>该容器不允许放入null元素</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存储元素的数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elements;</span><br><span class="line">   <span class="comment">//头部元素索引</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> head;</span><br><span class="line">   <span class="comment">//尾部要加入元素的索引</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> tail;</span><br></pre></td></tr></table></figure>

<p>数组遇到插入元素是一件很苦恼的事情，巧妙地利用循环数组可以直接将元素向头部之前添加元素，并不需要大面积地移动数据。</p>
<p>线性数组与循环数组插入元素地区别图：<strong>（注意头指针和尾指针的位置！头指针指向的是第一个元素，尾指针则是指向最后一个元素的后一位）</strong></p>
<p><img src="http://cdn.lehanbal.top/%E7%BA%BF%E6%80%A7%E6%95%B0%E7%BB%84%E4%B8%8E%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84.png" alt="线性数组与循环数组"></p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>我们从增删查入手，以此把每个要点的老大看了，就能彻底弄懂的源码。</p>
<h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><p>offer、add、push都是根据插入的位置的不同来分别调用addFirst或者addLast。它俩的源码如下：</p>
<p>addFirst：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)<span class="comment">//前面说过ArrayDeque不能存储空元素，这里源码再一次证明。</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elements;</span><br><span class="line">    es[head = dec(head, es.length)] = e;<span class="comment">//当前头指针指向的是第一个元素，头部指针向前减一位，由于是循环队列，所以会在dec()里面判断并且循环。</span></span><br><span class="line">    <span class="keyword">if</span> (head == tail)<span class="comment">//如果头指针指到尾指针了，就进行扩容，注意是先插入，后扩容，所以插入元素的时候并不需要考虑是否能插入，此时头指针永远都是指向空的位置。</span></span><br><span class="line">        grow(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addFirst所依赖的dec：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> modulus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (--i &lt; <span class="number">0</span>) i = modulus - <span class="number">1</span>;<span class="comment">//如果头指针向前移动了一位就导致数组下标越界了，那么就让这个头指针指向改数组的最后一个位置。</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addLast：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elements;</span><br><span class="line">    es[tail] = e;<span class="comment">//因为是尾指针，尾指针指向的地方为空元素，所以直接将元素插入即可，移动尾指针的步骤在inc里面执行。</span></span><br><span class="line">    <span class="keyword">if</span> (head == (tail = inc(tail, es.length)))<span class="comment">//判断是否需要扩容（顺便移动了尾指针）</span></span><br><span class="line">        grow(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addLast所依赖的inc：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> modulus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (++i &gt;= modulus) i = <span class="number">0</span>;<span class="comment">//尾指针移动之后如果超出了该数组的最大长度，那就让尾指针指向数组的第一个位置。</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><p>与增一致，remove、poll、pop都是调用pollFirst或者pollLast方法，源码如下：</p>
<p>pollFirst：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] es;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> h;</span><br><span class="line">    E e = elementAt(es = elements, h = head);<span class="comment">//获取头元素</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        es[h] = <span class="keyword">null</span>;<span class="comment">//将当前头元素的内容设为null</span></span><br><span class="line">        head = inc(h, es.length);<span class="comment">//调用inc函数让头指针先后移动以为，继续指向当前队列中的第一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pollLast：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] es;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> t;</span><br><span class="line">    E e = elementAt(es = elements, t = dec(tail, es.length));<span class="comment">//因为尾指针指向的位置是空元素，所以需要先进行dec操作将尾指针进行前移，才能获取到队列中的最后一个元素。</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">        es[tail = t] = <span class="keyword">null</span>;<span class="comment">//将当前尾指针指向的内容设值为null</span></span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>一样一样一样，都一样，get、peek、element都是调用的elementAt方法。</p>
<p>elementAt：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;E&gt; <span class="function">E <span class="title">elementAt</span><span class="params">(Object[] es, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) es[i];<span class="comment">//就这么简单,根据下标查询数组内容，所以会在数组下标的参数传递上做功夫。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> elementAt(elements, head);<span class="comment">//直接将头指针的位置传递即可</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] es;</span><br><span class="line">    <span class="keyword">return</span> elementAt(es = elements, dec(tail, es.length));<span class="comment">//尾指针先调用dec向前移动一位才能访问到数组元素，然后根据下标查询数据即可。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增删查就这么搞定了。</p>
<h4 id="扩增函数"><a href="#扩增函数" class="headerlink" title="扩增函数"></a>扩增函数</h4><p>grow函数（看个乐呵）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> needed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldCapacity = elements.length;<span class="comment">//记录下原来数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity;<span class="comment">//声明用于表示新数组长度的变量</span></span><br><span class="line">    <span class="comment">// Double capacity if small; else grow by 50%</span></span><br><span class="line">    <span class="keyword">int</span> jump = (oldCapacity &lt; <span class="number">64</span>) ? (oldCapacity + <span class="number">2</span>) : (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//当原数组的空间小于64的时候，每次就翻倍增则（这里的jump是扩容的量，后面还需要在原数组长度的基础上再加上jump），不然的后就按原数组长度的50%增长（&gt;&gt;1相当于*0.5）</span></span><br><span class="line">    <span class="keyword">if</span> (jump &lt; needed</span><br><span class="line">        || (newCapacity = (oldCapacity + jump)) - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)<span class="comment">//当我们扩容的长度比我们所需要的长度要小的时候，或者是我们扩容的长度已经比我们所设定的最大数组长度还要大的时候，我们会调用newCapacity方法（下一个代码详解）</span></span><br><span class="line">        newCapacity = newCapacity(needed, jump);</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elements = Arrays.copyOf(elements, newCapacity);<span class="comment">//我们把当前的数组用新空间拷贝一份</span></span><br><span class="line">    <span class="keyword">if</span> (tail &lt; head || (tail == head &amp;&amp; es[head] != <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="comment">//tail &lt; head 当头指针在尾指针后面的时候</span></span><br><span class="line">        <span class="comment">//tail == head &amp;&amp; es[head] != null 当头指针等于尾指针且它们指向的内容不为空</span></span><br><span class="line">        <span class="comment">//数组满了的情况就是头指到尾了，所以需要扩容</span></span><br><span class="line">        <span class="keyword">int</span> newSpace = newCapacity - oldCapacity;<span class="comment">//新空间的大小，等价于jump</span></span><br><span class="line">        System.arraycopy(es, head,</span><br><span class="line">                         es, head + newSpace,</span><br><span class="line">                         oldCapacity - head);<span class="comment">//调用系统复制数组，将原数组的元素移动到加了新空间的位置上，同时移动了头指针的位置，与尾指针分开</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head, to = (head += newSpace); i &lt; to; i++)</span><br><span class="line">            es[i] = <span class="keyword">null</span>;<span class="comment">//将新空间中的元素设置为null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>newCapacity：（这个函数是用来判断边界条件以及溢出处理的）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> needed, <span class="keyword">int</span> jump)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldCapacity = elements.length, minCapacity;</span><br><span class="line">    <span class="keyword">if</span> ((minCapacity = oldCapacity + needed) - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//minCapacity是所需要的最小扩容空间，当最小的扩容空间比我们给定的最大数组方法还要大的时候</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>)<span class="comment">//这里是溢出了，直接抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Sorry, deque too big&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;<span class="comment">//不然的话直接返回int的最大值</span></span><br><span class="line">        <span class="comment">//  private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class="line">        <span class="comment">//原先设定的最大数组长度比int的最大值小8，所以还能有剩余空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (needed &gt; jump)<span class="comment">//当我们所需的空间比自动扩容要大，则返回我们能够完成的最小空间</span></span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    <span class="keyword">return</span> (oldCapacity + jump - MAX_ARRAY_SIZE &lt; <span class="number">0</span>)</span><br><span class="line">        ? oldCapacity + jump</span><br><span class="line">        : MAX_ARRAY_SIZE;<span class="comment">//自动扩容的空间如果不比最大数组长度大则返回自动扩容的容量，否则返回指定的最大数组长度。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p><em>LinkedList</em>也是Deque的一个实现类，底层是一个双向链表实现的，记录着前驱和后继两个结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to first node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to last node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该集合的元素存储结构也可以形象的表示为以下图：</p>
<p><img src="http://cdn.lehanbal.top/LinkedList%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E5%9B%BE.png" alt="LinkedList逻辑存储图"></p>
<p>它的继承关系如下图：</p>
<p><img src="http://cdn.lehanbal.top/LinkedList.png" alt="LinkedList"></p>
<p>我们能看到<em>LinkedList</em>实现了Deque和List接口，那么<em>LinkedList</em>就具备了list和deque两个接口的属性，list能够通过下标进行索引访问，deque在前面也介绍了，能够实现双向队列（同样能够当作栈或者队列来使用）。</p>
<p>除此之外，<em>LinkedList</em>能够存储null元素。</p>
<p>那么我们来看看源码。</p>
<h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><h4 id="增-1"><a href="#增-1" class="headerlink" title="增"></a>增</h4><p>与队列和栈的增加元素方法相关的操作都与linkFirst函数和linkLast函数相关，根据插入元素的位置的不同会调用相关操作。</p>
<p>linkFirst：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;<span class="comment">//保存当前first结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);<span class="comment">//声明一个新的结点来作为当前的头节点</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)<span class="comment">//如果之前是空链表，那么就让头和尾指针指向同一个元素，因为当前元素是该链表中唯一的元素</span></span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;<span class="comment">//如果之前不是空链表，那么就让之前的头节点的前驱结点指向当前的头节点</span></span><br><span class="line">    size++;<span class="comment">//链表元素+1</span></span><br><span class="line">    modCount++;<span class="comment">//修改次数+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>linkLast：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;<span class="comment">//保存当前的last结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);<span class="comment">//声明一个新的结点来作为当前的尾结点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)<span class="comment">//如果之前是空链表，那么就让头和尾指针指向同一个元素，因为当前元素是该链表中唯一的元素</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;<span class="comment">//如果之前不是空链表，那么就让之前的尾结点的后继结点指向新的尾结点</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然继承了list接口，就有够通过下标进行元素操作的方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);<span class="comment">//检测index是否合理，必须是链表长度内才行，不然就抛出越界异常</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)<span class="comment">//如果要插入的元素是链表的末尾，那么就直接调用linkLast插入</span></span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));<span class="comment">//调用linkBefore函数插入结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>node：在add函数中已经对index进行了合法判断，所以当前的index是在链表的合理范围内。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//我们需要找到index位置的结点，最坏的情况只需要找n/2次便能找到，因为记录了头节点和尾结点，我们只需要计算index在该链表中心的左边还是右边即可，若是在左边，则从头节点开始查找，若是在右边，则从尾结点开始查找。</span></span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;<span class="comment">//判断index是在链表中心的左边还是右边</span></span><br><span class="line">        Node&lt;E&gt; x = first;<span class="comment">//左边就从头节点开始查找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;<span class="comment">//若在右边则从尾结点开始查找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>linkBefore：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//succ就是我们要插入元素的后继结点，我们需要把我们的元素安排在该结点之前</span></span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;<span class="comment">//记录要插入元素的前驱结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);<span class="comment">//声明一个新的结点，前驱后继如上所说</span></span><br><span class="line">    succ.prev = newNode;<span class="comment">//更新succ节点的前驱，使得我们要插入的元素成为它的前驱结点。</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)<span class="comment">//如果我们要插入的元素是头节点的位置，那么就让这个新的结点成为头节点。</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//不然的话就更新前驱节点的后继结点为我们新的结点。</span></span><br><span class="line">        pred.next = newNode;<span class="comment">//该节点就融入进去了</span></span><br><span class="line">    size++;<span class="comment">//元素数量+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体步骤如下图：</p>
<p><img src="http://cdn.lehanbal.top/LinkedList%E5%8A%A0%E5%85%A5%E6%96%B0%E5%85%83%E7%B4%A0%E7%9A%84%E6%AD%A5%E9%AA%A4.png" alt="LinkedList加入新元素的步骤"></p>
<h4 id="删-1"><a href="#删-1" class="headerlink" title="删"></a>删</h4><p>与队列、栈相关的删除操作本质上是在调用unlinkFirst与unlinkLast</p>
<p>unlinkFirst：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//删除头结点元素</span></span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;<span class="comment">//保存头节点元素，之后要返回</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;<span class="comment">//记录下当前头结点的后继结点，要让它子承父业</span></span><br><span class="line">    f.item = <span class="keyword">null</span>;<span class="comment">//让当前头节点的item以及后继节点的指向都指空，有助于GC回收</span></span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    first = next;<span class="comment">//开始子承父业</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)<span class="comment">//如果成了空链表的话，那么就让头尾都指向null，成为头尾都指向null的空链表，没有指向</span></span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//如果还有元素，那就让子节点的前驱结点指向空，成为头节点（头节点没有前驱结点）</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">    <span class="comment">//如果你疑问为什么next为空了就不需要让next的前驱指针指向空，好好读我下面这句话</span></span><br><span class="line">    <span class="comment">//憨批，next都是null了，null能存什么元素，null就是null，null，什么都没有了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unlinkLast</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//要删除的结点是尾结点</span></span><br><span class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = l.item;<span class="comment">//保存要删除结点的元素以便之后返回</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;<span class="comment">//记录下当前结点的前驱结点，我们要让这个前驱结点成为尾结点</span></span><br><span class="line">    l.item = <span class="keyword">null</span>;<span class="comment">//与前面的删除头节点的时候一致，让当前的尾结点的前驱结点指向和item都标记为null，有助于GC回收</span></span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    last = prev;<span class="comment">//开始树立新的尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)<span class="comment">//同样的，如果删除了刚刚的尾结点让链表成空了，那就让头节点也指向空，彻底抛弃指向，成为头尾都指向空的两边</span></span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//如果删了尾结点还有元素的话就让目前的尾结点的next指向为null，抛弃指向上一个尾结点的指向，这样就能成为真正的尾结点了</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过下标进行元素的删除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       checkElementIndex(index);<span class="comment">//一样是对索引进行合理性判断，不合理则抛出异常</span></span><br><span class="line">       <span class="keyword">return</span> unlink(node(index));<span class="comment">//node(index)找到要删除的结点，然后解除它的应用</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// assert x != null;</span></span><br><span class="line">       <span class="keyword">final</span> E element = x.item;<span class="comment">//记录下x结点的item 前驱后继结点，都记录下来</span></span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;<span class="comment">//如果前驱结点是空，说明我们要删除的结点是头结点，所以让头节点指向x的后继节点即可</span></span><br><span class="line">           first = next;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果不是前驱结点的话</span></span><br><span class="line">           prev.next = next;<span class="comment">//就让x的前驱结点的next直接指向x的后继结点</span></span><br><span class="line">           x.prev = <span class="keyword">null</span>;<span class="comment">//然后将x的前驱结点的指向设为null，不让他指向任何结点</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;<span class="comment">//如果后继结点是空，说明我们要删除的是尾结点，所以让尾指针直接指向x的前驱结点</span></span><br><span class="line">           last = prev;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;<span class="comment">//不然的话，就越过x，让x的后继结点的前驱指向直接指向x的前驱，再把x的后继结点指向null</span></span><br><span class="line">           next.prev = prev;</span><br><span class="line">           x.next = <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       x.item = <span class="keyword">null</span>;<span class="comment">//将x的内容设为null，这样一来，经过上述操作，x.item x.prev x.next全都指向了null</span></span><br><span class="line">       size--;</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="keyword">return</span> element;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>删除指定内容的元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//删除指定元素的操作，就是穷举当前的链表找到值相等的元素，然后调用unlink解除这个结点的前驱和后继，</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;<span class="comment">//因为LinkedList能够存储null值，null值的判断需要单独进行判断</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    unlink(x);<span class="comment">//穷举找到null之后将该结点删除</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item)) &#123;<span class="comment">//一样的穷举思路</span></span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//具体思路也用在了indexOf中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>删除过程的逻辑图：</p>
<p><img src="http://cdn.lehanbal.top/LinkedList%E6%96%AD%E5%BC%80%E8%BF%87%E7%A8%8B.png" alt="LinkedList断开过程"></p>
<h4 id="查-1"><a href="#查-1" class="headerlink" title="查"></a>查</h4><p>队列、栈的头尾元素查询只需要通过对头尾结点的调用即可取得</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">       <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">       <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">       <span class="keyword">return</span> f.item;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">       <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">       <span class="keyword">return</span> l.item;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以上不解读了，一眼就看明白的东西</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       checkElementIndex(index);</span><br><span class="line">       <span class="keyword">return</span> node(index).item;<span class="comment">//node函数之前已经解读过了，通过对index的大小判断，在链表中心的哪一段，然后利用头尾结点就能实现n/2的查找速率</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>LinkedList解读完了，我们在一起来看看ArrayDeque和LinkedList吧。</p>
<h2 id="ArrayDeque与LinkedList"><a href="#ArrayDeque与LinkedList" class="headerlink" title="ArrayDeque与LinkedList"></a><em>ArrayDeque</em>与<em>LinkedList</em></h2><p>我说了这么多，源码也给读了，剩下就看你们来总结这两者的不同吧。</p>
<p>如果你总结不出，那只能说明你没看我写的文章，懒狗。</p>
<p>但是本人也是懒狗，这里记录下这两者的不同，以及正面回答为什么很多情况下推荐使用ArrayDeque。</p>
<ol>
<li>ArrayDeque底层通过数组实现，底层是一个循环数组，动态扩容；LinkedList则是通过一个双向链表实现。</li>
<li>ArrayDeque并不能够存储null元素，有意为之，但是LinkedList能够存储null。</li>
<li>ArrayDeque进行扩容的时候会需要比较大的性能开销，LinkedList是链表实现，并不需要扩容操作，只需要指针指向即可。</li>
</ol>
<p>但是ArrayDeque插入头尾数据和删除数据都是妥妥的O(1)复杂度，作为队列或者栈来使用的时候，还有什么比O(1)的头部尾部操作更优秀呢？对于循环数组而言，它的随机访问依旧是O(1)，链表则是O(n)，此时唯一的缺点就是扩容造成的性能开销；相比之下LinkedList是通过链表实现的，同时他还继承了List接口，除了能够当成双向队列来使用的时候，还能够通过下表进行数据的访问以及相关操作，并且链表的优点是删除元素的时候很方便只有O(1)的时间复杂度，但是删除元素的时候你需要先找到当前元素，所以还是一个O(n)的时间过程，在当作队列或者栈来说的时候，ArrayDeque在操作的复杂度上而言，完爆LinkedList。</p>
<p>但是读过ArrayDeque源码之后我们知道，这玩意扩容很耗空间，而且扩容的时候性能开销也是实实在在存在的，LinkedList则是动态的使用空间大小，每次添加新的结点的时候都是原地创建结点再创建应用，并不会造成先ArrayDeque那样的扩容开销，而且它能够通过下标访问，所以在不作为队列或者栈使用的时候，是有它的用武之地。</p>
<ul>
<li>在我们清楚我们的操作需要消耗多少空间的时候，优先推荐使用ArrayDeque作为队列或者栈的集合。</li>
<li>若是我们不清楚消耗的空间，并且消耗的空间会持续增大的话，可以考虑使用LinkedList来作为队列或者栈的集合。（防止ArrayDeque多次地扩容造成性能浪费）。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>JAVA</tag>
        <tag>Deque</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是红黑树</title>
    <url>/2020/10/29/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<p>在知乎上看到老刘写的<a href="https://zhuanlan.zhihu.com/p/79980618?utm_source=cn.wiz.note">红黑树，超强动静图详解，简单易懂</a>，写得真的很棒，所以这里做下学习记录，再翻版一次。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在学习红黑树之前，需要先了解以下二叉搜索树（二叉平衡树，二叉排序树都是一个东西）。</p>
<p><strong>二叉搜索树</strong>：</p>
<ol>
<li>某节点的左子树节点值仅包含小于该节点值</li>
<li>某节点的右子树节点值仅包含大于该节点值</li>
<li>左右子树每个也必须是二叉查找树</li>
</ol>
<p>二叉搜索树查找元素核心的实现就是二分查找，如果要查找的元素比当前节点的值要大就去右子树找，如果比当前节点小就去左子树找。一颗合格的二叉搜索树应该长以下的样子。</p>
<p><img src="http://cdn.lehanbal.top/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.png" alt="二叉搜索树"></p>
<p>题外话：二叉搜索树的中序遍历结果是一个递增序列。</p>
<p>我们现在知道了二叉搜索树，那么什么是红黑树呢？</p>
<p>在二叉搜索树插入数据会出现一些比较极端的情况：</p>
<p><img src="http://cdn.lehanbal.top/jio%E6%8E%B0%E6%A0%91.png" alt="jio掰树"></p>
<p>这种情况下的二叉搜索树检索检索元素和线性表无异，这棵树太歪了。</p>
<p>红黑树就是用来解决这类问题的，</p>
<p>简单地说，红黑树就是会动态的调节根节点的位置，使这棵树趋近左右平衡，让这颗树长得不这么歪。</p>
<p><img src="http://cdn.lehanbal.top/%E7%BA%A2%E9%BB%91%E6%A0%91.png" alt="红黑树"></p>
<p>调节过后这就变成了红黑树。</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树，Red-Black Tree 「RBT」是一个自平衡(不是绝对的平衡)的二叉搜索树(BST)，树上的每个节点都遵循下面的规则:</p>
<p>性质1. 节点是红色或黑色。 </p>
<p>性质2. 根节点是黑色。 </p>
<p>性质3. 所有叶子都是黑色。（叶子是NUIL节点） </p>
<p>性质4. 每个红色节点的两个子节点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色节点，<strong>并没有说不能出现连续的黑色节点</strong>）</p>
<p>性质5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p>
<p>满足以上条件的二叉搜索树就是一颗红黑树。</p>
<p>虽然说条件看起来很复杂，我们直接跟着走几个案例试试。</p>
<p>在走案例之前，我们需要清楚以下操作</p>
<ul>
<li>染色</li>
</ul>
<p>红黑树以红色和黑色分别标记每个节点的颜色信息，所以我们需要会需要对节点进行重新染色的操作。</p>
<hr>
<ul>
<li>左旋转与右旋转</li>
</ul>
<p>个人觉得这就是红黑树的灵魂，就是因为旋转的步骤才保持着满足红黑树的约束条件的同时还能保证最基本的二叉搜索树的约束条件。</p>
<p>分别上个左旋和右旋的操作（该举例只是为了说明旋转的时候节点的去向，并不代表要转成红黑树需要这么做）</p>
<p>左旋：<img src="http://cdn.lehanbal.top/%E5%B7%A6%E6%97%8B%E8%BD%AC.png" alt="左旋转"></p>
<p>右旋：<img src="http://cdn.lehanbal.top/%E5%8F%B3%E6%97%8B%E8%BD%AC.png" alt="右旋转"></p>
<p><strong>上面的左旋右旋一定看清楚怎么旋转的！</strong></p>
<p><strong>上面的左旋右旋一定看清楚怎么旋转的！</strong></p>
<p><strong>上面的左旋右旋一定看清楚怎么旋转的！</strong></p>
<hr>
<h3 id="红黑树插入操作"><a href="#红黑树插入操作" class="headerlink" title="红黑树插入操作"></a>红黑树插入操作</h3><p>红黑树插入节点与二叉搜索树的插入方式一致，在二叉搜索树插入节点后，会动态的调整根节点位置。</p>
<p>在插入结点的时候，我们会考虑先把节点染色，当染色后不能够满足性质4的时候再进行旋转操作。</p>
<p>算法公式如下：</p>
<p>假设新插入的节点为x</p>
<ol>
<li><p>将新插入的节点标记为红色。</p>
</li>
<li><p>如果x是根节点（root），则标记为黑色。</p>
</li>
<li><p>如果x的父节点不是黑色，同时x也不是根节点：</p>
<p>3.1 如果x的叔叔节点是红色</p>
<p>​    3.1.1 将父节点和叔叔节点标记为黑色</p>
<p>​    3.1.2 将祖父节点标记为红色</p>
<p>​    3.1.3 让x节点的颜色与x祖父的颜色相同，然后重复2、3步骤。</p>
</li>
</ol>
<p>上案例！</p>
<p><img src="http://cdn.lehanbal.top/%E5%8F%94%E5%8F%94%E8%8A%82%E7%82%B9%E4%B8%BA%E7%BA%A2%E8%89%B2.png" alt="叔叔节点为红色"></p>
<p>​    3.2 如果x的叔叔节点是黑色，就有四种情况需要进行处理</p>
<p>​        3.2.1 x的父节点是x的祖父节点的左孩子，x是父节点的左孩子，左左关系</p>
<p>​        3.2.2 x的父节点是x的祖父节点的左孩子，x是父节点的右孩子，左右关系</p>
<p>​        3.2.3 与3.2.1反过来，镜像，右右关系</p>
<p>​        3.2.4 与 3.2.2反过来，镜像有，右左关系</p>
<p><strong>3.2.1 情况：左左关系：</strong></p>
<p><img src="http://cdn.lehanbal.top/%E5%B7%A6%E5%B7%A6%E6%83%85%E5%86%B5.png" alt="左左情况"></p>
<p><strong>3.2.2情况：左右关系：</strong></p>
<p><img src="http://cdn.lehanbal.top/%E5%B7%A6%E5%8F%B3%E6%83%85%E5%86%B5.png" alt="左右情况"></p>
<p><strong>3.2.3右右情况</strong></p>
<p><img src="http://cdn.lehanbal.top/%E5%8F%B3%E5%8F%B3%E6%83%85%E5%86%B5.png" alt="右右情况"></p>
<p><strong>3.2.4右左情况</strong></p>
<p><img src="http://cdn.lehanbal.top/%E5%8F%B3%E5%B7%A6%E6%83%85%E5%86%B5.png" alt="右左情况"></p>
<h3 id="红黑树删除操作"><a href="#红黑树删除操作" class="headerlink" title="红黑树删除操作"></a>红黑树删除操作</h3><p>删除操作则是阅读了<a href="https://blog.csdn.net/m0_37589327/article/details/78518324">该篇博文</a>，讲得是真的好，看了蛮多的红黑树删除操作得视频以及文章只觉得这篇最有价值。</p>
<p>删除操作就需要将所有情况都穷举一遍，是情况是真的多，但是无论我们怎么操作，我们的唯一的目的就是保持红黑树的平衡。</p>
<p>要了解红黑树的删除操作，那么就必须要清楚二叉搜索树的删除操作。</p>
<p>二叉搜索树删除结点会有三种情况出现：</p>
<ol>
<li>如果删除的结点是叶子结点，直接删除即可。</li>
<li>如果删除的结点只有一个结点，直接将父节点的指针指向它的孩子即可。</li>
<li>如果删除的结点有两个孩子，则可以找它的后继，覆盖它的值，之后情况转变为删除前驱结点或者后继结点，也就是回到（1）和（2）两种情况。</li>
</ol>
<p>红黑树删除结点的操作来了：</p>
<p>情况3解决方案：可以转化为情况2与情况1，所以红黑树的删除操作也就转化为下面得两种大情况。</p>
<p>情况2解决方案：这种情况待删除的结点一定是黑色，因为红色结点不能只有一个孩子，这会导致红黑树不平衡，并且他的孩子一定是红色。直接使他的孩子替换掉待删除结点的位置并且染色即可。</p>
<p><img src="http://cdn.lehanbal.top/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%E6%83%85%E5%86%B52.png" alt="删除结点情况2"></p>
<p>情况1解决方案：这是最为复杂的情况了。</p>
<ol>
<li><p>待删除的结点是红色，删就完事了，不会影响到红黑树平衡。<br><img src="http://cdn.lehanbal.top/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%E6%98%AF%E7%BA%A2%E8%89%B2.png" alt="删除结点是红色"></p>
</li>
<li><p>待删除的结点是黑色，它兄弟是黑色。</p>
<p>2.1.它兄弟没有孩子，并且它们的爹是红色</p>
<p><img src="http://cdn.lehanbal.top/%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B52.1.png" alt="删除情况2.1"></p>
<p>2.2.它兄弟没有孩子，并且它们的爹是黑色</p>
<p><img src="http://cdn.lehanbal.top/%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B52.2.png" alt="删除情况2.2"></p>
<p>​        这种情况需要注意，因为我们删除了一个黑色节点，所以这种情况该路线不会平衡，我们就需要对父节点进行递归操作处理，重新判断各种情况。</p>
<p>2.3.它兄弟只有一个红色左孩子</p>
<p>​        红色节点不会影响红黑树的性质。从下图看出，父亲结点被拖去左边抵儿子的债了。<br><img src="http://cdn.lehanbal.top/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%E6%83%85%E5%86%B52.3.png" alt="删除结点情况2.3"></p>
<p>2.4.它兄弟只有一个红色右孩子</p>
<p>​        和2.3的情况十分相似，都是子债父偿，但是2.3情况下当家作主的是侄子结点，在2.4情况下它兄弟当家做主了。</p>
<p><img src="http://cdn.lehanbal.top/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%E6%83%85%E5%86%B52.4.png" alt="删除结点情况2.4"></p>
</li>
<li><p>待删除的结点是黑色，兄弟结点是红色（该情况下红色肯定是带着两个红色孩子，不然树不会平衡）<br><img src="http://cdn.lehanbal.top/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%E6%83%85%E5%86%B53.png" alt="删除结点情况3"></p>
</li>
</ol>
<p>这就是全部的红黑树删除情况，剩下的右情况镜像处理即可。</p>
<h2 id="灵魂拷问"><a href="#灵魂拷问" class="headerlink" title="灵魂拷问"></a>灵魂拷问</h2><h3 id="jdk-1-8-HashMap-中有使用到红黑树，你知道触发条件是什么吗？有读过源码是如何-put-和-remove-的吗？"><a href="#jdk-1-8-HashMap-中有使用到红黑树，你知道触发条件是什么吗？有读过源码是如何-put-和-remove-的吗？" class="headerlink" title="jdk 1.8 HashMap 中有使用到红黑树，你知道触发条件是什么吗？有读过源码是如何 put 和 remove 的吗？"></a>jdk 1.8 HashMap 中有使用到红黑树，你知道触发条件是什么吗？有读过源码是如何 put 和 remove 的吗？</h3><p>红黑树插入为O(lgn),查询为O(lgn)，链表插入为O(1)，查询为O(n)。个数少时，插入删除成本高，用链表；个数多时，查询成本高，用红黑树。需要定一个值，比这个值大就转红黑树，比这个值小就转链表，而且要避免频繁的转换。根据泊松分布，在负载因子0.75（HashMap默认）的情况下，单个hash槽内元素个数为8的概率小于百万分之一，将7作为一个分水岭，等于7时不做转换，大于等于8才转红黑树，小于等于6才转链表。</p>
<p>触发转化的两个条件是：一个是链表的长度达到8个，一个是数组的长度达到64个。</p>
<p>put源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>putVal源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;<span class="comment">//定义一个临时链表数组，对hashmap中的table进行操作，n是table的长度，为hashmap初始化时定义的值，是2的幂，i为tab的游标</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)<span class="comment">//如果这个hashmap是空的</span></span><br><span class="line">        n = (tab = resize()).length;<span class="comment">//就resize一下这个hashmap，获取容量（16）</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)<span class="comment">//这行代码的意思是获取tab链表数组中的第length个链表，如果链表为空，就创建新节点添加进去，它的nextnode为null</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))<span class="comment">//如果hash相同，键相同，就直接把p指向e</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)<span class="comment">//如果已经是红黑树了就执行红黑树的添加操作</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;<span class="comment">//链表数组中如果不出现hash碰撞，最完美的情况应该是每个链表都是单结点，这里统计链表中节点的个数</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//TREEIFY_THRESHOLD = 8；判断当前链表长度，如果大于8就把链表转化为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);<span class="comment">//把这个链表转化成红黑树，然后直接退出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))<span class="comment">//在结点遍历的过程中，如果有hash值相同的情况，且key值相同，就直接退出循环，把这个找到的结点直接赋值</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;<span class="comment">//每次都指向下一个结点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)<span class="comment">//根据参数onlyIfAbsent决定是否覆盖</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;返回的是e.value的指向</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;<span class="comment">//操作数+1</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)<span class="comment">//如果链表数组大小大于了阈值，就扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过hash计算要填记得key准备插入的位置，如果key一样就看参数是否决定覆盖，如果是空的就执行插入方法，如果对应的位置有值就判断是红黑树结构还是链表结构，如果是链表结构的话就顺着链表寻找，找到一样的key就跟参数选择覆盖，没找到的话就放在链表的最后面，链表长度大于8的话就进行红黑树化，如果是红黑树结构就按照书的添加方式进行添加。</p>
<p>treeifyBin源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//MIN_TREEIFY_CAPACITY = 64,这里是重点，如果table小于64，那么是走的扩容resize的方法，超过这个数字，才会走到else的TreeNode的构建</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>remove源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>removeNode源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;<span class="comment">// 定义节点数组tab用于指向table、节点p、数组长度n、hash所映射的数组下标</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;<span class="comment">// 节点数组在hash位置处的节点不为空,若为空则直接返回null(不存在可删除元素)</span></span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;<span class="comment">// 定义局部节点变量node存储需要删除的元素、循环变量e、key、value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))<span class="comment">// 头结点即为需要删除的节点</span></span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;<span class="comment">// 链表还存在其他元素,并将e指向头结点的后继元</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)<span class="comment">// 该链表是一个红黑树结构</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);<span class="comment">// 在红黑树中查询指定hash、key的节点并返回</span></span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">// 链表是一个单项链表</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;<span class="comment">// 节点e时需要移除的节点,结束循环</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;<span class="comment">// 循环结束时,节点p为目标节点的前驱元</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;<span class="comment">// 存在需要移除的节点且值匹配删除为false或者不为false且值匹配</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)<span class="comment">// node为树形节点,使用treeNode的移除方法</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)<span class="comment">// 若node为头结点,直接将node 的后继元作为新的头结点</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;<span class="comment">// 链表下移除节点且不为头结点,此时将目标节点的前驱元的后继元指向目标节点的后继元</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是红黑树退成链表的源码，不解读了，在hashMap中的元素小于6的时候会从红黑树退成链表，选择6是为了防止在刚刚转化成红黑树后出现频繁地增加与删除操作导致查询效率低下，所以中间设置缓冲。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">    TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">    TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        tab[index] = first = succ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = succ;</span><br><span class="line">    <span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>)</span><br><span class="line">        root = root.root();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span></span><br><span class="line">        || (movable</span><br><span class="line">            &amp;&amp; (root.right == <span class="keyword">null</span></span><br><span class="line">                || (rl = root.left) == <span class="keyword">null</span></span><br><span class="line">                || rl.left == <span class="keyword">null</span>))) &#123;</span><br><span class="line">        tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">    <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">        <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor</span></span><br><span class="line">            s = sl;</span><br><span class="line">        <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">        TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s&#x27;s direct parent</span></span><br><span class="line">            p.parent = s;</span><br><span class="line">            s.right = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">            <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                    sp.left = p;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sp.right = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">                pr.parent = s;</span><br><span class="line">        &#125;</span><br><span class="line">        p.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">            sr.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">            pl.parent = s;</span><br><span class="line">        <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">            root = s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = s;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = s;</span><br><span class="line">        <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">            replacement = sr;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            replacement = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">        replacement = pl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">        replacement = pr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        replacement = p;</span><br><span class="line">    <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">            (root = replacement).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = replacement;</span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        p.parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                pp.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (movable)</span><br><span class="line">        moveRootToFront(tab, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="哪些场景可以应用红黑树？"><a href="#哪些场景可以应用红黑树？" class="headerlink" title="哪些场景可以应用红黑树？"></a>哪些场景可以应用红黑树？</h3><p>map和set都是用红黑树实现的。它可以在O(log n)时间内做查找，插入和删除等操作。</p>
<p>著名的linux进程调度<strong>Completely Fair Scheduler</strong>,用红黑树管理<strong>进程控制块。</strong></p>
<p><strong>epoll</strong>在内核中的实现，用红黑树管理事件块</p>
<p><strong>nginx</strong>中，用红黑树管理timer等</p>
<p>Java的<strong>TreeMap</strong>实现</p>
<h3 id="你了解各种树的时间复杂度吗？"><a href="#你了解各种树的时间复杂度吗？" class="headerlink" title="你了解各种树的时间复杂度吗？"></a>你了解各种树的时间复杂度吗？</h3><p><strong>二叉树</strong>：</p>
<p>​        查找时间复杂度：最好：<img src="https://math.jianshu.com/math?formula=O(lgn)" alt="O(lgn)">,最差<img src="https://math.jianshu.com/math?formula=O(n)" alt="O(n)">。最差情况是所有的数据全部在一端时。</p>
<p><strong>二叉搜索树（二叉排序树、二叉查找树）：</strong></p>
<p>​        查找时间复杂度：最好：<img src="https://math.jianshu.com/math?formula=O(lgn)" alt="O(lgn)">,最差<img src="https://math.jianshu.com/math?formula=O(n)" alt="O(n)">。最差情况是所有的数据全部在一端时。</p>
<p><strong>平衡二叉树：</strong></p>
<p>​        查找时间复杂度：<img src="https://math.jianshu.com/math?formula=O(lgn)" alt="O(lgn)"></p>
<p><strong>红黑树：</strong></p>
<p>​        查找删除插入时间复杂度：<img src="https://math.jianshu.com/math?formula=O(lgn)" alt="O(lgn)"></p>
<p><strong>B-树、B+树</strong></p>
<p>​        查找时间复杂度：<img src="https://math.jianshu.com/math?formula=O(lgn)" alt="O(lgn)"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/2020/10/29/KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>KMP 算法是 D.E.Knuth、J,H,Morris 和 V.R.Pratt 三位神人共同提出的，称之为 Knuth-Morria-Pratt 算法，简称 KMP 算法。该算法相对于 Brute-Force（暴力）算法有比较大的改进，主要是消除了主串指针的回溯，从而使算法效率有了某种程度的提高。</p>
<p>KMP适用于重复字串多的短串，在这种模式下会有很好的效果，当重复的字串不太多的时候，并且串还有点长，那么KMP的表现和暴力匹配会差不多。KMP会额外的开辟一个匹配串长度大小的空间，相当于用空间换时间。但是，既然都会了KMP，并且题目并没有明确的要求空间复杂度的时候，能用上KMP就用上。</p>
<p>推荐观看的KMP教学视频：<a href="https://www.bilibili.com/video/BV1S64y1u74P?from=search&seid=13411543487636624526">KMP算法实例详解(易懂)</a></p>
<h2 id="暴力匹配"><a href="#暴力匹配" class="headerlink" title="暴力匹配"></a>暴力匹配</h2><p>在说KMP之前，有必要了解暴力匹配，KMP就是在暴力匹配的基础上进行的算法优化。</p>
<p>现在有个题目：在字符串“111011101”找到第一个“10”的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">violentMatch</span><span class="params">(String source, String text)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] str = source.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] match = text.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; str.length &amp;&amp; j &lt; match.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == match[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i = i - j + <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == match.length) <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ViolentMatch vm = <span class="keyword">new</span> ViolentMatch();</span><br><span class="line">    System.out.println(vm.violentMatch(<span class="string">&quot;111011101&quot;</span>, <span class="string">&quot;10&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述的代码中，暴力匹配就是将匹配的字符串挨个去匹配源字符串的每个字符，如果匹配成功，匹配的字符就各自往前移动一位，否则源字符串就退回到最开始匹配的地方并且往前跳一个位置，再开始继续匹配。</p>
<p>这种匹配模式，如果源字符串和匹配字符串中有很多重复的地方，这个匹配方式依旧会挨个进行全匹配，这会很耗时间，下面说的KMP就是比较智能的方式，这个算法会跳过字符串中出现重复的地方。</p>
<p>为了实现这个操作，我们需要构造一个Next表，这个表记录着匹配的字符串匹配失败后应该跳转的位置。</p>
<h2 id="制作Next表"><a href="#制作Next表" class="headerlink" title="制作Next表"></a>制作Next表</h2><p>next表所记录的就是匹配字符串当中相同的前后缀出现的位数，进行匹配的时候，如果前面的字符串出现过，那么就跳过就好了，不需要再进行匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getNext(String text)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[text.length()];</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;<span class="comment">//相当于next表的第一个是万能符，全都能匹配，不然下面会进行死循环</span></span><br><span class="line">    <span class="keyword">int</span> i = -<span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; text.length() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == -<span class="number">1</span> || text.charAt(j) == text.charAt(i)) &#123;</span><br><span class="line">            j++;</span><br><span class="line">            i++;</span><br><span class="line">            next[j] = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = next[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>KMP和暴力匹配挺像的，但是KMP会用到next作为辅助判断，来计算匹配失败后匹配字符串所需要跳转的位置，相当于经过了一部预处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(String source, String text)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] next = getNext(text);</span><br><span class="line">    <span class="keyword">char</span>[] str = source.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] match = text.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; str.length &amp;&amp; j &lt; match.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span> || str[i] == match[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == match.length) <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>java反射</title>
    <url>/2020/10/29/java%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>JAVA反射机制是在运行状态中，对任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称之为java的反射机制。</p>
<p> JVM读取相应类的字节码文件叫做反射。</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>开发过程中经常会遇到某个类的某个成员变量、方法是私有的或者只对系统开放，这个时候使用JAVA反射机制就能够获取所需的私有成员或是方法，同样也能够使用反射来进行类的创建，降低耦合程度。另外，使用反射肯定会比直接调用慢，运行很多很多次程序的情况，反射大概比直接调用慢个50来倍，但是我们其实没有这么多需要运行百万级的反射程序。</p>
<p>如果我们需要大量的进行反射调用，那么进行缓存处理，不要反复去使用反射。</p>
<h2 id="反射相关的类"><a href="#反射相关的类" class="headerlink" title="反射相关的类"></a>反射相关的类</h2><table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Class类</td>
<td align="center">代表类的实体，在运行的Java应用程序中表示类和接口</td>
</tr>
<tr>
<td align="center">Field类</td>
<td align="center">代表类的成员变量</td>
</tr>
<tr>
<td align="center">Method类</td>
<td align="center">代表类的成员方法</td>
</tr>
<tr>
<td align="center">Constructor类</td>
<td align="center">代表类的构造方法</td>
</tr>
</tbody></table>
<h3 id="Class类-重点"><a href="#Class类-重点" class="headerlink" title="Class类(重点)"></a><strong>Class类(重点)</strong></h3><p><strong>获取类相关的方法</strong></p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">asSubclass(Class<U> class)</td>
<td align="center">把传递的类的对象转换成代表其子类的对象</td>
</tr>
<tr>
<td align="center">Cast</td>
<td align="center">把对象转换成代表类或者是接口的对象</td>
</tr>
<tr>
<td align="center">getClassLoader()</td>
<td align="center">获得类加载器</td>
</tr>
<tr>
<td align="center">getClasses()</td>
<td align="center">返回一个数组，数组中包含该类中所有公共类和接口类的对象</td>
</tr>
<tr>
<td align="center">getDeclaredClasses()</td>
<td align="center">返回一个数组，数组中包含该类中所有类和接口类的对象</td>
</tr>
<tr>
<td align="center">forName(String className)</td>
<td align="center">根据类名返回类的对象</td>
</tr>
<tr>
<td align="center">getName()</td>
<td align="center">获得类的完整路径名字</td>
</tr>
<tr>
<td align="center">newInstance()</td>
<td align="center">创建类的实例</td>
</tr>
<tr>
<td align="center">getPackage()</td>
<td align="center">获取类的包</td>
</tr>
<tr>
<td align="center">getSimpleName()</td>
<td align="center">获取类的名字</td>
</tr>
<tr>
<td align="center">getSuperclass()</td>
<td align="center">获取当前类继承的父类的名字</td>
</tr>
<tr>
<td align="center">getInterfaces()</td>
<td align="center">获取当前类实现的类或是接口</td>
</tr>
</tbody></table>
<p><strong>获取类中属性的方法</strong></p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getField(String name)</td>
<td align="center">获得某个共有的属性对象</td>
</tr>
<tr>
<td align="center">getField()</td>
<td align="center">获得所有共有的属性对象</td>
</tr>
<tr>
<td align="center">getDeclaredField(String name)</td>
<td align="center">获得某个属性对象</td>
</tr>
<tr>
<td align="center">getDeclaredFields()</td>
<td align="center">获得所有属性对象</td>
</tr>
</tbody></table>
<p><strong>获取类中注解相关的方法</strong></p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getAnnotation(Class<A> annotationClass)</td>
<td align="center">返回该类中参与参数类型匹配的公有注解对象</td>
</tr>
<tr>
<td align="center">getAnnotations()</td>
<td align="center">返回该类所有的共有注解对象</td>
</tr>
<tr>
<td align="center">getDeclaredAnnotation(Class<A> annotationClass)</td>
<td align="center">返回该类中与参数类型匹配的所有注解对象</td>
</tr>
<tr>
<td align="center">getDeclaredAnnotations()</td>
<td align="center">返回该类中所有的注解对象</td>
</tr>
</tbody></table>
<p><strong>获取类中构造器相关的方法</strong></p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getConstructor(Class..&lt;?&gt; parameterTypes)</td>
<td align="center">获得该类中与参数类型匹配的公有构造方法</td>
</tr>
<tr>
<td align="center">getConstructor()</td>
<td align="center">获得该类的所有共有构造方法</td>
</tr>
<tr>
<td align="center">getDeclaredConstructor(Class…&lt;?&gt; parameterTypes)</td>
<td align="center">获得该类中与参数类型匹配的构造方法</td>
</tr>
<tr>
<td align="center">getDeclaredConstructors()</td>
<td align="center">获得该类中所有构造方法</td>
</tr>
</tbody></table>
<p><strong>获取类中方法相关的方法</strong></p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getMethod(String name, Class…&lt;?&gt; parameterTypes)</td>
<td align="center">获得该类某个公有的方法</td>
</tr>
<tr>
<td align="center">getMethod()</td>
<td align="center">获得该类所有共有的方法</td>
</tr>
<tr>
<td align="center">getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes)</td>
<td align="center">获得该类某个方法</td>
</tr>
<tr>
<td align="center">getDeclaredMethods()</td>
<td align="center">获得该类所有方法</td>
</tr>
</tbody></table>
<p> <strong>类中其他重要的方法</strong></p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">isAnnotation()</td>
<td align="center">判断是否是注解类型</td>
</tr>
<tr>
<td align="center">isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</td>
<td align="center">判断是否是注定类型注解</td>
</tr>
<tr>
<td align="center">isAnonymousClass()</td>
<td align="center">判断是否是匿名类</td>
</tr>
<tr>
<td align="center">isArray()</td>
<td align="center">判断是否是数组</td>
</tr>
<tr>
<td align="center">isEnum()</td>
<td align="center">判断是否是枚举类型</td>
</tr>
<tr>
<td align="center">isInstance(Object obj)</td>
<td align="center">判断是否是obj</td>
</tr>
<tr>
<td align="center">isInterface()</td>
<td align="center">判断是否是接口</td>
</tr>
<tr>
<td align="center">isLocalClass()</td>
<td align="center">判断是否是局部类</td>
</tr>
<tr>
<td align="center">isMemberClass()</td>
<td align="center">判断是否是内部类</td>
</tr>
</tbody></table>
<h3 id="Field类"><a href="#Field类" class="headerlink" title="Field类"></a>Field类</h3><p>Field代表类的成员变量(成员变量也成为类的属性)</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">equals(Object obj)</td>
<td align="center">属性与obj相等则返回true</td>
</tr>
<tr>
<td align="center">get(Object obj)</td>
<td align="center">获得obj中对应的属性值</td>
</tr>
<tr>
<td align="center">set(Object obj)</td>
<td align="center">设置obj中对应的属性值</td>
</tr>
<tr>
<td align="center">setAccessible(Boolean flag)</td>
<td align="center">是否关闭java语言访问检查（关闭可提高反射运行速度）</td>
</tr>
</tbody></table>
<h3 id="Method类"><a href="#Method类" class="headerlink" title="Method类"></a>Method类</h3><p>只有一个执行方法，但是很重要</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">invoke(Object obj, Object … args)</td>
<td align="center">传递object对象及参数调用该对象对应的方法</td>
</tr>
</tbody></table>
<h3 id="Constructor类"><a href="#Constructor类" class="headerlink" title="Constructor类"></a>Constructor类</h3><p>类的构造方法</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">newInstance(Object… initargs)</td>
<td align="center">根据传递的参数创造类的对象</td>
</tr>
</tbody></table>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>要玩反射，那么就需要有个反射的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Lehanbal.study.Reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, String age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;起飞&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">toilet</span><span class="params">(<span class="keyword">int</span> genderIdx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (genderIdx) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> -&gt; System.out.println(<span class="string">&quot;进男厕所&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> -&gt; System.out.println(<span class="string">&quot;进女厕所&quot;</span>);</span><br><span class="line">            <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;宁就是女权终结者？&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&#x27;&quot;</span> + age + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>封装一下反射的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Lehanbal.study.Reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String personPath = <span class="string">&quot;Lehanbal.study.Reflect.Person&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reflectNewInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class&lt;?&gt; classPerson = Class.forName(personPath);</span><br><span class="line">            Person person = (Person) classPerson.getConstructor().newInstance();</span><br><span class="line">            person.setName(<span class="string">&quot;懒汉&quot;</span>);</span><br><span class="line">            person.setAge(<span class="string">&quot;24&quot;</span>);</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reflctPrivateConstructor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Person person = (Person)Class.forName(personPath).getDeclaredConstructor(String.class, String.class).newInstance(<span class="string">&quot;懒汉&quot;</span>, <span class="string">&quot;23&quot;</span>);</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射私有属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reflectPrivateField</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class&lt;?&gt; personClass = Class.forName(personPath);</span><br><span class="line">            Object personObj = personClass.getConstructor().newInstance();</span><br><span class="line">            Field field = personClass.getDeclaredField(<span class="string">&quot;TEST&quot;</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            System.out.println((String) field.get(personObj));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射私有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reflectPrivateMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class&lt;?&gt; personClass = Class.forName(personPath);</span><br><span class="line">            Method method = personClass.getDeclaredMethod(<span class="string">&quot;toilet&quot;</span>, <span class="keyword">int</span>.class);</span><br><span class="line">            method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object o = personClass.getConstructor().newInstance();</span><br><span class="line">            method.invoke(o, <span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        reflectNewInstance();</span><br><span class="line">        reflctPrivateConstructor();</span><br><span class="line">        reflectPrivateField();</span><br><span class="line">        reflectPrivateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p>Person{name=’懒汉’, age=’24’}</p>
<p>Person{name=’懒汉’, age=’23’}</p>
<p>Test</p>
<p>进男厕所</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>B-树、B+树</title>
    <url>/2020/10/29/B-%E6%A0%91%E3%80%81B-%E6%A0%91/</url>
    <content><![CDATA[<p><strong>B-树的“-”是不发音的！</strong></p>
<h2 id="先看2-3树"><a href="#先看2-3树" class="headerlink" title="先看2-3树"></a>先看2-3树</h2><p>本质上，2-3树是一颗最简单的B-树，其每个非叶节点都有两个或三个子女，而且所有叶都在统一层上。2-3树不是二叉树，其节点可拥有3个孩子。不过，2-3树与满二叉树相似。高为h的2-3树包含的节点数大于等于高度为h的满二叉树的节点数，即至少有2^h-1个节点。</p>
<p>说人话，2-3树就是比满二叉树的节点多。</p>
<p>先别看规则，向上个图，感受一下。</p>
<p><img src="http://cdn.lehanbal.top/2-3%E6%A0%91.png" alt="2-3树"></p>
<p>2-3的节点规则：</p>
<ol>
<li>2-节点有两个孩子，必含一个数据项，其查找关键字大于左孩子的查 找关键字，而小于右孩子的查找关键字。</li>
<li>3-节点有三个孩子 ，必含两个数据项，其查找关键字S和L满足下列关系：S大于左孩子的查找关键字，而小于中孩子的查找关键字；L大于中孩子的查找关键字，而小于右孩子的查找关键字。</li>
<li>叶子可以包含一个或两个数据项。</li>
</ol>
<p>对着图读一遍规则，这样就能更快一点理解这是个啥东西。</p>
<h3 id="2-3树查找元素"><a href="#2-3树查找元素" class="headerlink" title="2-3树查找元素"></a>2-3树查找元素</h3><p>在上面的定义中，我们可以知道2-3树是根据元素的大小来决定查找的方向的。要找到我们需要的元素，我们就需要将元素和当前的节点进行比较，其实和二叉搜索树的查找的方式很相似，只不过这里不是二叉树罢了。我直接上个案例来说明整个查找情况。</p>
<p><img src="https://gitee.com/lehanbal/blog-image/raw/master/img/2-3%E6%A0%91%E6%9F%A5%E6%89%BE1.png" alt="2-3树查找1"></p>
<h3 id="2-3树插入元素"><a href="#2-3树插入元素" class="headerlink" title="2-3树插入元素"></a>2-3树插入元素</h3><p>插入元素就显得略为复杂，主要分为以下四种情况，当然如果是空树的话直接创建一个节点即可。</p>
<ol>
<li><p>向一颗2-节点插入元素</p>
<p>如果未命中元素，并且是在2-节点结束的，那就把当前的2-节点变成3-节点，并且把插入的元素加进去即可。</p>
<p><img src="http://cdn.lehanbal.top/2-3%E6%A0%91%E6%8F%92%E5%85%A5%E6%83%85%E5%86%B51.png" alt="2-3树插入情况1"></p>
</li>
<li><p>向一个父节点是2-节点的3-节点插入元素</p>
<p>将3-节点临时变成4-节点，然后将中间节点抽出分解成3个2-节点，将中间节点向上合并，完成插入操作。</p>
<p><img src="http://cdn.lehanbal.top/2-3%E6%A0%91%E6%8F%92%E5%85%A5%E6%83%85%E5%86%B52.png" alt="2-3树插入情况2"></p>
</li>
<li><p>向一个父节点是3-节点的3-节点插入元素</p>
<p>插入元素的时候，先临时变成4-节点，然后把它分解了，将中间的元素向上合并，父节点继续变成4-节点，再分解，中间的元素再向上合并。知道遇到2-节点，把2-节点变成3-节点，此时便不再分解。<strong>如果根节点分解了，那么树高+1</strong>。</p>
<p><img src="http://cdn.lehanbal.top/2-3%E6%A0%91%E6%8F%92%E5%85%A5%E6%83%85%E5%86%B53.1.png" alt="2-3树插入情况3.1"></p>
</li>
</ol>
<p><img src="http://cdn.lehanbal.top/2-3%E6%A0%91%E6%8F%92%E5%85%A5%E6%83%85%E5%86%B53.2.png" alt="2-3树插入情况3.2"></p>
<h3 id="2-3树删除元素"><a href="#2-3树删除元素" class="headerlink" title="2-3树删除元素"></a>2-3树删除元素</h3><p>删除元素的思路和二叉搜索树的删除情况类似，如果删除的是非叶子节点，都是通过将非叶子节点的后继节点代替它，然后转换成删除叶子节点的问题。</p>
<p>删除叶子节点有以下五种情况：</p>
<ol>
<li><p>删除的节点不是2-节点，这种情况可以直接删除，将3-节点删除其中一个元素使它转换成2-节点。</p>
<p><img src="http://cdn.lehanbal.top/2-3%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B51.png" alt="2-3树删除情况1"></p>
</li>
<li><p>删除的节点是2-节点，父节点是2-节点，兄弟节点是3-节点，这种时候删除节点后将父节点移动到被删除节点的位置然后将兄弟节点中最接近父节点的值移动到父节点的位置。（左旋）</p>
<p><img src="http://cdn.lehanbal.top/2-3%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B52.png" alt="2-3树删除情况2"></p>
</li>
<li><p>删除的节点是2-节点，兄弟节点也是2-节点，（不是满二叉树）这时候我们需要将父节点的父节点的直接后继拆分来顶替父节点的位置，然后父节点与兄弟节点结合从3-节点，进行左旋操作即可。</p>
<p><img src="http://cdn.lehanbal.top/2-3%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B53.png" alt="2-3树删除情况3"></p>
</li>
<li><p>删除的节点是2-节点，父节点是3-节点，那么我们需要将父节点拆成两个2-节点，然后将父节点中最接近的一个元素与孩子结合，合并成一个3-节点。</p>
<p><img src="http://cdn.lehanbal.top/2-3%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B54.png" alt="2-3树删除情况4"></p>
</li>
<li><p>删除的是一个满二叉树的叶子节点，这个时候，就开始降维打击了，将删除节点的兄弟节点与父节点结合成3-节点，父节点的所有兄弟节点合并到父节点的都节点中，如果生成4-节点，那就拆分4-节点即可。</p>
</li>
</ol>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h2><p>B-树全名 Balance Tree<strong>读做B树(中间的-，只是分隔作用，不要读做B减树)。</strong></p>
<p>B树首先它也是属于树结构，除了树结构的节点有序、查找高效外，还有以下特性。以一个m阶的B树来举栗：</p>
<ol>
<li>根节点至少包含两个子节点；</li>
<li>每个中间节点包括k-1个元素和k个子节点，其中m/2 &lt;= k &lt;= m</li>
<li>每一个叶子节点包含k-1个元素，其中m/2 &lt;= k &lt;= m</li>
<li>每个节点的元素从大到小有序，节点当中k-1个元素是k个子节点的值域的划分。</li>
</ol>
<p>说人话，就是我们之前说的2-3树扩展，不过2-3树只不过是m=3的B-树罢了。</p>
<p>对应的，2-3-4树就是m=4的B-树。</p>
<p>查找、插入以及删除的概念在2-3树的时候已经完全介绍了，这里说明B-树有什么用，为什么数据库的索引会用到B-树。</p>
<h3 id="二叉搜索树的查询速度都已经是logN了，B-树B-树会比这个效率还高吗？"><a href="#二叉搜索树的查询速度都已经是logN了，B-树B-树会比这个效率还高吗？" class="headerlink" title="二叉搜索树的查询速度都已经是logN了，B-树B+树会比这个效率还高吗？"></a>二叉搜索树的查询速度都已经是logN了，B-树B+树会比这个效率还高吗？</h3><p>答案是当然不会，它的查询方式就是基于二分查找，但是当磁盘的存储数据较大的时候，树的高度会变高。在进行索引的查询的时候，并不会把整个索引全部加载到内存，会逐一加载每个磁盘页面，当树变高的时候，会需要增加读取磁盘页的次数，相对的也就增加了查询时间。</p>
<p>所以我们需要一种数据结构，压缩这棵树的高度，这就是B-树，把树变得矮胖，在内存中比较数值的速度的性能和时间消耗远远小于磁盘IO的速度，所以通过压缩树的高度对于大批的数据检索来说，是优于二叉搜索树的。</p>
<h3 id="B-树主要作用在什么地方"><a href="#B-树主要作用在什么地方" class="headerlink" title="B-树主要作用在什么地方"></a>B-树主要作用在什么地方</h3><p>B-树主要应用于文件系统以及部分数据库索引，非关系型数据库MongoDB的索引用的就是B-树结构。</p>
<h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h2><p>B+树是B-树的一种变形形式，B+树上的叶子结点存储关键字以及相应记录的地址，叶子结点以上各层作为索引使用。一棵m阶的B+树定义如下:</p>
<ol>
<li>中间元素不存数据，只是当索引用，所有数据都保存在叶子结点中。</li>
<li>所有的中间节点在子节点中要么是最大的元素，要么是最小的元素 。</li>
<li>叶子结点包含所有的数据，和指向这些元素的指针，而且叶子结点的元素形成了自小向大这样子的链表。</li>
</ol>
<p>B+树的查找与B树不同，当索引部分某个结点的关键字与所查的关键字相等时，并不停止查找，应继续沿着这个关键字左边的指针向下，一直查到该关键字所在的叶子结点为止。</p>
<p>上个图，体会一下：</p>
<p><img src="http://cdn.lehanbal.top/B+%E6%A0%91.png" alt="B+树"></p>
<p>因为B+树的非叶子节点并没有存储数据，所以一个磁盘页可以存储更多的数据，也就是说，B+树会比B-树更加矮胖，所以查询IO次数更少，查询速度也就更快。</p>
<p>B+树的叶子节点会形成一个链表，当我们需要查询下一个数据的时候，并不需要从头开始继续查找，而是顺着链表就能够摸到我们需要的数，更优的查询效率。</p>
<p>B+树的插入删除操作与B-树的操作大同小异，我不写了，感兴趣的自行百度。</p>
<h3 id="B-树的优势"><a href="#B-树的优势" class="headerlink" title="B+树的优势"></a>B+树的优势</h3><ol>
<li>单一节点存储更多的元素，使得查询的IO次数更少。</li>
<li>所有查询都要查找到叶子节点，查询性能稳定。</li>
<li>所有叶子节点形成有序链表，便于范围查询。</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>大小堆的实现</title>
    <url>/2020/10/20/%E5%A4%A7%E5%B0%8F%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>我在讲PriorityQueue这一个优先级队列的时候，说了它底层其实是一个大小堆来实现的优先级存储，我也粗略的点了一下大小堆的概念，这次的文章就详细的说一下堆排序是如何实现的。</p>
<h2 id="堆与堆排序的定义"><a href="#堆与堆排序的定义" class="headerlink" title="堆与堆排序的定义"></a>堆与堆排序的定义</h2><p><strong>堆</strong>：堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p>
<p><strong>堆排序</strong>：（英语：Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足<strong>堆积的性质</strong>：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p><img src="http://cdn.lehanbal.top/%E5%A4%A7%E9%A1%B6%E5%A0%86%E4%B8%8E%E5%B0%8F%E9%A1%B6%E5%A0%86.png" alt="大顶堆与小顶堆"></p>
<p>那就有一个公式：</p>
<p><strong>大顶堆</strong>：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</p>
<p><strong>小顶堆</strong>：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</p>
<h2 id="堆排序过程"><a href="#堆排序过程" class="headerlink" title="堆排序过程"></a>堆排序过程</h2><p>整体过程：将待排序的序列构造成大顶堆，此时最大值就是堆的顶点，此时将堆顶和末尾元素进行交换，此时末尾就是最大节点。再把除了末尾节点的剩下元素重新构造成大顶堆，此时堆顶是次最大元素，再与末尾元素-1的位置交换······如此反复，得到的就是一个升序的序列。（如果要降序序列，那就使用小顶堆重复一样的过程）</p>
<p>接下来模拟整个过程：</p>
<h3 id="堆调整"><a href="#堆调整" class="headerlink" title="堆调整"></a>堆调整</h3><ol>
<li><p>首先假定一个无序序列</p>
<p><img src="http://cdn.lehanbal.top/%E5%A0%86%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B1.png" alt="堆排序过程1"></p>
</li>
<li><p>然后从最后一个非叶子节点开始（arr.length / 2 - 1），也就是图中的序号1节点，调整它的位置。</p>
<p><img src="http://cdn.lehanbal.top/%E5%A0%86%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B2.png" alt="堆排序过程2"></p>
</li>
<li><p>再继续找下一个非叶子节点，也就是根节点，对它进行堆调整。</p>
<p><img src="http://cdn.lehanbal.top/%E5%A0%86%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B3.png" alt="堆排序过程3"></p>
</li>
<li><p>注意这个时候我们把0和1的位置进行的调换，换下来的值可能会造成原先已经是大顶堆的子节点顺序被破坏，此时就需要重新对子节点进行依次堆调整。（换句话说，就是只要我们动了非叶子节点的父节点，那么它父节点往下的非叶子节点都需要重新堆调整一次，使用递归来完成）</p>
<p>我们得到了我们需要的大顶堆：</p>
<p><img src="http://cdn.lehanbal.top/%E5%A0%86%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B4.png" alt="堆排序过程4"></p>
</li>
</ol>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ol>
<li><p>我们将堆顶元素和末尾元素交换顺序。</p>
<p><img src="http://cdn.lehanbal.top/%E5%A0%86%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B5.png" alt="堆排序过程5"></p>
</li>
<li><p>重新调整除了末尾元素的堆，使得再次成为大顶堆。</p>
<p><img src="http://cdn.lehanbal.top/%E5%A0%86%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B6.png" alt="堆排序过程6"></p>
</li>
<li><p>将堆顶元素和次末尾元素交换顺序。</p>
<p><img src="http://cdn.lehanbal.top/%E5%A0%86%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B7.png" alt="堆排序过程7"></p>
</li>
<li><p>重复2、3操作，最终得到的结果</p>
<p><img src="http://cdn.lehanbal.top/%E5%A0%86%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B8.png" alt="堆排序过程8"></p>
</li>
</ol>
<p>最终我们通过大顶堆实现了一个升序序列。</p>
<h3 id="堆排序的时间复杂度"><a href="#堆排序的时间复杂度" class="headerlink" title="堆排序的时间复杂度"></a>堆排序的时间复杂度</h3><p>堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。其中构建初始堆经推导复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)…1]逐步递减，近似为nlogn。所以堆排序时间复杂度一般认为就是O(nlogn)级。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;<span class="comment">//从第一个非叶子节点，从下到上，从左到右调整</span></span><br><span class="line">            adjustHeap(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = arr.length - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">            swap(arr, <span class="number">0</span>, j);<span class="comment">//与队尾元素交换</span></span><br><span class="line">            adjustHeap(arr, <span class="number">0</span>, j);<span class="comment">//重新调整剩下的堆</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];<span class="comment">//取出当前元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i * <span class="number">2</span> + <span class="number">1</span>; k &lt; length; k = k * <span class="number">2</span> + <span class="number">1</span>)&#123;<span class="comment">//跳到i的左节点，每次都先跳到左节点</span></span><br><span class="line">            <span class="keyword">if</span>(k + <span class="number">1</span> &lt; length &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>]) k++;<span class="comment">//如果右节点存在并且比左节点还要大，那就指向右节点</span></span><br><span class="line">            <span class="keyword">if</span>(arr[k] &gt; temp)&#123;<span class="comment">//如果子节点大于父节点，那就覆盖掉父节点的值</span></span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                i = k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp;<span class="comment">//将被覆盖的父节点放到最终的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>JAVA</tag>
        <tag>堆</tag>
      </tags>
  </entry>
</search>
